[{"title":"香菇蒜苗炒肉","url":"/2025/03/17/stir-fried-meat-with-mushrooms-and-garlic-sprouts.html","content":"食材用料   食材   数量   香菇   500克   蒜苗   四根   猪肉   500克   油   适量   葱   适量   蒜   适量   辣椒   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：花椒、辣椒、葱、蒜   3.    香菇切片   4.    蒜苗切段   5.    猪肉切丝   6.    香菇焯水备用   7.    放油下猪肉炒出香味，加入老抽上色   8.    肉撇到一边，放入调料炒香   9.    放入香菇翻炒   10.    放入蒜苗、盐、生抽翻炒均匀   11.    出锅   12.    装盘","categories":["cookbook"]},{"title":"NPM Error Resolve","url":"/2024/11/01/npm-error-resolve.html","content":"postinstall error   环境   版本   windows   10   node   20.14.0   pnpm   9.4.0   当第一次执行    pnpm install    或    npm install    时 PNPM报错：npm postinstall failed command not found node ./scripts/postinstall.js   解决方案1：   运行命令   rimraf .\\node_modules\\   npm cache clean --force   pnpm store prune   解决方案2：   找到报错的插件所在的 package.json 文件   把 package.json 中的 scripts.postinstall 的命令找个地方记录下来，并修改命令为    pnpm --version   然后执行一次    pnpm install    完成后将会发现报错的插件 postinstall 执行成功   挨个进入报错的插件所在的 package.json 文件层级   挨个执行该插件原有的 postinstall 命令   pnpm dev    启动成功。。。   node-pre-gyp error   插件   版本   linux   13.6.0   node   18.20.4   npm   10.7.0   当第一次执行    npm install    时，有时会出现 npm error node-pre-gyp。   原因   https://github.com/mozilla/pdf.js#user-content-getting-the-code   On MacOS M1/M2 you may see some node-gyp-related errors when running npm install. This is because one of our dependencies, &quot;canvas&quot;, does not provide pre-built binaries for this platform and instead npm will try to build it from source. Please make sure to first install the necessary native dependencies using brew:    https://github.com/Automattic/node-canvas#compiling   .   解决方案：   参考    https://github.com/Automattic/node-canvas#compiling    给的解决办法，给环境添加图片插件支持。   移除项目中所有与 canvas (项目名: node-canvas) 相关的插件。","categories":["javascript"]},{"title":"Windows PowerShell Assist","url":"/2024/05/16/windows-powershell-assist.html","content":"输出颜色字体   function Write-Color([String[]]$Text, [ConsoleColor[]]$Color) {  for ($i = 0; $i -lt $Text.Length; $i++) {    Write-Host $Text[$i] -Foreground $Color[$i] -NoNewLine  }  Write-Host}# Usage$scriptLocationPath = (Get-Location).PathWrite-Color -Text \"Title: \", \"Write Color\" -Color Blue, GreenWrite-Color -Text \"Script Path: \", $scriptLocationPath -Color Blue, Green","categories":["script"]},{"title":"Windows 创建新PowerShell窗口","url":"/2024/05/16/windows-crate-new-powershell-window.html","content":"通过双击执行CMD/BAT脚本创建新PowerShell窗口   :: start.batstart Powershell -executionpolicy RemoteSigned -noexit -file \".\\powershell-window.ps1\" \"Argument 1\" \"Argument 2\"# powershell-window.ps1$param1 = $args[0]$param2 = $args[1]$host.ui.RawUI.WindowTitle = \"Hello PowerShell\"Write-Output \"I'm $param1\"Write-Output \"I'm $param2\"// 可以运行一些命令ipconfignode -vnpm run dev   通过双击执行CMD/BAT脚本创建新CMD窗口   :: start.batstart \"Title\" /d C:\\xxx\\xxx cmd /k \"echo npm run dev &amp;&amp; npm run dev\"","categories":["script"]},{"title":"Configuration","url":"/2024/01/25/configuration.html","content":"Git   core.autocrlf   git config --global core.autocrlf false# true：auto convert CRLF to LF or convert to CRLF when git checkout.# false：no convert.git config --global core.safecrlf true# warn(default): Warning when submitting a file that contains mixed newlines.# true: Refuse to submit files containing mixed newlines (Fatal:xxx is displayed).# false: Allows you to submit files that contain mixed newlines.   .gitattributes    文件   # Set the default behavior, in case people don&apos;t have core.autocrlf set.* text=auto# Explicitly declare text files you want to always be normalized and converted# to native line endings on checkout.*.c text*.h text# Declare files that will always have CRLF line endings on checkout.*.sln text eol=crlf# Denote all files that are truly binary and should not be modified.*.png binary*.jpg binary   Gvim   Open _vimrc file, add flowing code:   # Setting show ^M and $ symbol:set encoding=utf-8:scriptencoding utf-8:set binary:set list:set listchars=tab:&gt;-,eol:$,space:·","categories":["note"]},{"title":"Windows CMD常用命令大全","url":"/2023/11/23/windows-cmd-commands.html","content":"执行 CMD 命令有两种方式：   通过命令提示符窗口执行命令：鼠标右键开始按钮并弹出菜单，点击运行（快捷键：Win + R），在输入框内输入 cmd 点击确定。   通过创建后缀名为 .cmd 或 .bat 的脚本文件执行 CMD 命令。   创建 .cmd 脚本文件执行 CMD 命令。   这里将会创建一个标题为 Hello World 的命令提示符窗口，并在里面执行输出 Hello World!，创建文件等操作。   rem start.cmdrem \"rem\"和\"::\"是批处理中的注释start \"Hello World\" cmd /k .\\input.batrem input.cmdrem chcp 改变页面编码，UTF-8的代码是65001，解决命令行中文乱码问题chcp 65001@echo Hello World!@echo offset /p text=请输入： (PS: 使用set设置变量, 使用/p参数阻塞命令, 等待输入完成后再执行其他命令.)echo 你输入的内容为%text%set /p isSave=是否保存为文件？(y/n)if \"%isSave%\" == \"y\" (  if exist 输入的内容.txt (    @echo 输入的内容.txt 文件已存在  )  @echo %text%&gt;&gt;输入的内容.txt  @echo 文件已保存.) else (  echo 不保存文件.)pause   附录：    Windows 命令大全   1.    cd 命令   ,    (chdir 命令)   显示当前目录的名称或更改当前目录。 如果仅与驱动器号一起使用（例如，cd C:），cd 将显示指定驱动器中当前目录的名称。 如果使用时不带参数，cd 将显示当前驱动器和目录。   如果跳转的路径在不同盘需要添加/d参数，否则无法跳转。   语法   cd [/d] [&lt;drive&gt;:][&lt;path&gt;]cd [..]   参数   说明   /d   更改当前驱动器以及驱动器的当前目录。   &lt;drive&gt;:   指定要显示或更改的驱动器（如果与当前驱动器不同）。   &lt;path&gt;   指定要显示或更改的目录的路径。   [..]   指定要更改为父文件夹。   /?   在命令提示符下显示帮助。   示例   rem  CMD 执行路径: $ C:\\Users\\liuzane&gt;D:                  // 进入d盘F:                  // 进入F盘cd \\                // 跳转到当前硬盘的根目录cd C:\\WINDOWS       // 跳转到C盘的WINDOWS文件夹，（相同驱动器下不需要/d参数）cd /d e:\\software   // 跳转到e盘的software文件夹，（需要添加/d参数）cd..                // 跳转到上一层目录   2.    dir 命令   显示目录的文件和子目录的列表。   语法   dir [&lt;drive&gt;:][&lt;path&gt;][&lt;filename&gt;] [...] [/p] [/q] [/w] [/d] [/a[[:]&lt;attributes&gt;]][/o[[:]&lt;sortorder&gt;]] [/t[[:]&lt;timefield&gt;]] [/s] [/b] [/l] [/n] [/x] [/c] [/4] [/r]   参数   说明   [&lt;drive&gt;:][&lt;path&gt;]   指定要查看其列表的驱动器和目录。   [&lt;filename&gt;]   指定要查看其列表的特定文件或文件组。   /p   一次显示一个列表屏幕。 要查看下一个屏幕，请按任意键。   /q   显示文件所有权信息。   /w   以宽格式显示列表，每行最多包含五个文件名或目录名称。   /d   以与 /w 相同的格式显示列表，但文件按列排序。   /a[[:]&lt;attributes&gt;]   仅显示具有指定属性的目录和文件的名称。 如果不使用此参数，此命令将显示除隐藏文件和系统文件之外的所有文件的名称。 如果在未指定任何属性的情况下使用此参数，则此命令将显示所有文件的名称，包括隐藏文件和系统文件。 可能的属性值列表包括：   d - 目录   h - 隐藏文件   s - 系统文件   l - 重新分析点   r - 只读文件   a - 可用于存档的文件   i - 非内容索引文件    你可以使用这些值的任意组合，但不要使用空格分隔值。 （可选）可以使用冒号 (   :   ) 分隔符，或者你可以使用连字符 (   -   ) 作为前缀来表示“非”。 例如，使用    -s    属性不会显示系统文件。   /o[[:]&lt;sortorder&gt;]   根据 sortorder 对输出进行排序，可以是以下值的任意组合：    n - 按名称字母顺序排列   e - 按扩展名字母顺序排列   g - 首先列出组目录   s - 按大小，最先列出最小的文件   d - 按日期/时间，最先列出最早的文件   使用 - 前缀可反转排序顺序    多个值将按照你列出它们的顺序进行处理。 不要用空格分隔多个值，但可以选择使用冒号 (   :   )。     如果未指定 sortorder，则    dir /o    将按字母顺序列出目录，后跟文件，这些文件也按字母顺序排序。   /t[[:]&lt;timefield&gt;]   指定要显示或用于排序的时间字段。 timefield 的可用值包括：    c - 创建时间   a - 上次访问时间   w - 最后写入时间   /s   列出指定目录和所有子目录中出现的指定文件名的每个匹配项。   /b   显示纯粹的目录和文件列表，不含其他信息。    /b    参数将覆盖    /w   。   /l   使用小写显示未排序的目录名称和文件名。   /n   在屏幕最右侧显示带有文件名的长列表格式。   /x   显示为非 8dot3 文件名生成的短名称。 显示内容与    /n    的显示内容相同，但短名称插入到长名称之前。   /c   以千位分隔符显示文件大小。 此选项为默认行为。 使用    /-c    隐藏分隔符。   /4   以四位数格式显示年份。   /r   以四位数格式显示年份。   /?   在命令提示符下显示帮助。   注解   若要使用多个 filename 参数，请用空格、逗号或分号分隔每个文件名。   可以使用通配符（* 或 ?）来表示文件名的一个或多个字符，并显示文件或子目录的子集。   可以使用通配符 * 来替换任何字符串，例如：   dir *.txt    将列出当前目录中扩展名以 .txt 开头的所有文件，例如 .txt、.txt1、.txt_old。   dir read *.txt    将列出当前目录中以 read 开头并且扩展名以 .txt 开头的所有文件，例如 .txt、.txt1 或 .txt_old。   dir read *.*    将列出当前目录中以 read 开头的所有文件（无论任何扩展名）。 星号通配符始终使用短文件名映射，因此你可能会得到意外的结果。 例如，以下目录包含两个文件（t.txt2 和 t97.txt）： 你可能期望键入    dir t97\\*    后将返回文件 t97.txt。 但是，键入 dir t97* 会返回这两个文件，因为星号通配符使用其短名称映射 T97B4~1.TXT，因此会认为文件 t.txt2 与 t97.txt 匹配。 同样，键入 del t97* 会删除这两个文件。   可以使用问号 (   ?   ) 代替名称中的单个字符。 例如，键入    dir read???.txt    会列出当前目录中扩展名为 .txt 的任何文件，这些文件以 read 开头，后跟最多三个字符。 这包括 Read.txt、Read1.txt、Read12.txt、Read123.txt 和 Readme1.txt，但不包括 Readme12.txt。   如果在 attributes 中使用    /a    和多个值，则此命令仅显示具有所有指定属性的文件的名称。 例如，如果将    /a    与    r    和    -h    一起使用作为属性（使用    /a:r-h    或    /ar-h   ），则此命令将仅显示未隐藏的只读文件的名称。   如果指定多个 sortorder 值，则此命令将首先按第一个条件对文件名进行排序，然后按第二个条件排序，依此类推。 例如，如果将    /o    与 sortorder 的    e    和    -s    参数一起使用（使用    /o:e-s    或 /oe-s），则此命令按扩展名对目录和文件的名称进行排序，首先显示最大的文件，然后显示最终结果。 按扩展名按字母顺序排序会导致首先显示没有扩展名的文件名，然后显示目录名称，然后显示带有扩展名的文件名。   如果使用重定向符号 (   &gt;   ) 将此命令的输出发送到文件，或者使用管道符号 (   |   ) 将此命令的输出发送到另一个命令，则必须使用    /a:-d    和    /b   ，以仅列出文件名。 可以将 filename 与    /b    和    /s    一起使用，以指定此命令要在当前目录及其子目录中搜索与 filename 参数匹配的所有文件名。 此命令仅列出它找到的每个文件名的驱动器号、目录名、文件名和文件扩展名（每行一个路径）。 在使用管道符号将此命令的输出发送到另一个命令之前，应首先在 Autoexec.nt 文件中设置 TEMP 环境变量。   示例   dir                       // 查看当前目录下的文件，类似于linux下的lsdir /s/w/o/p/a:-d         // 显示文件名和扩展名，但省略目录名称dir c:\\*.txt /w/o/s/p     // 显示驱动器 C 上所有目录中扩展名为.txt 的所有文件名的列表dir &gt; \\records\\dir.doc    // 将 dir 命令的输出重定向到文件                          // 如果 dir.doc 不存在，dir 将创建此文件                          // 除非 records 目录不存在。 如果 records 目录不存在                          // 将显示消息： `File creation error`   3.    md 命令   ,    (mkdir 命令)   创建目录或子目录。 命令扩展（默认情况下启用）允许使用单个 md 命令在指定路径中创建中间目录。   语法   md [&lt;drive&gt;:]&lt;path&gt;   参数   说明   &lt;drive&gt;:   指定要在其中创建新目录的驱动器。   &lt;path&gt;   指定新目录的名称和位置。 任何单个路径的最大长度都是由文件系统决定的。 这是必需参数。   /?   在命令提示符下显示帮助。   示例   md Directory1                // 在当前目录中创建名为 Directory1 的目录md \\Taxes\\Property\\Current   // 在启用命令扩展的情况下在根目录中创建目录树 Taxes\\Property\\Current   4.    rd 命令   ,    (mkdir 命令)   删除目录。   语法   rd [&lt;drive&gt;:]&lt;path&gt; [/s [/q]]   参数   说明   [&lt;drive&gt;:]&lt;path&gt;   指定要删除的目录的位置和名称。 Path 是必需的。 如果在指定 path 的开头包含反斜杠 ()，则该 path 从根目录开始（无论当前目录为何）。   /s   删除目录树（指定目录及其所有子目录，包括所有文件）。   /q   指定安静模式。 删除目录树时不提示进行确认。 仅当还指定了 /s 时，/q 参数才有效。   注意：在安静模式下运行时，无需确认即可删除整个目录树。 在使用 /q 命令行选项之前，请确保移动或备份重要文件。   /?   在命令提示符下显示帮助。   示例   rd /s test       // 从当前目录中删除名为 test 的目录（及其所有子目录和文件）rd /s /q test    // 在安静模式下运行上一个示例   5.    copy 命令   将一个或多个文件从一个位置复制到另一个位置。   语法   copy [/d] [/v] [/n] [/y | /-y] [/z] [/a | /b] &lt;source&gt; [/a | /b] [+&lt;source&gt; [/a | /b] [+ ...]] [&lt;destination&gt; [/a | /b]]   参数   说明   /d   允许将复制的加密文件作为解密文件保存到目标。   /v   验证是否已正确写入新文件。   /n   在复制名称超过八个字符或文件扩展名超过三个字符的文件时使用短文件名（如果可用）。   /y   禁止提示你确认覆盖现有目标文件。   /-y   提示你确认覆盖现有目标文件。   /z   以可重启模式复制网络文件。   /a   指示 ASCII 文本文件。   /b   指示二进制文件。   &lt;source&gt;   必需。 指定要从中复制一个文件或一组文件的位置。 source 可以由驱动器号后跟分号、目录名称、文件名或是这几项的组合组成。   &lt;destination&gt;   必需。 指定要将一个文件或一组文件复制到的位置。 destination 可以由驱动器号后跟分号、目录名称、文件名或是这几项的组合组成。   /?   在命令提示符下显示帮助。   注解   可以复制使用文件结束字符 (CTRL+Z) 指示文件结束的 ASCII 文本文件。   如果在命令行中的文件列表前面或后面添加    /a   ，该选项将应用于列出的所有文件，直到    copy    遇到    /b   。 在这种情况下，   /b    应用    /b    前面的文件。   /a    的效果取决于它在命令行字符串中的位置：- 如果    /a    跟在 source 后面，则    copy    命令会将文件视为 ASCII 文件并复制第一个文件结束字符 (CTRL+Z) 前面的数据。 - 如果    /a    跟在 destination 后面，则    copy    命令会添加一个文件结束符 (CTRL+Z) 作为文件的最后一个字符。   如果    /b    指示命令解释器读取目录中文件大小指定的字节数。 除非    copy    合并文件，否则    /b    是    copy    的默认值。   如果在命令行中的文件列表前面或后面添加    /b   ，该选项将应用于列出的所有文件，直到    copy    遇到    /a   。 在这种情况下，   /a    应用    /a    前面的文件。   /b    的效果取决于它在命令行字符串中的位置：- 如果    /b    跟在 source 后面，则    copy    命令会复制整个文件，包括任何文件结束字符 (CTRL+Z)。 - 如果    /b    跟在 destination 后面，则    copy    命令不会添加文件结束字符 (CTRL+Z)。   如果无法验证写入操作，将显示错误消息。 可以使用    /v    来验证是否已正确记录关键数据，不过，   copy    命令很少发生记录错误。    /v    命令行选项还会减慢    copy    命令的速度，因为使用此选项时，必须检查磁盘上记录的每个扇区。   如果在 COPYCMD 环境变量中预设了    /y   ，你可以在命令行中使用    /-y    替代此设置。 默认情况下，除非在批处理脚本中执行    copy    命令，否则在替换此设置时会出现提示。   若要追加文件，请为 destination 指定一个文件，但为 source 指定多个文件（使用通配符或 file1+file2+file3 格式）。   如果在复制阶段断开连接（例如，如果服务器脱机，则会断开连接），可以在重新建立连接后使用    copy /z    予以恢复。    /z    选项还会显示针对每个文件的复制操作的完成百分比。   可以将出现的一个或多个 source 或 destination 替换为设备名称。   如果 destination 是设备（例如 Com1 或 Lpt1），则    /b    选项以二进制模式将数据复制到设备。 在二进制模式下，   copy /b    会将所有字符（包括 CTRL+C、CTRL+S、CTRL+Z 和 ENTER 等特殊字符）作为数据复制到设备。 但是，如果省略    /b   ，则会在 ASCII 模式下将数据复制到设备。 在 ASCII 模式下，特殊字符可能会导致文件在复制过程中合并。   如果未指定目标文件，则会创建名称、修改日期和修改时间与原始文件相同的副本。 新副本存储在当前驱动器上的当前目录中。 如果源文件位于当前驱动器和当前目录中，并且你未为目标文件指定不同的驱动器或目录，则    copy    命令会停止并显示以下错误消息：   File cannot be copied onto itself0 File(s) copied   如果在 source 中指定了多个文件，则    copy    命令会使用在 destination 中指定的文件名将这些文件全部合并到单个文件。 除非使用 /b 选项，否则 copy 命令假设合并的文件是 ASCII 文件。   若要复制长度为 0 字节的文件，或要复制某个目录的所有文件和子目录，请使用    xcopy 命令   。   若要在不修改文件的情况下将当前时间和日期分配到文件，请使用以下语法：   copy /b &lt;source&gt; +,,    // 其中 , 逗号指示有意省略了 destination 参数。   示例   copy robin.typ c:\\birds                           // 将名为 robin.typ 的文件从当前驱动器和目录复制到驱动器 C 上名为 birds 的现有目录copy memo.doc letter.doc /a                       // 将名为 memo.doc 的文件复制到当前驱动器中的 letter.doc，并确保文件结束字符 (CTRL+Z) 位于复制的文件的末尾                                                  // 如果 birds 目录不存在，则会将文件 robin.typ 复制到名为 birds 的文件中，该文件位于磁盘驱动器 C 上的根目录中。copy mar89.rpt + apr89.rpt + may89.rpt Report     // 合并当前目录中的 Mar89.rpt、Apr89.rpt 和 May89.rpt，并将其放入名为 Report 的文件（也在当前目录中）                                                  // 如果合并文件，copy 命令会使用当前日期和时间标记目标文件。                                                  // 如果省略 destination，将使用列表中第一个文件的名称合并和存储文件。copy report + mar89.rpt + apr89.rpt + may89.rpt   // 合并 Report 中的所有文件，当名为 Report 的文件已存在时copy *.txt Combined.doc                           // 将当前目录中所有文件扩展名为 .txt 的文件合并到名为 Combined.doc 的单个文件                                                  // 如果合并二进制文件，生成的文件可能因内部格式问题而无法使用。copy *.txt + *.ref *.doc                          // 将扩展名为 .txt 的每个文件与其相应 .ref 文件合并会创建文件名相同，但扩展名为 .doc 的文件。                                                  // copy 命令将 file1.txt 与 file1.ref 合并成 file1.doc，                                                  // 然后该命令将 file2.txt 与 file2.ref 合并成 file2.doc，依此类推copy *.txt + *.ref Combined.doc                   // 合并扩展名为 .txt 的所有文件，然后将扩展名为 .ref 的所有文件合并为一个名为 Combined.doc 的文件   6.    move 命令   将一个或多个文件从一个目录移动到另一个目录。   语法   move [{/y|-y}] [&lt;source&gt;] [&lt;target&gt;]   参数   说明   /y   停止确认是否要覆盖现有目标文件的提示。 COPYCMD 环境变量中可能预设了此参数。 可以使用 -y 参数替代此预设。 除非命令是从批处理脚本中运行，否则默认会在覆盖文件之前进行提示。   -y   启动确认是否要覆盖现有目标文件的提示。   &lt;source&gt;   指定要移动的文件的路径和名称。 若要移动或重命名目录，source 应为当前目录的路径和名称。   &lt;target&gt;   指定要将文件移动到的路径和名称。 若要移动或重命名目录，target 应为目标目录的路径和名称。   /?   在命令提示符下显示帮助。   示例   move \\data\\*.xls \\second_q\\reports\\    // 将扩展名为 .xls 的所有文件从 \\Data 目录移动到 \\second_Q\\reports 目录   7.    del 命令   ,    erase 命令   删除一个或多个文件。(这个是专门删除文件的，不能删除文件夹)   语法   del [/p] [/f] [/s] [/q] [/a[:]&lt;attributes&gt;] &lt;names&gt;   参数   说明   &lt;names&gt;   指定一个或多个文件或目录的列表。 通配符可用于删除多个文件。 如果指定了目录，则将删除该目录中的所有文件。   /p   删除指定文件前提示用户进行确认。   /f   强制删除只读文件。   /s   从当前目录和所有子目录中删除指定的文件。 显示正在删除的文件的名称。   /q   指定安静模式。 系统不会提示你确认删除。   /a[:]&lt;attributes&gt;   根据以下文件属性删除文件：   r 只读文件   h 隐藏文件   i 非内容索引文件   s 系统文件   a 可用于存档的文件   l 重新分析点   - 用作前缀，表示“非”   /?   在命令提示符下显示帮助。   备注   如果使用    del /p    命令，你将看到以下消息：   FileName, Delete (Y/N)?   要确认删除，请按 Y。要取消删除并显示下一个文件名（如果已指定一组文件），请按 N。要停止    del    命令，请按 Ctrl+C。   如果禁用命令扩展，则    /s    参数将显示未找到的任何文件的名称，而不是显示要删除的文件的名称。   如果在    &lt;names&gt;    参数中指定特定文件夹，则所有包含的文件也将被删除。 例如，如果要删除 \\work 文件夹中的所有文件，请键入：   del \\work   可以使用通配符（   *    和    ?   ）一次删除多个文件。 但是，为避免无意中删除文件，应谨慎使用通配符。 例如，如果键入以下命令：   del *.*   del 命令显示以下提示：   Are you sure (Y/N)?   要删除当前目录中的所有文件，请按 Y，然后按 Enter。 要取消删除，请按 N，然后按 Enter。在 del 命令中使用通配符之前，请在 dir 命令中使用相同的通配符，以列出要删除的所有文件。   示例   del c:\\test                // 删除驱动器 C 上名为 test 的文件夹中的所有文件del c:\\test\\*.*            // 同上del \"c:\\test folder\\\"      // 删除文件夹中名称中包含空格的所有文件，需要用双引号将完整路径括起来del \"c:\\test folder\\*.*\"   // 同上del *.bat                  // 从当前目录中删除文件扩展名为 .bat 的所有文件del /a:r *.*               // 删除当前目录中的所有只读文件   8.    cls 命令   清除命令提示符窗口。   cls    // 类似于linux下的 clear   9.    ping 命令   通过发送 Internet 控制消息协议 (ICMP) 回显请求消息，验证与另一台 TCP/IP 计算机的 IP 级别连接情况。   语法   ping [/t] [/a] [/n &lt;count&gt;] [/l &lt;size&gt;] [/f] [/I &lt;TTL&gt;] [/v &lt;TOS&gt;] [/r &lt;count&gt;] [/s &lt;count&gt;] [{/j &lt;hostlist&gt; | /k &lt;hostlist&gt;}] [/w &lt;timeout&gt;] [/R] [/S &lt;Srcaddr&gt;] [/4] [/6] &lt;targetname&gt;   参数   说明   /t   指定 ping 继续向目标发送回显请求消息，直到被中断为止。 要中断并显示统计信息，请按 Ctrl+Enter。 要中断并退出此命令，请按 Ctrl+C。   /a   指定对目标 IP 地址执行反向名称解析。 如果此操作成功，ping 会显示相应的主机名。   /n &lt;count&gt;   指定要发送的回显请求消息数。 默认值为 4。   /l &lt;size&gt;   指定回显请求消息中“数据”字段的长度（以字节为单位）。 默认值为 32。 最大大小为 65,500。   /f   指定发送回显请求消息且 IP 标头中的“不分段”标志设置为 1（仅在 IPv4 上可用）。 回显请求消息不能由目标路径中的路由器分段。 此参数可用于排查路径最大传输单元 (PMTU) 问题。   /I &lt;TTL&gt;   指定已发送的回显请求消息的 IP 标头中生存时间 (TTL) 字段的值。 默认值为主机的默认 TTL 值。 最大 TTL 为 255。   /v &lt;TOS&gt;   指定发送的回显请求消息的 IP 标头中服务类型 (TOS) 字段的值（仅在 IPv4 中可用）。 默认值为 0。 TOS 指定为一个介于 0 到 255 之间的十进制值。   /r &lt;count&gt;   指定 IP 标头中的“记录路由”选项用于记录回显请求消息和相应回显回复消息采用的路径（仅在 IPv4 上可用）。 路径中的每个跃点使用“记录路由”选项中的一个条目。 如果可能，请指定一个等于或大于源和目标之间的跃点数的计数。 计数必须至少为 1，最大值为 9。   /s &lt;count&gt;   指定 IP 标头中的“Internet 时间戳”选项用于记录每个跃点的回显请求消息和相应回显回复消息的到达时间。 计数必须至少为 1，最大值为 4。 对于本地链路目标地址，此参数是必需的。   /j &lt;hostlist&gt;   指定回显请求消息使用 IP 标头中的“松散源路由”选项，它带有 hostlist 中指定的一组中间目标（仅在 IPv4 上可用）。 使用松散源路由时，连续的中间目标可由一个或多个路由器分隔。 主机列表中的地址或名称数目不超过 9。 主机列表是一系列由空格分隔的 IP 地址（采用点分十进制格式）。   /k &lt;hostlist&gt;   指定回显请求消息使用 IP 标头中的“严格源路由”选项，它带有 hostlist 中指定的一组中间目标（仅在 IPv4 上可用）。 使用严格源路由时，下一个中间目标必须可直接访问（它必须是路由器接口上的相邻项）。 主机列表中的地址或名称数目不超过 9。 主机列表是一系列由空格分隔的 IP 地址（采用点分十进制格式）。   /w &lt;timeout&gt;   指定等待与给定回显请求消息对应的回显回复消息的时间（以毫秒为单位）。 如果在超时时间内未收到回显回复消息，则会显示“请求超时”错误消息。 默认超时值为 4000（4 秒）。   /R   指定跟踪往返路径（仅在 IPv6 上可用）。   /S &lt;Srcaddr&gt;   指定要使用的源地址（仅在 IPv6 上可用）。   /4   指定用于 ping 的 IPv4。 使用 IPv4 地址标识目标主机时不需要此参数。 按名称标识目标主机时才需要此参数。   /6   指定用于 ping 的 IPv6。 使用 IPv6 地址标识目标主机时不需要此参数。 按名称标识目标主机时才需要此参数。   &lt;targetname&gt;   指定目标的主机名或 IP 地址。   /?   在命令提示符下显示帮助。   示例   ping /a 10.0.99.221              // 对目标 10.0.99.221 执行 ping 操作并将 10.0.99.221 解析为其主机名ping /n 10 /l 1000 10.0.99.221   // 用 10 条回显请求消息对目标 10.0.99.221 执行 ping 操作（其中每条消息的“数据”字段为 1000 字节）ping /r 4 10.0.99.221            // 对目标 10.0.99.221 执行 ping 操作并记录 4 个跃点的路由   10.    netstat 命令   显示活动的 TCP 连接数、计算机侦听的端口、以太网统计信息、IP 路由表、IPv4 统计信息，以及 IPv6 统计信息。   语法   netstat [-a] [-b] [-e] [-n] [-o] [-p &lt;Protocol&gt;] [-r] [-s] [&lt;interval&gt;]   参数   说明   -a   显示所有活动的 TCP 连接数以及计算机正在侦听的 TCP 和 UDP 端口。   -b   显示创建每个连接或侦听端口所涉及的可执行文件。 在某些情况下，众所周知的可执行文件承载了多个独立组件，在这些情况下，将显示创建连接或侦听端口所涉及的组件序列。 在这种情况下，可执行文件名称位于底部的 [] 中，顶部是它调用的组件，依此类推，直到到达 TCP/IP。 请注意，此选项可能很耗时，除非你有足够的权限，否则会失败。   -e   显示以太网统计信息，例如发送和接收的字节数和数据包数。 此参数可与 -s 一起使用。   -n   显示活动的 TCP 连接数，但是，地址和端口号以数字表示，并且不会尝试确定名称。   -o   显示活动的 TCP 连接数，并包括每个连接的进程 ID (PID)。 可以在 Windows 任务管理器的“进程”选项卡上基于 PID 找到应用程序。 此参数可与    -s   、   -n    和    -p    一起使用。   -p &lt;Protocol&gt;   显示 Protocol 指定的协议的连接。 在这种情况下，Protocol 可以是 tcp、udp、tcpv6 或 udpv6。 如果此参数与 -s 一起使用以按协议显示统计信息，则 Protocol 可以是 tcp、udp、icmp、ip、tcpv6、udpv6、icmpv6 或 ipv6。   -s   按协议显示统计信息。 默认情况下，会显示 TCP、UDP、ICMP 和 IP 协议的统计信息。 如果安装了 IPv6 协议，则会显示基于 IPv6 的 TCP、基于 IPv6 的 UDP、ICMPv6 和 IPv6 协议的统计信息。    -p    参数可用于指定一组协议。   -r   显示 IP 路由表的内容。 这等效于 route print 命令。   &lt;interval&gt;   每隔 interval 秒重新显示一次所选信息。 按 CTRL+C 停止重新播放。 如果省略此参数，此命令仅打印一次所选信息。   /?   在命令提示符下显示帮助。   示例   netstat -ano                  // 查看网络连接、状态以及对应的进程idnetstat -aon|findstr \"8080\"   // 查看被占用端口对应的 PIDnetstat -e -s                 // 同时显示以太网统计信息和所有协议的统计信息netstat -s -p tcp udp         // 仅显示 TCP 和 UDP 协议的统计信息netstat -o 5                  // 每 5 秒显示一次活动的 TCP 连接数和进程 IDnetstat -n -o                 // 使用数字形式显示活动的 TCP 连接数和进程 ID   11.    tasklist 命令   显示本地计算机或远程计算机上当前正在运行的进程列表。   语法   tasklist [/s &lt;computer&gt; [/u [&lt;domain&gt;\\]&lt;username&gt; [/p &lt;password&gt;]]] [{/m &lt;module&gt; | /svc | /v}] [/fo {table | list | csv}] [/nh] [/fi &lt;filter&gt; [/fi &lt;filter&gt; [ ... ]]]   参数   说明   /s &lt;computer&gt;   指定远程计算机的名称或 IP 地址（请勿使用反斜杠）。 默认为本地计算机。   /u &lt;domain&gt;\\&lt;username&gt;   使用    &lt;username&gt;    或    &lt;domain&gt;\\&lt;username&gt;    指定的用户的帐户权限运行该命令。 仅当还指定了    /s    时，才能指定    /u    参数。 默认值是当前登录到发出该命令的计算机的用户的权限。   /p &lt;password&gt;   指定    /u    参数中指定的用户帐户的密码。   /m &lt;module&gt;   列出加载了与给定模式名称匹配的 DLL 模块的所有任务。 如果未指定模块名称，则此选项将显示每个任务加载的所有模块。   svc   列出每个进程的所有服务信息，而不截断。 当    /fo    参数设置为 table 时有效。   /v   在输出中显示详细的任务信息。 若要获得不截断的完整详细输出，请同时使用    /v    和    /svc   。   /fo {table | list | csv}   指定要用于输出的格式。 有效值为 table、list 或 csv。 输出的默认格式为 table。   /nh   取消在输出中显示列标题。 当    /fo    参数设置为 table 或 csv 时有效。   /fi &lt;filter&gt;   指定要包含在查询中或从查询中排除的进程类型。 可以使用多个筛选器或使用通配符 (   \\   ) 指定所有任务或映像名称。 本文的“筛选器名称、运算符和值”部分列出了有效的筛选器。   /?   在命令提示符下显示帮助。   tasklist                                // 获取 PID 进程列表tasklist|findstr \"8080\"                 // 查看指定 PID 的进程tasklist /fi \"IMAGENAME eq nginx.exe\"   // 查找所有映像名称为nginx.exe的进程   12.    taskkill 命令   杀进程任务及进程号   语法   taskkill [/s &lt;computer&gt; [/u [&lt;domain&gt;\\]&lt;username&gt; [/p [&lt;password&gt;]]]] {[/fi &lt;filter&gt;] [...] [/pid &lt;processID&gt; | /im &lt;imagename&gt;]} [/f] [/t]   参数   说明   /s &lt;computer&gt;   指定远程计算机的名称或 IP 地址（请勿使用反斜杠）。 默认为本地计算机。   /s &lt;computer&gt;   使用    &lt;username&gt;    或    &lt;domain&gt;\\&lt;username&gt;    指定的用户的帐户权限运行该命令。 仅当还指定了    /s    时，才能指定    /u    参数。 默认值是当前登录到发出该命令的计算机的用户的权限。   /p &lt;password&gt;   指定    /u    参数中指定的用户帐户的密码。   /fi &lt;filter&gt;   应用筛选器以选择一组任务。 可以使用多个筛选器或使用通配符 (*) 指定所有任务或映像名称。 本文的“筛选器名称、运算符和值”部分列出了有效的筛选器。   /pid &lt;processID&gt;   指定要终止的进程的进程 ID。   /im &lt;imagename&gt;   指定要终止的进程的映像名称。 使用通配符 (*) 指定所有映像名称。   /f   指定强制结束进程。 对于远程进程，将忽略此参数；所有远程进程都会被强制结束。   /t   结束指定的进程及其启动的任何子进程。   示例   taskkill /PID 8080         // 杀死 PID 为 8080 的进程taskkill /T /F /PID 8080   // 强制（/F参数）杀死 PID 为 8080 的所有进程包括子进程（/T参数）taskkill /IM nginx.exe     // 杀死所有映像名称为nginx.exe的进程   13.    tracert 命令   tracert也被称为Windows路由跟踪实用程序，在命令提示符（cmd）中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。   语法   tracert [/d] [/h &lt;maximumhops&gt;] [/j &lt;hostlist&gt;] [/w &lt;timeout&gt;] [/R] [/S &lt;srcaddr&gt;] [/4][/6] &lt;targetname&gt;   参数   说明   /d   停止尝试将中间路由器的 IP 地址解析为其名称。 这可以加快结果的返回速度。   /h &lt;maximumhops&gt;   指定搜索目标的路径中的最大跃点数。 默认值为 30 个跃点。   /j &lt;hostlist&gt;   指定回显请求消息使用 IP 标头中的“松散源路由”选项，它带有    &lt;hostlist&gt;    中指定的一组中间目标。 使用松散源路由时，连续的中间目标可由一个或多个路由器分隔。 列表中的地址或名称数目不超过 9。    &lt;hostlist&gt;    是一系列由空格分隔的 IP 地址（采用点分十进制格式）。 仅在跟踪 IPv4 地址时使用此参数。   /w &lt;timeout&gt;   指定等待接收与给定回显请求消息对应的 ICMP 超时或回显回复消息的时间（以毫秒为单位）。 如果在超时值内未收到，则显示星号 (*)。 默认超时值为 4000（4 秒）。   /R   指定使用 IPv6 路由扩展标头向本地主机发送回显请求消息，将目标用作中间目标并测试反向路由。   /S &lt;srcaddr&gt;   指定要在回显请求消息中使用的源地址。 仅在跟踪 IPv6 地址时使用此参数。   /4   指定 tracert.exe 只能使用 IPv4 进行此跟踪。   /6   指定 tracert.exe 只能使用 IPv6 进行此跟踪。   &lt;targetname&gt;   指定目标，该目标由 IP 地址或主机名标识。   /?   在命令提示符下显示帮助。   示例   tracert www.microsoft.com        // 跟踪名为 www.microsoft.com 的主机的路径tracert /d www.microsoft.com     // 跟踪名为 www.microsoft.com 的主机的路径，并阻止将每个 IP 地址解析为其名称   14.    start 命令   启动单独的命令提示符窗口以运行指定的程序或命令。   语法   start &lt;\"title\"&gt; [/d &lt;path&gt;] [/i] [{/min | /max}] [&lt;command&gt; [&lt;parameter&gt;... ] | &lt;program&gt; [&lt;parameter&gt;... ]]   参数   说明   &quot;title&quot;   指定要在“命令提示符”窗口标题栏中显示的标题。   /d &lt;path&gt;   指定启动目录。   /i   将 Cmd.exe 启动环境传递到新的“命令提示符”窗口。 如果未指定 /i，则使用当前环境。   &lt;command&gt; [&lt;parameter&gt;... ]   指定要启动的命令， &lt;parameter&gt; 为命令参数。   &lt;program&gt; [&lt;parameter&gt;... ]   指定要启动的程序， &lt;parameter&gt; 为程序参数。   /?   在命令提示符下显示帮助。   示例   // 打开新命令提示符窗口设置路径为 D:\\workspace\\project 并且执行 echo Hello Worldstart \"Hello World\" /d D:\\workspace\\project cmd /k echo Hello World   15.    cmd 命令   启动命令解释器的新实例 Cmd.exe。 使用时如果没有参数，cmd 将显示操作系统的版本和版权信息。   语法   cmd [/c|/k] [/s] [/q] [/d] [/a|/u] [/t:{&lt;b&gt;&lt;f&gt; | &lt;f&gt;}] [/e:{on | off}] [/f:{on | off}] [/v:{on | off}] [&lt;string&gt;]   参数   说明   /c   执行由    &lt;string&gt;    指定的命令，然后退出命令处理器。   /k   执行由    &lt;string&gt;    指定的命令，并使命令处理器保持运行。   /s   与    /c    或    /k    一起使用时，触发特殊的非分析规则，这些规则在    &lt;string&gt;    周围去除第一个和最后一个引号 (&quot;)，但使命令的其余部分保持不变。   /q   关闭回显。   /d   禁用自动运行命令的执行。   /a   将命令输出的格式设置为美国国家标准协会 (ANSI)。   /u   将命令输出的格式设置为 Unicode。   /t:{&lt;b&gt;&lt;f&gt; | &lt;f&gt;}   设置背景色 (b) 和前景色 (f)。   /e:on   启用命令扩展。   /e:off   禁用命令扩展。   /f:on   启用文件和目录名完成。   /f:off   禁用文件和目录名完成。   /v:on   启用延迟的环境变量扩展。   /v:off   禁用延迟的环境变量扩展。   &lt;string&gt;   指定要执行的命令。   /?   在命令提示符下显示帮助。   下表列出了可用作 &lt;b&gt; 和 &lt;f&gt; 的值的有效的十六进制数字：   值   颜色   0   黑色   1   蓝色   2   绿色   3   Aqua   4   红色   5   紫色   6   黄色   7   白色   8   灰色   9   淡蓝色   a   浅绿色   b   淡蓝绿色   c   淡红色   d   淡紫色   e   淡黄色   F   亮白色   示例   // 若要将命令输出重定向到另一个命令的输入，请使用管道 (|) 字符。 例如：&lt;command1&gt; | &lt;command2&gt;// 若要对 &lt;string&gt; 使用多个命令，请用命令分隔符 &amp;&amp; 分隔它们。 例如：&lt;command1&gt;&amp;&amp;&lt;command2&gt;&amp;&amp;&lt;command3&gt;// 如果提供的目录路径、文件或任何信息包含空格，则必须在文本周围使用双引号 (\")，例如 \"Computer Name\"。 例如：mkdir Test&amp;&amp;mkdir \"Test 2\"&amp;&amp;move \"Test 2\" Test   16.    echo 和 @echo 命令   显示消息或者打开或关闭命令回显功能。 如果不结合任何参数使用，echo 会显示当前回显设置。echo 和 @echo 命令的区别：添加@后将不会显示命令行内容   语法   echo [&lt;message&gt;]echo [on | off]   参数   说明   [on | off]   打开或关闭命令回显功能。 命令回显功能默认已打开。   &lt;message&gt;   指定要在屏幕上显示的文本。   /?   在命令提示符下显示帮助。   示例   echo Hello World// 将显示以下内容// $ D:\\workspace\\script&gt;echo Hello World// $ Hello World@echo Hello World// 只显示// $ Hello World@echo off  // 防止批处理文件中的所有命令（包括 echo off 命令）显示在屏幕上@echo on   // 开启批处理文件中的命令显示在屏幕上   备注   当    echo    关闭时，   echo &lt;message&gt;    命令更有用。 若要显示长度有好几行的消息而不显示任何命令，可以在批处理程序中的    echo off    命令后面添加多个    echo &lt;message&gt;    命令。   关闭回显后，命令提示符不会出现在“命令提示符”窗口中。 若要显示命令提示符，请键入    echo on   。   如果在批处理文件中使用，   echo on    和    echo off    不会影响命令提示符处的设置。   如果使用    echo    时批处理文件中存在空变量，则会显示“回显已关闭”。 若要防止看到此消息，改为生成一个空行，请在    echo    和变量之间放置一个冒号 (   :   )。 例如    echo:%var%   。   若要防止回显批处理文件中的特定命令，请在该命令前面插入 (   @   ) 符号。 若要防止回显批处理文件中的所有命令，请在文件开头包含    echo off    命令。   若要在批处理脚本中显示感叹号 (   !   )，请在单词或短语后面添加脱字符，再后接感叹号，并将此字符串括在双引号中 (   Hello World^!   )。 或者，可以使用双脱字符 (   ^^   ) 而无需使用双引号 (   Hello World^^!   )。   若要在使用    echo    时显示竖线 (   |   )、与号 (   &amp;   ) 或重定向字符（   &lt;    或    &gt;   ），请紧靠在该字符前面使用脱字符 (   ^   )。 例如    ^|   、   ^&amp;   、   ^&gt;    或    ^&lt;   。 若要显示脱字符，请连续键入两个脱字符 (   ^^   )。   17.    set 命令   显示、设置或删除 cmd.exe 环境变量。 如果不结合任何参数使用，set 将显示当前环境变量设置。   语法   set [&lt;variable&gt;=[&lt;string&gt;]]set [/p] &lt;variable&gt;=[&lt;promptString&gt;]set /a &lt;variable&gt;=&lt;expression&gt;   参数   说明   &lt;variable&gt;   指定要设置或修改的环境变量。   &lt;string&gt;   指定要与指定环境变量关联的字符串。   /p   将    &lt;variable&gt;    的值设置为由用户输入的一行输入。   &lt;promptstring&gt;   指定提示用户输入的消息。 此参数必须与    /p    参数一起使用。   /a   将    &lt;string&gt;    设置为计算的数值表达式。   &lt;expression&gt;   指定数值表达式。   /?   在命令提示符下显示帮助。   示例   set /p text=请输入：        // 请输入： 为 placeholder, 输入文字后变量 text 为输入的内容.echo %text%set /p isSave=是否保存为文件？(y/n)echo %isSave%   18.    if 命令   在批处理程序中执行条件处理。   语法   if [not] ERRORLEVEL &lt;number&gt; &lt;command&gt; [else &lt;expression&gt;]if [not] &lt;string1&gt;==&lt;string2&gt; &lt;command&gt; [else &lt;expression&gt;]if [not] exist &lt;filename&gt; &lt;command&gt; [else &lt;expression&gt;]   如果启用了命令扩展，请使用以下语法：   if [/i] &lt;string1&gt; &lt;compareop&gt; &lt;string2&gt; &lt;command&gt; [else &lt;expression&gt;]if cmdextversion &lt;number&gt; &lt;command&gt; [else &lt;expression&gt;]if defined &lt;variable&gt; &lt;command&gt; [else &lt;expression&gt;]   参数   说明   not   指定仅当条件为 false 时，才应执行该命令。   errorlevel &lt;number&gt;   仅当由 Cmd.exe 运行的上一个程序返回等于或大于 number 的退出代码时，才指定 true 条件。   &lt;command&gt;   指定在满足上述条件时应执行的命令。   &lt;string1&gt;==&lt;string2&gt;   仅当 string1 和 string2 相同时，才指定 true 条件。 这些值可以是字符串或批处理变量（例如，%1）。 无需将字符串用引号括起来。   exist &lt;filename&gt;   如果指定的文件名存在，则指定 true 条件。   &lt;compareop&gt;   指定三字母比较运算符，包括：    EQU - 等于   NEQ - 不等于   LSS - 小于   LEQ - 小于或等于   GTR - 大于   GEQ - 大于或等于   /i   强制字符串比较忽略大小写。 可以采用 if 的 string1==string2 形式使用 /i。 这些比较是通用的，因为如果 string1 和 string2 仅由数字组成，则字符串将转换为数值并执行数值比较。   cmdextversion &lt;number&gt;   仅当与 Cmd.exe 的命令扩展功能关联的内部版本号等于或大于指定的数值时，才指定 true 条件。 第一个版本为 1。 向命令扩展添加大量增强功能时，它会以 1 为增量增加。 禁用命令扩展时（默认情况下，启用命令扩展），cmdextversion 条件永远不会为 true。   defined &lt;variable&gt;   如果定义了变量，则指定 true 条件。   &lt;expression&gt;   指定命令行命令以及要在 else 子句中传递给该命令的任何参数。   /?   在命令提示符下显示帮助。   示例   if not exist product.dat echo 无法找到 product.dat 文件if exist product.dat (  del product.dat) ELSE (  echo 无法找到 product.dat 文件)   备注   如果 if 子句中指定的条件为 true，则执行条件后面的命令。如果条件为 false，则忽略 if 子句中的命令，并且该命令执行 else 子句中指定的任何命令。   程序停止时，它将返回退出代码。 若要使用退出代码作为条件，请使用 errorlevel 参数。   %errorlevel%：扩展为 ERRORLEVEL 环境变量的当前值的字符串表示形式。 此变量假定尚不存在名为 ERRORLEVEL 的现有环境变量。 如果存在，将获得该 ERRORLEVEL 值。   %cmdcmdline%：扩展到在 Cmd.exe 进行任何处理之前传递给 Cmd.exe 的原始命令行。 这假定尚不存在名为 CMDCMDLINE 的现有环境变量。 如果存在，将获得该 CMDCMDLINE 值。   %cmdextversion%：扩展为 cmdextversion 的当前值的字符串表示形式。 这假定不存在名为 CMDEXTVERSION 的现有环境变量。 如果存在，将获取该 CMDEXTVERSION 值。   必须在 if 后面的命令所在的同一行上使用 else 子句。   19. 辅助符号 ‘|’   “|”cmd命令中|代表前一个的输出代表后一个的输入   netstat -ano|find \"192.168.1.10\"  // 查找特定ip的网络连接及进程号   20 重定向输出符号&gt; &gt;&gt;   将原本输出到命令窗口的内容，转存到文件中，如jstack 12912 &gt;d:/s.txt 打印线程到指定文件   cmd &gt; 重定向输出并覆盖源文件。   echo hello &gt;c:\\1.txt   // 1.txt的文件内容先被清空，然后写入hello。   cmd &gt;&gt;重定向输出追加到文件末尾   echo hello &gt;&gt;c:\\1.txt  // 在1.txt文件末尾加上hello   21. 重定向输入符号&lt; &lt;&lt;   cmd &lt; file     // 使cmd命令从file读入cmd &lt;&lt; text    // 从命令行读取输入，直到一个与text相同的行结束。// 除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。// 如果使用 &lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考后面的例子。cmd &lt;&lt;&lt; word   // 把word（而不是文件word）和后面的换行作为输入提供给cmd。cmd &lt;&gt; file    // 以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。cmd &gt;| file    // 功能同&gt;，但即便在设置了noclobber时也会覆盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。","categories":["script"]},{"title":"运维的未来是平台工程","url":"/2023/07/19/platform-engineering.html","content":"","categories":["reprint"]},{"title":"软件吃软件，编程工作会越来越多吗？","url":"/2023/07/07/will-programmers-increase.html","content":"","categories":["reprint"]},{"title":"大盘鸡","url":"/2022/08/16/big-plate-chicken.html","content":"食材用料   食材   数量   鸡   一只   土豆   两个   青椒   两个   油   适量   白糖   适量   葱   适量   姜   适量   蒜   适量   辣椒   适量   花椒   适量   八角   适量   香叶   适量   桂皮   适量   盐   适量   生抽   适量   老抽   适量   辣椒油   适量   料酒   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜、姜、蒜、辣椒、花椒、八角、香叶、桂皮   3.    鸡块焯水，放入姜片、料酒   4.    土豆切滚刀块   5.    鸡块去除浮沫后捞出   6.    放油大火，放入白糖或者冰糖炒化   7.    放入鸡块翻炒，炒出香味   8.    放入调料翻炒   9.    放入盐、生抽、老抽、辣椒油、料酒翻炒均匀   10.    放入土豆翻炒，然后加入水没过土豆，盖上锅盖   11.    煮到一半放入青椒，大火收汁   12.    装盘","categories":["cookbook"]},{"title":"Language Tags (BCP 47)","url":"/2022/04/10/language-tags.html","content":"Language Tag   Language   Region   Description   ar-SA   Arabic   Saudi Arabia   Arabic (Saudi Arabia)   bn-BD   Bangla   Bangladesh   Bangla (Bangladesh)   bn-IN   Bangla   India   Bangla (India)   cs-CZ   Czech   Czech Republic   Czech (Czech Republic)   da-DK   Danish   Denmark   Danish (Denmark)   de-AT   German   Austria   Austrian German   de-CH   German   Switzerland   &quot;Swiss&quot; German   de-DE   German   Germany   Standard German (as spoken in Germany)   el-GR   Greek   Greece   Modern Greek   en-AU   English   Australia   Australian English   en-CA   English   Canada   Canadian English   en-GB   English   United Kingdom   British English   en-IE   English   Ireland   Irish English   en-IN   English   India   Indian English   en-NZ   English   New Zealand   New Zealand English   en-US   English   United States   US English   en-ZA   English   South Africa   English (South Africa)   es-AR   Spanish   Argentina   Argentine Spanish   es-CL   Spanish   Chile   Chilean Spanish   es-CO   Spanish   Columbia   Colombian Spanish   es-ES   Spanish   Spain   Castilian Spanish (as spoken in Central-Northern Spain)   es-MX   Spanish   Mexico   Mexican Spanish   es-US   Spanish   United States   American Spanish   fi-FI   Finnish   Finland   Finnish (Finland)   fr-BE   French   Belgium   Belgian French   fr-CA   French   Canada   Canadian French   fr-CH   French   Switzerland   &quot;Swiss&quot; French   fr-FR   French   France   Standard French (especially in France)   he-IL   Hebrew   Israel   Hebrew (Israel)   hi-IN   Hindi   India   Hindi (India)   hu-HU   Hungarian   Hungary   Hungarian (Hungary)   id-ID   Indonesian   Indonesia   Indonesian (Indonesia)   it-CH   Italian   Switzerland   &quot;Swiss&quot; Italian   it-IT   Italian   Italy   Standard Italian (as spoken in Italy)   jp-JP   Japanese   Japan   Japanese (Japan)   ko-KR   Korean   Republic of Korea   Korean (Republic of Korea)   nl-BE   Dutch   Belgium   Belgian Dutch   nl-NL   Dutch   The Netherlands   Standard Dutch (as spoken in The Netherlands)   no-NO   Norwegian   Norway   Norwegian (Norway)   pl-PL   Polish   Poland   Polish (Poland)   pt-BR   Portugese   Brazil   Brazilian Portuguese   pt-PT   Portugese   Portugal   European Portuguese (as written and spoken in Portugal)   ro-RO   Romanian   Romania   Romanian (Romania)   ru-RU   Russian   Russian Federation   Russian (Russian Federation)   sk-SK   Slovak   Slovakia   Slovak (Slovakia)   sv-SE   Swedish   Sweden   Swedish (Sweden)   ta-IN   Tamil   India   Indian Tamil   ta-LK   Tamil   Sri Lanka   Sri Lankan Tamil   th-TH   Thai   Thailand   Thai (Thailand)   tr-TR   Turkish   Turkey   Turkish (Turkey)   zh-CN   Chinese   China   Mainland China, simplified characters   zh-HK   Chinese   Hond Kong   Hong Kong, traditional characters   zh-TW   Chinese   Taiwan   Taiwan, traditional characters","categories":["note"]},{"title":"杏鲍菇炒肉","url":"/2021/12/24/fried-meat-with-pleurotus-eryngii.html","content":"食材用料   食材   数量   杏鲍菇   250克   鸡胸肉   半块   油   适量   葱   适量   姜   适量   蒜   适量   辣椒   适量   花椒   适量   盐   适量   冰糖   适量   生抽   适量   老抽   少量   耗油   适量   十三香   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：葱姜蒜、辣椒、花椒   3.    杏鲍菇洗净切片   4.    肉切片，捏掉水   5.    放油中火，放调料爆香   6.    放肉片炒熟   7.    放入杏鲍菇片，大火翻炒变软   8.    放入盐、冰糖、生抽、老抽、十三香翻炒   9.    收锅   10.    装盘","categories":["cookbook"]},{"title":"NPM如何查看更新包版本","url":"/2021/10/22/npm-check-update.html","content":"先查询有哪些包有更新   $ npm outdated   如查看xxx包的最新版本信息   $ npm view xxx versions  or$ npm info xxx   使用npm安装指定版本的包   $ npm i xxx@1.11.1 --save-dev   使用npm升级指定版本的包   $ npm update xxx --save-dev   安装xxx最新版本的包   $ npm i xxx@latest --save-dev   使用npm查看已安装的包列表   $ npm list   使用npm查看已安装某一指定包的版本信息   $ npm list xxx   使用npm-check查看更新包   $ npm install -g npm-check  # 先全局安装 npm-check$ npm-check -u              # 查询当前项目下的包更新$ npm-check -u -g           # 查询全局安装的包更新   会列出所有的更新，上下键控制，空格选中或取消选中，选好了以后按回车就行了。","categories":["note"]},{"title":"香菇炖羊排","url":"/2021/10/19/stewed-lamb-chop-with-mushroom.html","content":"食材用料   食材   数量   羊排   6个   香菇   300克   油   多量   盐   适量   辣椒   适量   花椒   适量   八角   适量   孜然   适量   羊排必须焯水去血沫，不然腥味重。   做法步骤   图片   步骤   1.    准备食材   2.    调料盘：辣椒、花椒、八角、孜然   3.    羊排加水放血   4.    温水焯水捞出   5.    放入调料中火翻炒羊排   6.    加水，放入切好的香菇，放入盐   7.    中火炖煮30分钟   8.    装盘","categories":["cookbook"]},{"title":"青椒炒肉","url":"/2021/09/05/green-pepper-parch-meat.html","content":"食材用料   食材   数量   青椒   300克   猪肉   120克   油   适量   蒜   适量   盐   适量   生抽   适量   老抽   少量   料酒   适量   肉嫩青椒好吃关键：不能大火，全程中火。   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜、辣椒   3.    青椒切成丝   4.    肉切丝，捏掉水，放入淀粉、生抽、料酒   5.    搅拌成粘稠状腌一下   6.    放油中火，放调料爆香   7.    放肉丝炒熟   8.    放入青椒翻炒均匀   9.    放入盐、老抽翻炒   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"番茄香肠炒鸡蛋","url":"/2021/06/14/scrambled-egg-with-tomato-sausage.html","content":"食材用料   食材   数量   番茄   250克   鸡蛋   两个   香肠   60克   油   适量   干辣椒   适量   盐   适量   冰糖   适量   做法步骤   图片   步骤   1.    准备食材   2.    番茄底部切掉，为了煮开的时候更好裂皮   3.    开水煮到番茄表面裂皮   4.    番茄剥皮   5.    番茄切成小块   6.    打入鸡蛋、葱花搅拌   7.    香肠切片和辣椒装在一起   8.    热锅热油，油冒烟放入鸡蛋液   9.    放入香肠辣椒翻炒均匀   10.    放入番茄块翻炒均匀，放入盐（番茄块用锅铲摁烂）   11.    收锅   12.    装盘","categories":["cookbook"]},{"title":"JavaScript 注释规范","url":"/2021/04/28/javascript-document-convertions.html","content":"Type 语法   类型名   语法示例   描述   Symbol name   {string}, {myNamespace.MyClass}   指定符号的名称。   Multiple types   {number|boolean}   这意味着值可能是几种类型中的一种，用&quot;|&quot;分隔类型的完整列表。   Arrays   {string[]}, {MyClass[]}   表达式   string[]   表示字符串数组，    表达式   {MyClass[]}   标识具有MyClass实例的数组   Objects   {a: number, b: string, c}     // or     {object} myObj     {number} myObj.a     {string} myObj.b     {any} myObj.c   对象“MyObj”中具有属性 &#39;a&#39; (一个数字) &#39;b&#39; (一个字符串) 和 &#39;c&#39; (任何类型)，    对于具有一组已知的属性的对象，    你可以使用 Closure Compiler 语法文档化标注的类型。    你也可以分别描述每个属性，    这使你能够提供有关每个属性的更多详细信息。   Nullable type   {?number}   指明类型为指定的类型，或者为null。   Non-nullable type   {!number}   指明类型为指定的类型，但是绝对不会是null。   Variable number of that type   @param {...number} num   表示该函数接受可变数量的参数，并指定一个类型的参数。   Optional parameter   @param {number} [foo=1]   指示参数是可选的, 你还可以指明参数的默认值。   Callbacks   @callback myCallback     @param {number} x - ...   使用@callback标签指明一个回调。    和@typedef标签是相同的，    不同之处在于回调的类型始终是&quot;function&quot;。   Type definitions   @typedef {object} PropertiesHash     @property {string} id     @property {string} name     @property {number} age   你可以使用@typedef标签记录复杂类型。   常用注释关键字   注释名   别名   描述   @param   @argument, @arg   记录传递给一个函数的参数。   @return   @returns   记录一个函数的返回值。   @method   @function, @func   描述一个函数或方法。   @typedef   记录一个自定义的类型。   @property   @prop   记录一个对象的属性。   @callback   描述一个回调函数。   @author   指定项目的作者。   @copyright   描述一个文件的版权信息。   @description   描述一个标识。   @param   记录传递给一个函数的参数。   别名： @arg，@argument   /*** @param {string} somebody - Somebody's name.*/function sayHello(somebody) {alert('Hello ' + somebody);}   如果参数是一个对象，有特定的属性：   /*** Assign the project to an employee.* @param {object} employee            - The employee who is responsible for the project.* @param {string} employee.name       - The name of the employee.* @param {string} employee.department - The employee's department.*/Project.prototype.assign = function(employee) { ... };   如果参数的属性值在数组中：   /*** Assign the project to a list of employees.* @param {object[]} employees            - The employees who are responsible for the project.* @param {string} employees[].name       - The name of an employee.* @param {string} employees[].department - The employee's department.*/Project.prototype.assign = function(employees) { ... };   一个可选参数和默认值：   /*** @param {string} [somebody=John Doe] - Somebody's name.*/function sayHello(somebody) {if (!somebody) {  somebody = 'John Doe';}alert('Hello ' + somebody);}   允许一个类型或另一个类型：   /*** @param {string|string[]} [somebody=John Doe] - Somebody's name, or an array of names.*/function sayHello(somebody) {if (!somebody) {  somebody = 'John Doe';} else if (Array.isArray(somebody)) {  somebody = somebody.join(', ');}alert('Hello ' + somebody);}   参数接受一个回调函数：   /*** @param {requestCallback} cb*//*** @callback requestCallback* @param {number} responseCode* @param {string} responseMessage*/function doSomethingAsynchronously(cb) { ... }   @return   记录一个函数的返回值。   别名： @returns   /*** Returns the sum of a and b* @param {number} a* @param {number} b* @param {boolean} retArr If set to true, the function will return an array* @return {number|array} Sum of a and b or an array that contains a, b and the sum of a and b.*/function sum(a, b, retArr) {if (retArr) {  return [a, b, a + b];}return a + b;}   @method   描述一个函数或方法。   别名： @function, @func   /*** Returns the sum of a and b* @method sum* @param {number} a* @param {number} b* @return {number} Sum of a and b or an array that contains a, b and the sum of a and b.*/function sum(a, b) {return a + b;}   @typedef   记录一个自定义的类型。   /*** The complete Triforce, or one or more components of the Triforce.* @typedef {Object} WishGranter~Triforce* @property {boolean} hasCourage - Indicates whether the Courage component is present.* @property {boolean} hasPower   - Indicates whether the Power component is present.* @property {boolean} hasWisdom  - Indicates whether the Wisdom component is present.*//*** A class for granting wishes, powered by the Triforce.* @class* @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects* containing all three components of the Triforce.*/function WishGranter() {}   @property   记录一个对象的属性。   /*** @namespace* @property {object}  defaults               - The default values for parties.* @property {number}  defaults.players       - The default number of players.* @property {string}  defaults.level         - The default level for the party.* @property {object}  defaults.treasure      - The default treasure.* @property {number}  defaults.treasure.gold - How much gold the party starts with.*/var config = {defaults: {  players: 1,  level: 'beginner',  treasure: {    gold: 0  }}};   @callback   描述一个回调函数。   /*** @class*/function Requester() {}   /**   Send a request.   @param {Requester~requestCallback} cb - The callback that handles the response.   /Requester.prototype.send = function(cb) {// code};   /**   This callback is displayed as part of the Requester class.   @callback Requester~requestCallback   @param {number} responseCode   @param {string} responseMessage   /   @author   指定项目的作者。   /*** @author Zane Liu &lt;liuzane@example.com&gt;*/function MyClass() {}   @copyright   描述一些版权信息。   /*** @file This is my cool script.* @copyright Zane Liu 2021*/   @description   描述一个标识。   /*** @param {number} a* @param {number} b* @returns {number}* @description Add two numbers.*/function add(a, b) {return a + b;}","categories":["javascript"]},{"title":"香菇炒肉","url":"/2021/04/05/mushroom-fried-meat.html","content":"食材用料   食材   数量   香菇   250克   鸡胸肉   半块   青椒   一个   油   少量   蒜   适量   葱   适量   辣椒   适量   花椒   适量   盐   适量   老抽   适量   十三香   适量   豆瓣酱   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片、辣椒、花椒、葱花   3.    蘑菇切片焯水装盘   4.    肉切片，捏掉水   5.    青椒切成条   6.    放油放入调料爆香   7.    中火放入肉炒熟   8.    放入青椒、蘑菇大火翻炒   9.    放入盐、老抽、十三香、豆瓣酱   10.    大火翻炒几下   11.    出锅   12.    装盘","categories":["cookbook"]},{"title":"ScrollContainer Component","url":"/2020/12/30/scroll-container.html","content":"滚动容器组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   Usage   null   ScrollContainer   // 基础模块import React, { Component } from 'react';import PropTypes from 'prop-types';   class ScrollContainer extends Component {  static propTypes = {    className: PropTypes.string,    style: PropTypes.object,    tagName: PropTypes.string,    scrollBottomDistance: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),    onScrollBottom: PropTypes.func,    children: PropTypes.node,  }     static defaultProps = {    tagName: &#39;div&#39;,    scrollBottomDistance: 100,    onScrollBottom: () =&gt; {},  }     constructor(props) {    super(props);    this.scrollBottom = false;  }     // 监听content是否滑动到底部  onScroll = (e) =&gt; {    const { onScrollBottom } = this.props;    const target = e.currentTarget;    const scrollHeight = target.scrollHeight;    const scrollTop = target.scrollTop;    const clientHeight = target.clientHeight;    const scrollBottomDistance = parseInt(this.props.scrollBottomDistance);   if (scrollHeight - clientHeight &gt; (scrollTop + scrollBottomDistance)) {  this.scrollBottom = false;}if (!this.scrollBottom &amp;&amp; (scrollHeight - clientHeight &lt;= (scrollTop + scrollBottomDistance))) {  //滚动条滚到最底部  this.scrollBottom = true;  onScrollBottom();}     }     render() {    const { className, style, children } = this.props;    return (      &lt;this.props.tagName         className={className}        style={style}        onScroll={this.onScroll}      &gt;        {children}      &lt;/this.props.tagName&gt;    );  }}   export default ScrollContainer;```","categories":["react"]},{"title":"Screenshot Component","url":"/2020/12/30/screenshot.html","content":"截屏组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   html2canvas   http://html2canvas.hertzen.com   Usage   null   Screenshot.jsx   import React, { Component } from 'react';import PropTypes from 'prop-types';import html2canvas from 'html2canvas';   import &#39;./Screenshot.css&#39;;   class Screenshot extends Component {  static propTypes = {    options: PropTypes.object,    className: PropTypes.string,    style: PropTypes.object,    children: PropTypes.node,    callback: PropTypes.func,    onRef: PropTypes.func,  }     static defaultProps = {    options: {},    callback: () =&gt; {},    onRef: () =&gt; {},  }     constructor(props) {    super(props);    this.Element = React.createRef();   Screenshot.screenshot = this.screenshot.bind(this);     }     componentDidMount() {    this.props.onRef(this.Element);  }     // 截图  screenshot = () =&gt; {    const { callback } = this.props;    const Element = this.Element.current;    const options = {      logging: false,      scale: 2,      scrollX: 0,      scrollY: 0,      backgroundColor: null,      useCORS: true,    };    // Element.classList.add(&#39;screenshot&#39;);    html2canvas(Element, options).then((canvas) =&gt; {      // Element.classList.remove(&#39;screenshot&#39;);      callback(canvas);    });  }     render() {    const { className, style, children } = this.props;    return (         {children}       );  }}   export default Screenshot;   * Screenshot.css```css.screenshot {  position: fixed !important;  top: 0 !important;  left: 0 !important;}","categories":["react"]},{"title":"香辣虾","url":"/2020/12/27/fried-shrimp-with-chilli.html","content":"食材用料   食材   数量   基围虾   10个   油   适量   葱   适量   蒜   适量   姜   适量   辣椒   适量   香叶   适量   盐   适量   清水   半碗   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    葱切段，姜切撕，蒜切末装盘   3.    调料汁：清水、生抽、盐、香叶   4.    虾洗净，挑去虾线   5.    热锅热油，下虾，煎至两面成漂亮的红色出虾油后，盛出虾（用锅铲轻轻压一压虾，红油出的多）   6.    把葱和姜放入虾油锅中爆香   7.    放入煎好的虾，倒入调料汁   8.    大火收汁   9.    装盘","categories":["cookbook"]},{"title":"ClickOutside Component","url":"/2020/12/25/click-outside.html","content":"点击到元素外面组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   immutable   https://github.com/immutable-js/immutable-js   Usage   null   ClickOutside.jsx   // 基础模块import React, { Component } from 'react';import PropTypes from 'prop-types';   // 第三方模块import { fromJS, is } from &#39;immutable&#39;;   class ClickOutside extends Component {  static propTypes = {    tag: PropTypes.string.isRequired,    children: PropTypes.element,    onOutside: PropTypes.func,  };     static defaultProps = {    onOutside: () =&gt; {},  };     constructor(props) {    super(props);    this.Tag = React.createRef();  }     componentDidMount() {    document.addEventListener(&#39;click&#39;, this.isOutside);  }     componentWillunmount() {    document.removeEventListener(&#39;click&#39;, this.isOutside);  }     isOutside = event =&gt; {    let [ isChild, node ] = [ false, event.target ];    while (node &amp;&amp; node.id !== &#39;root&#39;) {      if (is(fromJS(node), fromJS(this.refs.tag))) {        isChild = true;        break;      }      node = node.parentNode;    }    if (!isChild) {      this.props.onOutside();    }  }     render() {    const { tag, children, ...restProps } = this.props;    return (      &lt;this.props.tag        ref={this.Tag}        onClick={ this.isOutside }        {...restProps}      &gt;        { children }      &lt;/this.props.tag&gt;    );  }}   export default ClickOutside;```","categories":["react"]},{"title":"Validate Component","url":"/2020/12/25/validate.html","content":"自定义验证组件   Plugin   Name   Link   prop-types   https://github.com/facebook/prop-types   immutable   https://github.com/immutable-js/immutable-js   lodash   https://www.lodashjs.com   Usage   class Desktop extends PureComponent {constructor() {  super();  this.state = {    model: {      name: '',      phone: '',    },    rules: {      name: {        required: true,        message: 'Please type name',      },      phone: [        {          required: true,          message: 'Please type phone',        },        {          validator(rule, value, callback) {            console.log('rule', rule);            console.log('value', value);            if (!/^1\\d{10}$/.test(value)) {              callback('Please type the correct phone, inside');            } else {              callback();            }          },          message: 'Please type the correct phone, outside',        }      ]    }  };}onSetValue = (key, e) =&gt; {  const value = e.target.value;  const model = _.cloneDeep(this.state.model);  model[key] = value;  this.setState({ model });}handleValidate = () =&gt; {  Validate.validate((error, model) =&gt; {    console.log('error', error);    console.log('model', model);  });}render() {  const { model, rules } = this.state;  return (    &lt;LayContainer&gt;      &lt;Validate model={model} rules={rules}&gt;        {          (messages) =&gt; (            &lt;div className=\"validate-wrap\"&gt;              &lt;div className=\"validate-row\"&gt;                &lt;Input value={model.name} placeholder=\"Please type name\" onChange={this.onSetValue.bind(this, 'name')}/&gt;                &lt;p&gt;{messages.name}&lt;/p&gt;              &lt;/div&gt;              &lt;div className=\"validate-row\"&gt;                &lt;Input value={model.phone} placeholder=\"Please type phone\" onChange={this.onSetValue.bind(this, 'phone')}/&gt;                &lt;p&gt;{messages.phone}&lt;/p&gt;              &lt;/div&gt;              &lt;Button onClick={this.handleValidate}&gt;验证&lt;/Button&gt;            &lt;/div&gt;          )        }      &lt;/Validate&gt;    &lt;/LayContainer&gt;  );}}   Validate.jsx   // 基础模块import { Component } from 'react';import PropTypes from 'prop-types';   // 第三方模块import { fromJS, is } from &#39;immutable&#39;;import _ from &#39;lodash&#39;;   class Validate extends Component {  static propTypes = {    model: PropTypes.object,    rules: PropTypes.object,    children: PropTypes.func,  };     constructor(props) {    super(props);    this.state = {      messages: {},      originalModel: {},      isValidated: {},    };    Validate.validate = this.validate;  }     // 初始化设置原始model数据  componentWillMount() {    const { model } = this.props;    this.setState({ originalModel: model });  }     // 如果更新了 model 就获取 messages  componentWillReceiveProps(nextProps) {    if (!is(fromJS(this.props.model), fromJS(nextProps.model))) {      const messages = this.getValidateMessages(nextProps.model);      this.setState({ messages });    }  }     shouldComponentUpdate (nextProps, nextState) {    return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState));  }     // 验证规则项  validateRuleItem = (rule, value) =&gt; {    if (rule.required &amp;&amp; !value) {      return rule.message;    }   if (rule.validator) {  let message;  const callback = errorMsg =&gt; {    message = errorMsg || rule.message;  };  rule.validator(rule, value, callback);  return message;}     }     // 获取验证错误信息  getValidateMessages = (model, isValidate) =&gt; {    const messages = {};    const { rules } = this.props;    const { originalModel, isValidated } = this.state;   for (const key in rules) {  if (isValidate || (model[key] !== undefined &amp;&amp; (model[key] !== originalModel[key] || isValidated[key]))) {    // 计算 key 更新次数    isValidated[key] = true;    // 如果规则项是数组    if (_.isArray(rules[key])) {      for (let i = 0; i &lt; rules[key].length; i++) {        const message = this.validateRuleItem(rules[key][i], model[key]);        if (message) {          messages[key] = message;          break;        }      }      continue;    }    // 如果规则项是对象    if (_.isPlainObject(rules[key])) {      const message = this.validateRuleItem(rules[key], model[key]);      if (message) messages[key] = message;      continue;    }  }}this.setState({ countModel: _.cloneDeep(isValidated) });return messages;     }     // 外部调用验证方法  validate = (callback) =&gt; {    const { model } = this.props;    const messages = this.getValidateMessages(model, true);    const error = Object.keys(messages).length &gt; 0 ? messages : null;    this.setState({ messages });    callback(error, model);  }     render () {    const { children } = this.props;    const { messages } = this.state;   return children(messages);     }}   export default Validate;```","categories":["react"]},{"title":"localStorage","url":"/2020/12/10/local-storage.html","content":"setStorage(key, data, hours)   设置localStorage```javascript/**   @method setStorage   @param {string} key   @param {any} data   @param {number} hours   @return {boolean}   /function setStorage(key, data, hours) { let expires;    if (!key || !data) {   console.error(&#39;[localStorage Error]: Key and Data is a must parameter&#39;);   return false; }    expires = hours ? new Date().getTime() + 1000 * 60 * 60 * hours : new Date(0).getTime(); localStorage.setItem(key, JSON.stringify({ data, expires }));    return true;}   getStorage(key)   获取localStorage```javascript/**   @method getStorage   @param {string} key   @return {boolean|null}   /function getStorage(key) { let data, nowTime = new Date().getTime();    if (!key) console.error(&#39;[localStorage Error]: Key is a must parameter&#39;);    try {   data = JSON.parse(localStorage.getItem(key)); } catch (error) {   return localStorage.getItem(key); }    if (!data) return null;    if (!Boolean(data.expires) || data.expires &gt;= nowTime) {   return data.data; } else {   localStorage.removeItem(key);   return null; }}   clearStorage(key)   清除localStorage```javascript/**   @method clearStorage   @param {string} key   /function clearStorage(key) { if (key) {   localStorage.removeItem(key); } else {   localStorage.clear(); }}```","categories":["javascript"]},{"title":"Cookies","url":"/2020/12/10/cookies.html","content":"setCookie(params)   设置Cookie```javascript/**   @method setCookie   @param {object} options   @param {string} options.key   @param {string} options.value   @param {number} [options.hours]   @param {string} [options.path]   - path: &#39;/&#39;   @param {string} [options.domain] - domain: document.domain   /function setCookie(options) { let time = new Date(), expires = &#39;&#39;, path = &#39;&#39;, domain = &#39;&#39;;    if (!options.key || !options.value) {   console.error(&#39;[Cookie Error]: key, value must be set.&#39;);   return; }    if (options.hours) {   try {   Number(options.hours);      } catch (e) {   console.error(&apos;[Cookie Error]: expires must is number.&apos;);      }      time.toGMTString(time.setTime(time.getTime() + 1000 * 60 * 60 * options.hours));   expires = &#39;expires=&#39; + time + &#39;;&#39;; }    if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;    if (options.domain) domain = &#39;domain=&#39; + options.domain;    document.cookie = options.key + &#39;=&#39; + options.value + &#39;;&#39; + expires + path + domain;}   getCookie(key)   获取Cookie```javascript/**   @method getCookie   @param {string} key    @return {undefined|string|null}   /function getCookie(key) { if (!key) {   console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);   return; } const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;); const result = document.cookie.match(regexp); const value = result ? result[0].replace(/[; ]/g, &#39;&#39;).split(&#39;=&#39;)[1] : null; return value;}   deleteCookie(param)   ```javascript/**   @method deleteCookie   @param {string|object} param   @param {string} param.key   @param {string} [param.path]   @param {string} [param.domain]   @return {undefined|string|null}   /function deleteCookie(param) { const options = typeof param === &#39;object&#39; ? param : {}; const key = typeof param === &#39;string&#39; ? param : options.key;    if (!key) {   console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);   return; } if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;; if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;    const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;); const result = document.cookie.match(regexp); const item = result ? result[0].replace(/[; ]/g, &#39;&#39;) : &#39;&#39;; const time = new Date(); time.toGMTString(time.setTime(0)); document.cookie = item + &#39;;expires=&#39; + time + &#39;;&#39; + options.path + options.domain;}   clearCookie(params)   清除Cookie```javascript/**   @method clearCookie   @param {object} [options]   @param {string} [options.path]   @param {string} [options.domain]   /function clearCookie(options) { let arr = document.cookie.split(&#39;;&#39;), path = &#39;&#39;, domain = &#39;&#39;;    if (!options) options = {}; if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;; if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;    for (let i = 0; i &lt; arr.length; i++) {   let key = arr[i].substring(0, arr[i].indexOf(&#39;=&#39;));   document.cookie = key + &#39;=0;expires=Thu, 01 Jan 1970 00:00:00 GMT;&#39; + path + domain; }}```","categories":["javascript"]},{"title":"Assist","url":"/2020/12/10/assist.html","content":"方法集合：   方法名称   描述   typeOf   验证数据类型。   deepCopy   深拷贝。   uuid   生成 UUID。   download   下载。   getUrlArg   根据名称获取路径参数。   getUrlQuery   将路径参数转化为对象格式。   setUrlQuery   将对象格式转化为路径参数。   getDeepValueOfObject   获取对象深层值。   toThousands   转化为千位分隔符格式。   typeOf(anything)   验证数据类型。   返回值均为字符串   enum TypeValue {Boolean = 'boolean',Number = 'number',String = 'string',Function = 'function',Array = 'array',Date = 'date',RegExp = 'regexp',Undefined = 'undefined',Null = 'null',Object = 'object'}   const TypeMap: Record&lt;string, TypeValue&gt; = {  &#39;[object Boolean]&#39;: TypeValue.Boolean,   &#39;[object Number]&#39;: TypeValue.Number,  &#39;[object String]&#39;: TypeValue.String,  &#39;[object Function]&#39;: TypeValue.Function,  &#39;[object Array]&#39;: TypeValue.Array,  &#39;[object Date]&#39;: TypeValue.Date,  &#39;[object RegExp]&#39;: TypeValue.RegExp,  &#39;[object Undefined]&#39;: TypeValue.Undefined,  &#39;[object Null]&#39;: TypeValue.Null,  &#39;[object Object]&#39;: TypeValue.Object};   /**   Validate data type.   @method typeOf   @param {any} obj   @return {string}   /export function typeOf(obj: unknown): TypeValue {const toString = Object.prototype.toString;return TypeMap[toString.call(obj)];}   console.log(typeOf(&#39;abc&#39;)); // stringconsole.log(typeOf([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])); // arrayconsole.log(typeOf({ a: 1, b: 2, c: 3 })); // object   * #### deepCopy(data)深拷贝。&gt; 该方法需要结合 `typeOf()` 方法一起使用```typescript/** * Data deep copy. * @method deepCopy * @param {array|object} data * @return {array|object} */export function deepCopy&lt;T&gt;(data: T): T {  const type: TypeValue = typeOf(data);  switch (type) {    case TypeValue.Array: {      const array: unknown[] = [];      for (let index = 0; index &lt; (data as unknown[]).length; index++) {        array.push(deepCopy(data[index]));      }      return array as T;    }    case TypeValue.Object: {      const object: Record&lt;string, unknown&gt; = {};      for (const key in data) {        if (Object.prototype.hasOwnProperty.call(data, key)) {          object[key] = deepCopy(data[key]);        }      }      return object as T;    }    default:      return data;  }}const obj1 = { a: 1, b: 2, c: 3 };const obj2 = deepCopy(obj1);console.log(obj1 === obj2); // false   formatDate(date, format)   日期格式化。   /*** Time and date formatting.* @method formatDate* @param {string|date} time* @return {string}*/export function formatDate(time: string | Date, format = 'yyyy-MM-dd hh:mm:ss'): string {const date: Date = time ? new Date(time) : new Date();const dateValues: Record&lt;string, number&gt; = {  'M+': date.getMonth() + 1, // 月  'd+': date.getDate(), // 日  'h+': date.getHours(), // 时  'm+': date.getMinutes(), // 分  's+': date.getSeconds(), // 秒  'q+': Math.floor((date.getMonth() + 3) / 3), // 季度  'S': date.getMilliseconds() // 毫秒};if (/(y{4})/.test(format)) {  format = format.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));}for (const key in dateValues) {  if (new RegExp('(' + key + ')').test(format)) {    const value = dateValues[key].toString();    format = format.replace(RegExp.$1, (RegExp.$1.length === 1) ? value : ('00' + value).substr(value.length));  }}return format;}   console.log(formatDate(&#39;2024-05-01&#39;)); // &#39;2024-05-01 00:00:00&#39;console.log(formatDate(&#39;2024-05-01&#39;, &#39;yyyy-MM-dd&#39;)); // &#39;2024-05-01&#39;   * #### uuid()生成 UUID。```javascript/** * @method uuid * @return {string} */function uuid() {  return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function (c) {    const r = Math.random() * 16 | 0;    const v = c === &apos;x&apos; ? r : (r &amp; 0x3 | 0x8);    return v.toString(16);  });}console.log(uuid()); // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   download(url, name)   下载。/*** @method download* @param {string} url* @param {string} name*/function download(url, name) {const aDom = document.createElement('a');aDom.download = name;aDom.href = url;document.body.appendChild(aDom);aDom.click();aDom.remove();}   console.log(download(&#39;word.docx&#39;, &#39;   https://www.test.com/word.docx&#39;   )); // word.docx   * #### getUrlArg(name)根据名称获取路径参数。```javascript/** * @method getUrlArg * @param {string} name * @return {string} */function getUrlArg(name) {  const search = window.location.search;  const regexp = new RegExp(`(^|&amp;)${name}=([^&amp;]*)(&amp;|$)`);  const arg = search.substr(1).match(regexp);  return arg ? arg[2] : &apos;&apos;;}   getUrlQuery(url)   将路径参数转化为对象格式。/*** @method getUrlQuery* @param {string} url* @return {object}*/function getUrlQuery(url) {const query = url.substring(url.indexOf('?') + 1).split('&amp;');const params = {};query.forEach(item =&gt; {  const key_value = item.split('=');  params[key_value[0]] = key_value[1];});return params;}   const url = &#39;   https://www.test.com/query?a=1&amp;b=2&amp;c=3&#39;   ;console.log(getUrlQuery(url)); // { a: 1, b: 2, c: 3 }   * #### setUrlQuery(url)将对象格式转化为路径参数。```javascript/** * @method setUrlQuery * @param {object} params * @return {string} */function setUrlQuery(params) {  const querys = [];  for (const key in params) {    if (params.hasOwnProperty(key)) {      querys.push(key + &apos;=&apos; + params[key]);    }  }  return querys.join(&apos;&amp;&apos;);}const params = { a: 1, b: 2, c: 3 };console.log(setUrlQuery(params)); // &apos;a=1&amp;b=2&amp;c=3&apos;   getDeepValueOfObject(object, keyPath, defaultValue)   获取对象深层值。   /*** @method getDeepValueOfObject* @param {object|array} object* @param {string} keyPath* @param {any} [defaultValue]* @return {any}*/function getDeepValueOfObject(object, keyPath, defaultValue) {const isString = typeof keyPath === 'string';if (!isString) {  console.warn('[getDeepValueOfObject warn]: keyPath is not a string, type ' + typeof keyPath);}if (object &amp;&amp; keyPath &amp;&amp; isString) {  const keys = keyPath.split('.');  let value = object;  for (let index = 0; index &lt; keys.length; index++) {    const key = keys[index];    if (value[key] !== undefined) {      value = value[key];    } else {      value = defaultValue;    }  }  return value;} else {  return defaultValue;}}   const obj = {  foo: {    number: 3  },  bar: 2,};const arr = [ obj ];   console.log(getDeepValueOfObject(obj, &#39;foo.number&#39;)); // 3console.log(getDeepValueOfObject(obj, &#39;bar.number&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;bar.number&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(obj, &#39;&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(arr, 0)); // undefinedconsole.log(getDeepValueOfObject(arr, &#39;0.foo.number&#39;)); // 3   * #### toThousands(number)转化为千位分隔符格式```javascript/** * @method toThousands * @param {number|string} number * @return {string} */function toThousands(number) {  if (Math.abs(Number(number)) &gt;= 1000) {    const [integer, float] = (number || 0).toString().split(&apos;.&apos;);    const thousandsInteger = integer.replace(/(\\d)(?=(?:\\d{3})+$)/g, &apos;$1,&apos;);    return thousandsInteger + (float ? &apos;.&apos; + float : &apos;&apos;);  } else {    return number;  }}","categories":["javascript"]},{"title":"黄瓜炒香肠","url":"/2020/12/05/sauteed-cucumber-sausage.html","content":"食材用料   食材   数量   黄瓜   1根   香肠   2根   油   适量   蒜   适量   盐   适量   鸡精   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    蒜切末装盘   3.    黄瓜切成片   4.    香肠斜切成片   5.    热锅热油，下香肠，炒至表面略焦装盘备用   6.    另起油下蒜末爆香   7.    下黄瓜片翻炒均匀   8.    加入香肠、盐、生抽和鸡精翻炒均匀   9.    收锅   10.    装盘","categories":["cookbook"]},{"title":"芹菜炒肉","url":"/2020/11/30/celery-fried-meat.html","content":"食材用料   食材   数量   芹菜   200克   鸡胸肉   半块   油   适量   蒜   适量   胡椒粉   适量   淀粉   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片   3.    芹菜切段，焯水   4.    肉切片，捏掉水，加入生抽、胡椒粉、淀粉   5.    搅拌至粘稠   6.    放油中火，放入调料爆香   7.    放入肉片翻炒   8.    放入芹菜段，再加入一点点水大火翻炒   9.    放盐、一点点老抽翻炒   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"芹菜香肠炒鸡蛋","url":"/2020/11/29/scrambled-eggs-with-celery-sausage.html","content":"食材用料   食材   数量   芹菜   150克   香肠   2根   鸡蛋   2个   油   少量   蒜   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    蒜切末装起来   3.    芹菜切段   4.    香肠切片   5.    鸡蛋打散   6.    热锅热油，倒入鸡蛋炒成定型，盛出备用   7.    锅烧热，下油加香肠炒一下   8.    香肠表面略焦加入蒜末和芹菜翻炒   9.    加入鸡蛋、盐、生抽翻炒入味   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"手撕鸡肉","url":"/2020/11/27/hand-tore-the-chicken.html","content":"食材用料   食材   数量   无骨鸡腿   2个   姜   适量   料酒   适量   葱   适量   蒜   适量   辣椒粉   适量   盐   适量   生抽   适量   香油   适量   藤椒油   适量   做法步骤   图片   步骤   1.    准备食材   2.    煮鸡腿调料：葱段、姜片、盐和料酒   3.    锅中放鸡腿、煮鸡腿调料，加水开始煮20分钟左右   4.    期间准备腌料：葱段、蒜末、辣椒粉、盐、生抽、藤椒油、香油   5.    鸡腿煮好后捞出撕碎   6.    把腌料倒进去拌匀   7.    装盘","categories":["cookbook"]},{"title":"麻辣鸡中翅","url":"/2020/10/31/spicy-chicken-medium-wing.html","content":"食材用料   食材   数量   鸡中翅   4块   油   少量   葱   适量   姜   适量   蒜   适量   八角   2个   辣椒圈   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   香油   适量   鸡翅必须焯水去血沫，不然菜味会变腥。   做法步骤   图片   步骤   1.    准备食材   2.    葱切葱花，蒜切末，姜切片，和辣椒圈花椒八角装起来   3.    鸡中翅解冻洗净割口（想入味又不想割口可以拿牙签刺）   4.    热锅热油，下鸡中翅炒至表面金黄   5.    下葱花、蒜末、辣椒圈、花椒、八角爆香   6.    加入半碗水、生抽、老抽、盐   7.    汤汁剩少许时加入香油出锅   8.    装盘","categories":["cookbook"]},{"title":"青菜炒肉","url":"/2020/10/31/green-vegetables-meat.html","content":"食材用料   食材   数量   青菜   250克   鸡胸肉   半块   油   多量   蒜   适量   辣椒圈   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   青菜不出水关键：多放油，炒完菜最后放盐。   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片、花椒、辣椒圈   3.    青菜洗净焯水   4.    肉切片，捏掉水，加入淀粉、生抽、一点点老抽   5.    搅拌至粘稠   6.    放油中火，放入蒜、辣椒圈、花椒爆香   7.    放入肉片翻炒至肉熟   8.    翻入青菜大火翻炒   9.    最后放入盐简单翻炒两下入味   10.    出锅   11.    装盘","categories":["cookbook"]},{"title":"土豆块炖肉","url":"/2020/10/21/potato-cubes-stew-with-meat.html","content":"食材用料   食材   数量   土豆   400克   鸡胸肉   半块   油   适量   葱   适量   姜   适量   蒜   适量   辣椒圈   适量   花椒   适量   桂叶   1片   盐   适量   老抽   少量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：葱花、蒜末、辣椒圈、花椒   3.    土豆切成块，加清水泡防止变色   4.    肉切片，捏掉水   5.    放油放入调料爆香   6.    中火放入肉炒熟   7.    放入土豆块翻炒均匀   8.    放入生抽、老抽、盐大火翻炒   9.    放香叶，加水，没过食材，大火收汁   10.    收锅   11.    装盘","categories":["cookbook"]},{"title":"土豆肉丝","url":"/2020/10/21/potato-with-meat-shreds.html","content":"食材用料   食材   数量   土豆   250克   猪肉   120克   油   适量   青椒   适量   蒜   适量   干辣椒   适量   花椒   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    青椒切条，蒜切片，和辣椒圈花椒装起来   3.    土豆切成丝，冲洗一遍去掉淀粉，加清水泡防止变色   4.    猪肉切成丝   5.    肉丝解冻，捏去多余水分   6.    热锅热油，油冒烟下肉丝爆香翻炒（肉丝有水注意锅里油乱蹦）   7.    放入青椒调料等，翻炒爆香   8.    放入土豆丝翻炒均匀，加入生抽、盐后翻炒均匀入味   9.    收锅   10.    装盘","categories":["cookbook"]},{"title":"React PropTypes","url":"/2020/09/17/react-proptypes.html","content":"Install   $ npm install prop-types --save   Use   Grammar One：   class Greeting extends Component {  static propTypes = {    className: PropTypes.string,    style: PropTypes.object,  };  static defaultProps = {    className: '',  };  render() { ... }}   Grammar Two：   class Greeting extends Component { ... }Greeting.propTypes = {  className: PropTypes.string,};Greeting.defaultProps = {  className: '',};   String   string: PropTypes.string   Number   number: PropTypes.number   Boolean   bool: PropTypes.bool   Array   array: PropTypes.array   Object   object: PropTypes.object   Symbol   symbol: PropTypes.symbol   Function   func: PropTypes.func   Required   // 必填isRequired: PropTypes.isRequiredstringIsRequired: PropTypes.string.isRequired   Anything   // 任意类型的数据any: PropTypes.any   Node   // 任何可被渲染的元素（包括数字、字符串、子元素或数组）node: PropTypes.node   Element   // 一个 React 元素element: PropTypes.element   ElementType   // 一个 React 元素类型（即，MyComponent）elementType: PropTypes.elementType   InstanceOf   // 声明属性为某个类的实例，这里使用 JS 的 instanceof 操作符实现。instanceOf: PropTypes.instanceOf(Message)   OneOf   // 限制你的属性值是某个特定值之一oneOf: PropTypes.oneOf(['News', 'Photos'])   OneOfType   // 限制它为列举类型之一的对象oneOfType: PropTypes.oneOfType([  PropTypes.string,  PropTypes.number,  PropTypes.instanceOf(Message)])   ArrayOf   // 一个指定元素类型的数组arrayOf: PropTypes.arrayOf(PropTypes.number)   ObjectOf   // 一个指定类型的对象objectOf: PropTypes.objectOf(PropTypes.number)   Shape   // 一个指定属性及其类型的对象objectWithShape: PropTypes.shape({  color: PropTypes.string,  fontSize: PropTypes.number})","categories":["react"]},{"title":"前端自动部署 GitHub Page","url":"/2019/12/05/deploy-github-page.html","content":"自己的项目部署在GitHub Page的时候很麻烦，要先build然后再把文件推到master/docs或者gh-pages分支上面，现在github有一个插件可以帮你完成上面步骤：   github地址：   gh-pages   安装：   $ npm install gh-pages --save-dev   注意：该模块需要git版本大于等于1.9   配置：   在 package.json 的 script 字段中添加以下代码   \"scripts\": {  \"deploy\": \"npm run build &amp; gh-pages -d dist\",}   接下来运行    npm run deploy    就会先执行build命令，然后开始向该项目的gh-pages分支推送刚build的文件，随后在github项目的 Settings &gt; GitHub Pages 在 Sourse 中选择 gh-pages branch ，稍等几分钟后打开网址查看   https://${username}.github.io/${project}   命令行参数说明   参数   说明   -d   要推送文件的目录，这里写的是项目根目录 dist 文件夹。   -m   推送信息，信息如果过长带空格的话在json中需要加上双引号    -m \\&quot;Update GitHub Page\\&quot;   -b   推送的分支，默认gh-pages   更多参数请在命令行中输入以下命令   $ gh-pages --help","categories":["note"]},{"title":"安装MySQL","url":"/2019/11/13/mysql-install.html","content":"Windows 上安装 MySQL   Windows 上安装 MySQL 相对来说会较为简单，最新版本可以在    MySQL 下载    中下载中查看(更详细安装：   Windows 上安装 MySQL   )。   点击 Download 按钮进入下载页面，点击下图中的 No thanks, just start my download. 就可立即下载：   下载完后，解压完成后为以下样子（我将安装文件放在 D:\\mysql 中）：   接下来我们需要配置下 MySQL 的配置文件   打开刚刚解压的文件夹 D:\\mysql ，在该文件夹下创建 my.ini 配置文件，编辑 my.ini 配置以下基本信息：   [client]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\web\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB   接下来我们来启动下 MySQL 数据库：   以管理员身份打开 cmd 命令行工具，切换目录：   $ cd C:\\web\\mysql-8.0.11\\bin   初始化数据库：   $ mysqld --initialize --console   注意：这个可能会报错：   mysqld : 无法将“mysqld”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。   解决办法有两个：1、在命令前面加上 ./ 如：   $ ./mysqld --initialize --console   2、   配置 mysql 环境变量   执行完成后，会输出 root 用户的初始默认密码，如：   ...2019-11-13T09:36:49.186128Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: &lt;!wbLjV?/3uq   &lt;!wbLjV?/3uq 就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。输入以下安装命令：   $ mysqld install   启动输入以下命令即可：   $ net start mysql   登录 MySQL   当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名:   $ mysql -h 主机名 -u 用户名 -p   参数说明：   -h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略;   -u : 登录的用户名;   -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。   如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：   $ mysql -u root -p   按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:   $ Enter password:   若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welcome to the MySQL monitor... 的提示语。然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。   配置 mysql 环境变量   上面安装的是时候我们看到mysql默认安装路径是：D:\\mysql 我的电脑右键—&gt;属性—&gt;高级系统设置—&gt;环境变量—&gt;新建MYSQL_HOME,将安装目录输入：   找到path编辑：输入%MYSQL_HOME%\\bin   打开 cmd 输入    mysql    检测一下   在 navicat for mysql 上链接 mysql   navicat for mysql 下载    安装完成后运行 navicat    客户端使用 navicat for mysql。本地安装了mysql 8.0。但是在链接的时候提示：   解决方法：   这行代码有两层含义，第一:修改root的密码为&#39;root&#39;，摒弃原来的旧密码。第二：使用mysql_native_password对新密码进行编码。   $ ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';   详情报错信息请看    navicat for mysql 链接时报错：1251...","categories":["database"]},{"title":"海浪涛天，一个老水兵的亲身经历","url":"/2019/10/31/wave-and-sky.html","content":"","categories":["reprint"]},{"title":"图片 JPEG 显示优化","url":"/2019/10/31/gradual-jpeg.html","content":"1. JPEG介绍   JPEG 是Joint Photographic Experts Group（联合图像专家小组）的缩写，是第一个国际图像压缩标准。JPEG图像压缩算法能够在提供良好的压缩性能的同时，具有比较好的重建质量，被广泛应用于图像、视频处理领域。   2. 保存方式   JPEG文件格式有两种保存方式。他们是Baseline JPEG和Progressive JPEG.两种格式有相同尺寸以及图像数据，他们的扩展名也是相同的，唯一的区别是二者显示的方式不同。   2.1 Baseline JPEG （基线）   这种类型的JPEG文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在JPEG文件中。打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来，直到所有的数据都被读完，就完成了整张图片的显示。如果文件较大或者网络下载速度较慢，那么就会看到图片被一行行加载的效果，这种格式的JPEG没有什么优点，因此，一般都推荐使用Progressive JPEG   2.2 Progressive JPEG （渐进）   和Baseline一遍扫描不同，Progressive JPEG文件包含多次扫描，这些扫描顺寻的存储在JPEG文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。这种格式的主要优点是在网络较慢的情况下，可以看到图片的轮廓知道正在加载的图片大概是什么。在一些网站打开较大图片时，你就会注意到这种技术。   3. 如何创建   使用Photoshop   文件 &gt; 存储为 &gt; 先点击保存，随后会弹出JPEG选项   如果想创建渐进式JPEG，选择连续   4. 应用   基本JPEG和渐进JPEG该什么时候使用？   当您的JPEG图像低于10K时，最好保存为基本JPEG（估计有75％的可能性会更小）对于超过10K的文件，渐进式JPEG将为您提供更好的压缩（在94％的情况下）Chrome + Firefox + IE9浏览器下，渐进式图片加载更快，而且是快很多，至于其他浏览器，与基本式图片的加载一致，至少不会拖后腿。   渐进式图片也有不足，就是吃CPU吃内存。","categories":["note"]},{"title":"母鸡与前端工程师","url":"/2019/10/25/hen-and-front-end-engineer.html","content":"","categories":["reprint"]},{"title":"RegExp","url":"/2019/10/22/regexp.html","content":"JavaScript RegExp 对象   语法   var regexp = new RegExp(pattern, modifiers);    // 通过 RegExp 构造函数创建var regexp = /[pattern]/[modifiers];            // 通过字面量创建   pattern（模式） 描述了表达式的模式   modifiers (修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配   注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的：    var regexp = new RegExp('\\\\w+');var regexp = /\\w+/;   修饰符   修饰符 (Modifiers) 用于指定全局匹配、区分大小写的匹配和多行匹配：   修饰符   描述   i   执行对大小写不敏感的匹配。   g   执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。   m   执行多行匹配。   s   允许 . 匹配换行符。   u   使用 unicode 码的模式进行匹配。   y   执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。   量词   量词（Quantifiers）定义了重复匹配字符的确数或约数：   量词   描述   n+   匹配任何包含至少一个 n 的字符串。   n*   匹配任何包含零个或多个 n 的字符串。   n?   匹配任何包含零个或一个 n 的字符串。   n{X}   匹配包含 X 个 n 的序列的字符串。   n{X,}   匹配包含最少 x 个、最多 y 个 n 的序列的字符串。   n{X,Y}   匹配包含至少 x 个 n 的序列的字符串。   ^n   匹配任何开头为 n 的字符串。   n$   匹配任何结尾为 n 的字符串。   ?=n   匹配任何其后紧接指定字符串 n 的字符串。   ?!n   匹配任何其后没有紧接指定字符串 n 的字符串。   元字符   元字符（Metacharacter）是拥有特殊含义的字符：   元字符   描述   .   （小数点）默认匹配除   换行符   之外的任何单个字符。   \\w   匹配单词字符（数字，字母，下划线）。   \\W   匹配非单词字符。   \\d   匹配数字。   \\D   匹配非数字字符。   \\s   匹配空白字符。   \\S   匹配非空白字符。   \\b   匹配单词边界。   \\B   匹配非单词边界。   \\0   匹配 NULL 字符。   \\n   匹配换行符。   \\f   匹配换页符。   \\r   匹配回车符。   \\t   匹配制表符。   \\v   匹配垂直制表符。   \\xxx   匹配以八进制数 xxx 规定的字符。   \\xdd   匹配以十六进制数 dd 规定的字符。   \\uxxxx   匹配以十六进制数 xxxx 规定的 Unicode 字符。   方括号   方括号用于查找某个范围内的字符：   表达式   描述   [^]   匹配任意任何字符。（可以匹配到   换行符   ）   [abc]   匹配方括号之间的任何字符。   [^abc]   匹配任何不在方括号之间的字符。   [0-9]   匹配任何从 0 至 9 的数字。   [a-z]   匹配任何从小写 a 到小写 z 的字符。   [A-Z]   匹配任何从大写 A 到大写 Z 的字符。   [A-z]   匹配任何从大写 A 到小写 z 的字符。   (red|blue|green)   匹配任何指定的选项。   RegExp 对象方法   表达式   描述   compile   编译正则表达式。   exec   检索字符串中指定的值。返回找到的值，并确定其位置。   test   检索字符串中指定的值。返回 true 或 false。   支持正则表达式的 String 对象的方法   表达式   描述   search   检索与正则表达式相匹配的值。。   match   找到一个或多个正则表达式的匹配。   replace   替换与正则表达式匹配的子串。   split   把字符串分割为字符串数组。   在多行文本中使用正则表达式   var string = 'Please yes\\nmake my day!';string.match(/yes.*day/); // nullstring.match(/yes[^]*day/); // 'yes\\nmake my day'   先行断言和先行否定断言   先行断言（lookahead）指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。   var string = '100% of US presidents have been male';/\\d+(?=%)/.exec(string); // ['100']/have(?=%)/.exec(string); // null   先行否定断言（negative lookahead）x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。   var string = 'that’s all 44 of them';/\\d+(?!%)/.exec(string); // ['44']/\\d+(?!.*of)/.exec(string); // null/\\d+(?!.*all)/.exec(string); // ['44']/\\d+(?!.*of|.*all)/.exec(string); // null   后行断言和后行否定断言   ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。后行断言（lookbehind）指的是，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成 /(?&lt;=\\$)\\d+/。   var string = 'Benjamin Franklin is on the $100 bill';/(?&lt;=\\$)\\d+/.exec(string);  // [\"100\"]   后行否定断言（negative lookbehind）指的是，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成 /(?&lt;!\\$)\\d+/。   var string = 'it’s is worth about €90';/(?&lt;!\\$)\\d+/.exec(string);  // [\"90\"]   贪婪模式和非贪婪模式   贪婪模式: 正则表达式一般趋向于最大长度匹配，总是尝试匹配尽可能多的字符。   var html = '&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;';var regexp = /(&lt;.*&gt;)/;html.match(regexp); // ['&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;']   非贪婪模式: 非贪婪匹配就是匹配到结果就好，总是尝试匹配尽可能少的字符。   var html = '&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;';var regexp = /(&lt;.*?&gt;)/;html.match(regexp); // ['&lt;html&gt;']   针对 6 种重复类惰性匹配的简单描述如下：   {n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。   {n}?：尽量匹配 n 次。   {n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。   ??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。   +?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。   *? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。   捕获型分组和非捕获型分组   捕获型()：捕获型分组会把每个捕获分组所匹配的内容暂且存储在某个地方，以便下次使用。在JavaScript中，捕获性分组所匹配的内容都是以$1,$2,$3…的格式保存的。因此捕获型分组会有性能上的损失。   var string = 'sjds24324abcabc1234';var regexp = /(abc){2}/;string.match(regexp); // ['abcabc', 'abc']   非捕获型(?:)：非捕获型分组只会返回一个不含各个分组匹配（不含字串）的结果。所以会提高匹配速度。   var string = 'sjds24324abcabc1234';var regexp = /(?:abc){2}/;string.match(regexp); // ['abcabc']   正则命名组捕获   正则命名组捕获使用符号 ?    表示，对匹配到的正则结果按名称访问。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。   var date = '2023-01-01';var regexp = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u;regexp.exec('2023-01-01'); // { year: '2023', month: '01', day: '01' }","categories":["javascript"]},{"title":"VSCode","url":"/2019/09/21/vscode.html","content":"插件   GitLens   ：显示某一行代码是谁写的   vscode-fileheader   ：显示文件作者修改信息   ESLint   ：使用项目下的eslint配置文件检查项目代码   Prettier - Code formatter   ：prettier格式化代码   Tailwind CSS IntelliSense   ：Tailwind css语法提示插件   {  \"recommendations\": [    \"eamodio.gitlens\",    \"dbaeumer.vscode-eslint\",    \"esbenp.prettier-vscode\",    \"bradlc.vscode-tailwindcss\"  ]}   VSCode编辑器设置：   {  \"editor.detectIndentation\": true,  \"editor.tabSize\": 2,  \"files.eol\": \"\\n\",  \"files.autoSave\": \"off\",  \"editor.formatOnSave\": true,  \"editor.formatOnType\": false,  \"editor.formatOnPaste\": false,  \"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\",  \"emmet.triggerExpansionOnTab\": true,  \"editor.wordWrap\": \"on\",  \"workbench.tree.enableStickyScroll\": false,  \"editor.stickyScroll.enabled\": false,  \"extensions.ignoreRecommendations\": true,  \"http.proxy\": \"http://127.0.0.1:1000\"}   缩进    Indentation   detectIndentation    - 控制打开文件时是否根据文件内容自动检测“editor.tabSize”和“editor.insertSpaces”。   tabSize    - 制表符等于空格数。 当“editor.detectIndentation”打开时，此设置将根据文件内容被覆盖。   insertSpaces    - 按“Tab”时插入空格。 当“editor.detectIndentation”打开时，此设置将根据文件内容被覆盖。   {\"editor.detectIndentation\": true,\"editor.tabSize\": 2,\"editor.insertSpaces\": true}   行结束符   默认的行结束符。   值   说明   \\n   LF (Linux)   \\r\\n   CRLF (Windows)   auto   Uses operating system specific end of line character.   {  \"files.eol\": \"\\n\",  // Configure settings to be overridden for the shellscript language.  \"[shellscript]\": {    \"files.eol\": \"\\n\"  }}   自动保存    Auto Save   值   说明   off   to disable auto save.   afterDelay   to save files after a configured delay (default 1000 ms).   onFocusChange   to save files when focus moves out of the editor of the dirty file.   onWindowChange   to save files when the focus moves out of the VS Code window.   {  \"files.autoSave\": \"off\",  \"files.autoSaveDelay\": 1000}   自动格式化    Formatting   formatOnSave    - 保存时格式化代码文件   formatOnType    - 输入后格式化该行代码   formatOnPaste    - 格式化粘贴内容   {\"editor.formatOnSave\": true,\"editor.formatOnType\": false,\"editor.formatOnPaste\": false}   默认格式化插件    Default formatter   dbaeumer.vscode-eslint    - Eslint Plugin.   esbenp.prettier-vscode    - Prettier - Code formatter.   {// 将根据eslint配置格式化代码\"editor.defaultFormatter\": \"dbaeumer.vscode-eslint\"}   换行   代码长度超过编辑器可视宽度是否换行   {\"editor.wordWrap\": \"on\"}   展开缩写    Emmet   使用快捷语法展开标签，例如 ul&gt;li*3&gt;span.hello   {\"emmet.triggerExpansionOnTab\": true}   粘滞滚动    Sticky Scroll   https://code.visualstudio.com/updates/v1_85#_sticky-scroll-in-trees   {\"workbench.tree.enableStickyScroll\": false,\"editor.stickyScroll.enabled\": false}   其他   ignoreRecommendations    - 设置true可以禁止推荐插件推送，    详情见这里   proxy    - 编辑器设置代理   {\"extensions.ignoreRecommendations\": true,\"http.proxy\": \"http://127.0.0.1:1000\"}   格式化代码快捷键：   Windows   Shift + Alt + F   Mac   Shift + Option + F   Ubuntu   Ctrl + Shift + I   快捷键配置：   Redo（反撤销）：   Ctrl + Shift + Z   -&gt;   Ctrl + Y   Copy Line Down（快速拷贝一行）:   Shift + Alt + ↓   -&gt;   Ctrl + D   Transform to Uppercase（转为大写）:   Null   -&gt;   Ctrl + Shift + U   Transform to Lowercase（转为小写）:   Null   -&gt;   Ctrl + Shift + I","categories":["note"]},{"title":"Webstorm","url":"/2019/09/20/webstorm.html","content":"设置中文字体   Show only monospaced fonts 取消打钩   Font：consolas   Size：14   Line spacing: 1.2   Fallback font：Microsoft YaHei   格式化代码快捷键：   Ctrl + Alt + L   键盘快捷键：   Add Or Remove Caret（多光标）:   Alt+ Button1 Click   Redo（反撤销）:   Ctrl + Shift + Z   Expand Live Template / Emmet Abbreviation（展开标签）:   Tab   Fix ESLint Problems（修复ESLint错误）:   Alt + Shift + L   花括号和中括号之间加上空格配置：   Setting &gt; Editor &gt; Code Style &gt; JavaScript &gt; Space,  找到 Within，勾选以下几项并打上勾：   Object literal braces   ES6 import/export braces   Array brackets   Interpolation expressions   配置ESlint   Setting &gt; Plugins，安装ESlint插件   Setting &gt; ESLint Settings，配置   Setting 搜索ESLint，或者查找 Setting &gt; Languages &amp; Frameworks &gt; JavaScript &gt; Code Quality Tools &gt; ESLint   取消webstorm自动保存   第一步：   Settings &gt; Appearance &amp; Behavior &gt; System Settings&gt; Synchronization   &gt; Synchroniza files on frame or editor tab activation           // 激活当前窗口时保存   &gt; Save files on frame deactivation                                       // 切换到其他窗口时保存   &gt; Save files automatically if application is idle for  15 sec.    // 设定一个时间自动保存   &gt; Use &quot;safe write&quot; (save changes to a temporary file first)    // 安全写入,这个选项会不停的保存源文件,因此关闭最后一个就好   第二步：   Settings &gt; Editor &gt; General &gt; Editor Tabs&gt; Appearance   &gt; Mark modified(*)   // 被修改的文件会出现 * 号（在文件图标右下角）","categories":["note"]}]