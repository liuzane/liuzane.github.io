<!doctype html><html lang="en"><head><meta charset="utf-8"><title>RegExp</title><meta name="author" content="Zane"><meta name="keywords" content="RegExp, JavaScript, Regular Expression, Pattern, Matching, Syntax, Modifiers, Quantifiers, Metacharacters"><meta name="description" content="Introduce the RegExp object in JavaScript, including the syntax, modifiers, quantifiers, and metacharacters."><meta name="robots" content="index, follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="alternate" href="https://liuzane.github.io/en" hreflang="en"><link rel="alternate" href="https://liuzane.github.io/zh" hreflang="zh"><link rel="alternate" href="https://liuzane.github.io/ja" hreflang="ja"><link rel="alternate" href="https://liuzane.github.io" hreflang="x-default"><link rel="canonical" href="https://liuzane.github.io/en/2019/10/22/regexp.html"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/article.css"></head><body><div id="container"><div id="nav" class="frosted-glass"><nav id="nav-wrap"><a class="nav-link" href="/en">Home</a> <a class="nav-link" href="/en/archives">Archives</a> <a class="nav-link" href="/en/categories">Categories</a> <a class="nav-link" href="https://liuzane.github.io/tools" target="_blank">Tools</a> <a class="nav-link" href="https://liuzane.github.io/laboratory" target="_blank">Laboratory</a> <a class="nav-link" href="/en/about">About</a></nav></div><div id="nav-lang"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="2em" height="2em"><path d="M512 742.4a230.4 230.4 0 1 0 0-460.8 230.4 230.4 0 0 0 0 460.8z m0 57.6a288 288 0 1 1 0-576 288 288 0 0 1 0 576zM380.256 267.2l25.664-13.984c0-0.8-0.032-0.832 4.832 3.2 25.6 26.976 38.368 49.92 38.368 68.8 0 5.312 0.192 10.08 0.736 19.776 1.792 31.232 1.376 43.04-5.664 58.88-10.848 24.544-34.176 36.544-67.072 36.544-27.456 0-49.696 6.464-88.96 23.296-30.4 13.024-33.28 14.208-45.952 18.432l10.592-41.728c10.432-3.456-15.68-17.504 12.704-29.664 45.888-19.648 74.336-27.936 111.616-27.936 7.392 0 12-0.896 14.208-2.048 1.92-4.128 2.24-11.712 1.024-32.512-0.64-10.752-0.832-16.288-0.832-23.04 0-8.256-16.48-23.552-17.632-24.512-16.8-13.984 6.4-12.832 6.4-33.504z m225.312 325.728c-24.896-13.632-41.024-28.512-48.896-52.096-2.656-8-8.832-13.952-20.128-19.712-5.248-2.656-24.832-10.624-27.776-12.032-15.68-7.52-25.568-16.544-25.568-34.944 0-16.224 0.864-27.68 4.512-41.856 5.952-23.008 17.92-42.144 37.824-54.592 17.664-11.04 36.288-12.128 56.832-5.92 6.848 2.048 13.568 4.736 22.784 8.864-0.928-0.448 16.96 7.68 22.24 9.984 12.736 5.472 23.808 9.408 35.584 12.352a205.216 205.216 0 0 0 101.248 0l13.952 55.904a262.784 262.784 0 0 1-129.152 0 283.04 283.04 0 0 1-44.416-15.36c-47.584-20.48-44.448-19.52-48.544-16.96-8.896 5.568-13.312 16.864-14.72 33.792 6.784 2.848 16.416 6.944 21.344 9.44 23.584 12 40.448 28.32 48.64 52.832 2.208 6.592 8.544 12.48 21.888 19.776 3.2 1.76 17.12 8.832 20.64 10.752 26.528 14.624 40.512 33.184 28.736 61.6-9.152 22.08-25.088 32.928-54.72 44.576-0.96 0.384-19.648 7.488-25.152 9.76-9.28 3.808-17.024 7.488-24.224 11.648a137.6 137.6 0 0 0-7.328 4.544c-19.904 13.28-30.368 37.728-30.368 76.864h-57.6c0-56.896 18.336-99.648 56-124.8 3.424-2.24 6.88-4.384 10.432-6.432a248.64 248.64 0 0 1 31.232-15.136c6.304-2.56 25.568-9.92 25.92-10.048a168.32 168.32 0 0 0 12.768-5.504 1102.944 1102.944 0 0 1-13.984-7.296z" p-id="1465"></path></svg></div><div id="nav-lang-list"><a class="lang-link" href="/en/2019/10/22/regexp.html" hreflang="en">English</a> <a class="lang-link" href="/zh/2019/10/22/regexp.html" hreflang="zh">简体中文</a> <a class="lang-link" href="/ja/2019/10/22/regexp.html" hreflang="ja">日本語</a></div><div id="scroller"><div id="wrapper"><header id="header" class="frosted-glass"><div class="header-wrapper"><img src="/images/aodamiao.jpg" alt="Zane" class="header-avatar"><p class="header-author">Zane</p><p class="header-description">Study hard and make progress every day</p></div></header><section id="content"><article class="article"><a class="article-back" href="javascript: history.back(-1)">&lt; Back</a><header class="article-header"><h1 class="article-title">RegExp</h1><div class="article-meta"><time datetime="2025-07-05T08:57:39.000Z" class="article-date">2025-07-05</time></div></header><div class="article-content"><h2 id="JavaScript-RegExp-Object"><a href="#JavaScript-RegExp-Object" class="headerlink" title="JavaScript RegExp Object"></a>JavaScript RegExp Object</h2><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(pattern, modifiers);    <span class="comment">// Create via RegExp constructor</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/[pattern]/</span>[modifiers];            <span class="comment">// Create via literal</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>pattern describes the expression pattern</li><li>modifiers are used to specify global matching, case-sensitive matching, and multiline matching</li></ul><p>Note: When using the constructor to create a regular expression object, you need to follow the regular character escaping rules (add backslash \ in front). For example, the following are equivalent:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\w+&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/\w+/</span>;</span><br></pre></td></tr></table></figure><h4 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h4><blockquote><p>Modifiers are used to specify global matching, case-sensitive matching, and multiline matching:</p></blockquote><table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody><tr><td>i</td><td>Perform case-insensitive matching.</td></tr><tr><td>g</td><td>Perform global matching (find all matches rather than stopping after the first match).</td></tr><tr><td>m</td><td>Perform multiline matching.</td></tr><tr><td>s</td><td>Allow . to match newline characters.</td></tr><tr><td>u</td><td>Use unicode code patterns for matching.</td></tr><tr><td>y</td><td>Perform “sticky” search, matching from the current position of the target string.</td></tr></tbody></table><h4 id="Quantifiers"><a href="#Quantifiers" class="headerlink" title="Quantifiers"></a>Quantifiers</h4><blockquote><p>Quantifiers define the exact or approximate number of repeated character matches:</p></blockquote><table><thead><tr><th>Quantifier</th><th>Description</th></tr></thead><tbody><tr><td>n+</td><td>Match any string containing at least one n.</td></tr><tr><td>n*</td><td>Match any string containing zero or more n.</td></tr><tr><td>n?</td><td>Match any string containing zero or one n.</td></tr><tr><td>n{X}</td><td>Match strings containing a sequence of X n’s.</td></tr><tr><td>n{X,}</td><td>Match strings containing at least X n’s in sequence.</td></tr><tr><td>n{X,Y}</td><td>Match strings containing at least X n’s in sequence.</td></tr><tr><td>^n</td><td>Match any string that starts with n.</td></tr><tr><td>n$</td><td>Match any string that ends with n.</td></tr><tr><td>?=n</td><td>Match any string that is immediately followed by the specified string n.</td></tr><tr><td>?!n</td><td>Match any string that is not immediately followed by the specified string n.</td></tr></tbody></table><h4 id="Metacharacters"><a href="#Metacharacters" class="headerlink" title="Metacharacters"></a>Metacharacters</h4><blockquote><p>Metacharacters are characters with special meanings:</p></blockquote><table><thead><tr><th>Metacharacter</th><th>Description</th></tr></thead><tbody><tr><td>.</td><td>(Decimal point) By default matches any single character except <strong><em>newline</em></strong>.</td></tr><tr><td>\w</td><td>Match word characters (digits, letters, underscore).</td></tr><tr><td>\W</td><td>Match non-word characters.</td></tr><tr><td>\d</td><td>Match digits.</td></tr><tr><td>\D</td><td>Match non-digit characters.</td></tr><tr><td>\s</td><td>Match whitespace characters.</td></tr><tr><td>\S</td><td>Match non-whitespace characters.</td></tr><tr><td>\b</td><td>Match word boundaries.</td></tr><tr><td>\B</td><td>Match non-word boundaries.</td></tr><tr><td>\0</td><td>Match NULL character.</td></tr><tr><td>\n</td><td>Match newline character.</td></tr><tr><td>\f</td><td>Match form feed character.</td></tr><tr><td>\r</td><td>Match carriage return character.</td></tr><tr><td>\t</td><td>Match tab character.</td></tr><tr><td>\v</td><td>Match vertical tab character.</td></tr><tr><td>\xxx</td><td>Match character specified by octal number xxx.</td></tr><tr><td>\xdd</td><td>Match character specified by hexadecimal number dd.</td></tr><tr><td>\uxxxx</td><td>Match Unicode character specified by hexadecimal number xxxx.</td></tr></tbody></table><h4 id="Square-Brackets"><a href="#Square-Brackets" class="headerlink" title="Square Brackets"></a>Square Brackets</h4><blockquote><p>Square brackets are used to find characters within a certain range:</p></blockquote><table><thead><tr><th>Expression</th><th>Description</th></tr></thead><tbody><tr><td>[^]</td><td>Match any character. (Can match <strong><em>newline</em></strong>)</td></tr><tr><td>[abc]</td><td>Match any character between the square brackets.</td></tr><tr><td>[^abc]</td><td>Match any character not between the square brackets.</td></tr><tr><td>[0-9]</td><td>Match any digit from 0 to 9.</td></tr><tr><td>[a-z]</td><td>Match any character from lowercase a to lowercase z.</td></tr><tr><td>[A-Z]</td><td>Match any character from uppercase A to uppercase Z.</td></tr><tr><td>[A-z]</td><td>Match any character from uppercase A to lowercase z.</td></tr><tr><td>(red|blue|green)</td><td>Match any specified option.</td></tr></tbody></table><h4 id="RegExp-Object-Methods"><a href="#RegExp-Object-Methods" class="headerlink" title="RegExp Object Methods"></a>RegExp Object Methods</h4><table><thead><tr><th>Expression</th><th>Description</th></tr></thead><tbody><tr><td>compile</td><td>Compile regular expression.</td></tr><tr><td>exec</td><td>Retrieve specified value in string. Returns found value and determines its position.</td></tr><tr><td>test</td><td>Retrieve specified value in string. Returns true or false.</td></tr></tbody></table><h4 id="String-Object-Methods-Supporting-Regular-Expressions"><a href="#String-Object-Methods-Supporting-Regular-Expressions" class="headerlink" title="String Object Methods Supporting Regular Expressions"></a>String Object Methods Supporting Regular Expressions</h4><table><thead><tr><th>Expression</th><th>Description</th></tr></thead><tbody><tr><td>search</td><td>Retrieve value matching regular expression.</td></tr><tr><td>match</td><td>Find one or more regular expression matches.</td></tr><tr><td>replace</td><td>Replace substring matching regular expression.</td></tr><tr><td>split</td><td>Split string into string array.</td></tr></tbody></table><h4 id="Using-Regular-Expressions-in-Multiline-Text"><a href="#Using-Regular-Expressions-in-Multiline-Text" class="headerlink" title="Using Regular Expressions in Multiline Text"></a>Using Regular Expressions in Multiline Text</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(<span class="regexp">/yes.*day/</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(<span class="regexp">/yes[^]*day/</span>); <span class="comment">// &#x27;yes\nmake my day&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Lookahead-and-Negative-Lookahead-Assertions"><a href="#Lookahead-and-Negative-Lookahead-Assertions" class="headerlink" title="Lookahead and Negative Lookahead Assertions"></a>Lookahead and Negative Lookahead Assertions</h4><blockquote><p>Lookahead assertion means that x only matches if it’s followed by y, must be written as /x(?=y)/. For example, to only match numbers before percent sign, write /\d+(?=%)/.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;100% of US presidents have been male&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?=%)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// [&#x27;100&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/have(?=%)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><blockquote><p>Negative lookahead assertion means that x only matches if it’s not followed by y, must be written as /x(?!y)/. For example, to only match numbers not before percent sign, write /\d+(?!%)/.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;that&#x27;</span>s all <span class="number">44</span> <span class="keyword">of</span> them<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\d+(?!%)/.exec(string); // [&#x27;</span><span class="number">44</span><span class="string">&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\d+(?!.*of)/.exec(string); // null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\d+(?!.*all)/.exec(string); // [&#x27;</span><span class="number">44</span><span class="string">&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\d+(?!.*of|.*all)/.exec(string); // null</span></span><br></pre></td></tr></table></figure><h4 id="Lookbehind-and-Negative-Lookbehind-Assertions"><a href="#Lookbehind-and-Negative-Lookbehind-Assertions" class="headerlink" title="Lookbehind and Negative Lookbehind Assertions"></a>Lookbehind and Negative Lookbehind Assertions</h4><blockquote><p>ES2018 introduced lookbehind assertions, V8 engine version 4.9 (Chrome 62) already supports it.<br>Lookbehind assertion means that x only matches if it’s preceded by y, must be written as /(?&lt;=y)x/. For example, to only match numbers after dollar sign, write /(?&lt;=$)\d+/.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Benjamin Franklin is on the $100 bill&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/(?&lt;=\$)\d+/</span>.<span class="title function_">exec</span>(string);  <span class="comment">// [&quot;100&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>Negative lookbehind assertion means that x only matches if it’s not preceded by y, must be written as /(?&lt;!y)x/. For example, to only match numbers not after dollar sign, write /(?&lt;!$)\d+/.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;it&#x27;</span>s is worth about €<span class="number">90</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/(?&lt;!\$)\d+/.exec(string);  // [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="Greedy-and-Non-greedy-Modes"><a href="#Greedy-and-Non-greedy-Modes" class="headerlink" title="Greedy and Non-greedy Modes"></a>Greedy and Non-greedy Modes</h4><blockquote><p>Greedy mode: Regular expressions generally tend toward maximum length matching, always trying to match as many characters as possible.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(&lt;.*&gt;)/</span>;</span><br><span class="line"></span><br><span class="line">html.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>Non-greedy mode: Non-greedy matching means matching just enough to get the result, always trying to match as few characters as possible.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(&lt;.*?&gt;)/</span>;</span><br><span class="line"></span><br><span class="line">html.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;&lt;html&gt;&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>Simple description of lazy matching for 6 repetition types:</p><ul><li>{n,m}?: Try to match n times, but may repeat up to m times to satisfy constraints.</li><li>{n}?: Try to match n times.</li><li>{n,}?: Try to match n times, but may match any number of times to satisfy constraints.</li><li>??: Try to match, but may match at most 1 time to satisfy constraints, equivalent to {0,1}?.</li><li>+?: Try to match 1 time, but may match any number of times to satisfy constraints, equivalent to {1,}?.</li><li>*?: Try not to match, but may match any number of times to satisfy constraints, equivalent to {0,}?.</li></ul></blockquote><h4 id="Capturing-and-Non-capturing-Groups"><a href="#Capturing-and-Non-capturing-Groups" class="headerlink" title="Capturing and Non-capturing Groups"></a>Capturing and Non-capturing Groups</h4><blockquote><p>Capturing (): Capturing groups temporarily store the content matched by each capturing group somewhere for later use. In JavaScript, the content matched by capturing groups is saved in the format $1, $2, $3, etc. Therefore, capturing groups have performance overhead.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;sjds24324abcabc1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(abc)&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;abcabc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>Non-capturing (?:): Non-capturing groups only return a result without individual group matches (without substrings). So it improves matching speed.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;sjds24324abcabc1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?:abc)&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;abcabc&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="Named-Group-Captures"><a href="#Named-Group-Captures" class="headerlink" title="Named Group Captures"></a>Named Group Captures</h4><blockquote><p>Named group captures use the symbol ?&lt;name&gt; to access matched regular expression results by name. If a named group doesn’t match, the corresponding groups object property will be undefined.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line">regexp.<span class="title function_">exec</span>(<span class="string">&#x27;2023-01-01&#x27;</span>); <span class="comment">// &#123; year: &#x27;2023&#x27;, month: &#x27;01&#x27;, day: &#x27;01&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div><div class="article-divider"></div><script src="https://giscus.app/client.js" data-lang="en" data-repo="liuzane&#x2F;liuzane.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMTY3ODEyNDM&#x3D;" data-category="Announcements" data-category-id="DIC_kwDODOvRu84CwfsS" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" crossorigin="anonymous" async></script></article></section><footer id="footer" class="frosted-glass"><div class="footer-wrapper"><a href="/" class="footer-title">Zane&#39;s Blog</a><p>This small world built by me</p></div></footer></div></div></div><script src="/js/i18n.js"></script></body></html>