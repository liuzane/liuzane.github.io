<!doctype html><html lang="en"><head><meta charset="utf-8"><title>RegExp - LiuZheng&#39;s Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="google-site-verification" content="7if7tEoBzofIpEcyTBbXYj68Uwni_Udf_J_RnIMKkx0"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/article.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="container"><div id="nav"><nav id="nav-wrap"><a class="nav-link" href="/">Home</a> <a class="nav-link" href="/archives">Archives</a> <a class="nav-link" href="/categories">Categories</a> <a class="nav-link" href="https://liuzane.github.io/tools">Tools</a> <a class="nav-link" href="/about">About</a></nav><div class="frosted-glass"></div></div><div id="wrapper"><header id="header"><div class="header-wrapper"><img src="/images/aodamiao.jpg" class="header-avatar"><p class="header-author">Zheng Liu</p><p class="header-description">Study hard and make progress every day</p></div><div class="frosted-glass"></div></header><section id="content"><article class="article"><a class="article-back" href="javascript: history.back(-1)">&lt; Back</a><header class="article-header"><h1 class="article-title">RegExp</h1><div class="article-meta"><time datetime="2019-10-22T08:57:39.000Z" class="article-date">2019-10-22</time></div></header><div class="article-content"><h2 id="JavaScript-RegExp-对象"><a href="#JavaScript-RegExp-对象" class="headerlink" title="JavaScript RegExp 对象"></a>JavaScript RegExp 对象</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern, modifiers);    <span class="comment">// 通过 RegExp 构造函数创建</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/[pattern]/</span>[modifiers];            <span class="comment">// 通过字面量创建</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>pattern（模式） 描述了表达式的模式</li><li>modifiers (修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</li></ul><p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\\w+&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/\w+/</span>;</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><blockquote><p>修饰符 (Modifiers) 用于指定全局匹配、区分大小写的匹配和多行匹配：</p></blockquote><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>执行对大小写不敏感的匹配。</td></tr><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td>m</td><td>执行多行匹配。</td></tr><tr><td>s</td><td>允许 . 匹配换行符。</td></tr><tr><td>u</td><td>使用 unicode 码的模式进行匹配。</td></tr><tr><td>y</td><td>执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。</td></tr></tbody></table><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><blockquote><p>量词（Quantifiers）定义了重复匹配字符的确数或约数：</p></blockquote><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td>n?</td><td>匹配任何包含零个或一个 n 的字符串。</td></tr><tr><td>n{X}</td><td>匹配包含 X 个 n 的序列的字符串。</td></tr><tr><td>n{X,}</td><td>匹配包含最少 x 个、最多 y 个 n 的序列的字符串。</td></tr><tr><td>n{X,Y}</td><td>匹配包含至少 x 个 n 的序列的字符串。</td></tr><tr><td>^n</td><td>匹配任何开头为 n 的字符串。</td></tr><tr><td>n$</td><td>匹配任何结尾为 n 的字符串。</td></tr><tr><td>?=n</td><td>匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td>?!n</td><td>匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><blockquote><p>元字符（Metacharacter）是拥有特殊含义的字符：</p></blockquote><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>（小数点）默认匹配除<strong><em>换行符</em></strong>之外的任何单个字符。</td></tr><tr><td>\w</td><td>匹配单词字符（数字，字母，下划线）。</td></tr><tr><td>\W</td><td>匹配非单词字符。</td></tr><tr><td>\d</td><td>匹配数字。</td></tr><tr><td>\D</td><td>匹配非数字字符。</td></tr><tr><td>\s</td><td>匹配空白字符。</td></tr><tr><td>\S</td><td>匹配非空白字符。</td></tr><tr><td>\b</td><td>匹配单词边界。</td></tr><tr><td>\B</td><td>匹配非单词边界。</td></tr><tr><td>\0</td><td>匹配 NULL 字符。</td></tr><tr><td>\n</td><td>匹配换行符。</td></tr><tr><td>\f</td><td>匹配换页符。</td></tr><tr><td>\r</td><td>匹配回车符。</td></tr><tr><td>\t</td><td>匹配制表符。</td></tr><tr><td>\v</td><td>匹配垂直制表符。</td></tr><tr><td>\xxx</td><td>匹配以八进制数 xxx 规定的字符。</td></tr><tr><td>\xdd</td><td>匹配以十六进制数 dd 规定的字符。</td></tr><tr><td>\uxxxx</td><td>匹配以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4><blockquote><p>方括号用于查找某个范围内的字符：</p></blockquote><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[^]</td><td>匹配任意任何字符。（可以匹配到<strong><em>换行符</em></strong>）</td></tr><tr><td>[abc]</td><td>匹配方括号之间的任何字符。</td></tr><tr><td>[^abc]</td><td>匹配任何不在方括号之间的字符。</td></tr><tr><td>[0-9]</td><td>匹配任何从 0 至 9 的数字。</td></tr><tr><td>[a-z]</td><td>匹配任何从小写 a 到小写 z 的字符。</td></tr><tr><td>[A-Z]</td><td>匹配任何从大写 A 到大写 Z 的字符。</td></tr><tr><td>[A-z]</td><td>匹配任何从大写 A 到小写 z 的字符。</td></tr><tr><td>(red|blue|green)</td><td>匹配任何指定的选项。</td></tr></tbody></table><h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>compile</td><td>编译正则表达式。</td></tr><tr><td>exec</td><td>检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td>test</td><td>检索字符串中指定的值。返回 true 或 false。</td></tr></tbody></table><h4 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>search</td><td>检索与正则表达式相匹配的值。。</td></tr><tr><td>match</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td>replace</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td>split</td><td>把字符串分割为字符串数组。</td></tr></tbody></table><h4 id="在多行文本中使用正则表达式"><a href="#在多行文本中使用正则表达式" class="headerlink" title="在多行文本中使用正则表达式"></a>在多行文本中使用正则表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">string.match(<span class="regexp">/yes.*day/</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">string.match(<span class="regexp">/yes[^]*day/</span>); <span class="comment">// &#x27;yes\nmake my day&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="先行断言和先行否定断言"><a href="#先行断言和先行否定断言" class="headerlink" title="先行断言和先行否定断言"></a>先行断言和先行否定断言</h4><blockquote><p>先行断言（lookahead）指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;100% of US presidents have been male&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?=%)/</span>.exec(string); <span class="comment">// [&#x27;100&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/have(?=%)/</span>.exec(string); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><blockquote><p>先行否定断言（negative lookahead）x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;that’s all 44 of them&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!%)/</span>.exec(string); <span class="comment">// [&#x27;44&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!.*of)/</span>.exec(string); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!.*all)/</span>.exec(string); <span class="comment">// [&#x27;44&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!.*of|.*all)/</span>.exec(string); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h4 id="后行断言和后行否定断言"><a href="#后行断言和后行否定断言" class="headerlink" title="后行断言和后行否定断言"></a>后行断言和后行否定断言</h4><blockquote><p>ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。<br>后行断言（lookbehind）指的是，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成 /(?&lt;=\$)\d+/。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Benjamin Franklin is on the $100 bill&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/(?&lt;=\$)\d+/</span>.exec(string);  <span class="comment">// [&quot;100&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>后行否定断言（negative lookbehind）指的是，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成 /(?&lt;!\$)\d+/。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;it’s is worth about €90&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/(?&lt;!\$)\d+/</span>.exec(string);  <span class="comment">// [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h4><blockquote><p>贪婪模式: 正则表达式一般趋向于最大长度匹配，总是尝试匹配尽可能多的字符。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(&lt;.*&gt;)/</span>;</span><br><span class="line"></span><br><span class="line">html.match(regexp); <span class="comment">// [&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>非贪婪模式: 非贪婪匹配就是匹配到结果就好，总是尝试匹配尽可能少的字符。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(&lt;.*?&gt;)/</span>;</span><br><span class="line"></span><br><span class="line">html.match(regexp); <span class="comment">// [&#x27;&lt;html&gt;&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>针对 6 种重复类惰性匹配的简单描述如下：</p><ul><li>{n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。</li><li>{n}?：尽量匹配 n 次。</li><li>{n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。</li><li>??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。</li><li>+?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。</li><li>*? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。</li></ul></blockquote><h4 id="捕获型分组和非捕获型分组"><a href="#捕获型分组和非捕获型分组" class="headerlink" title="捕获型分组和非捕获型分组"></a>捕获型分组和非捕获型分组</h4><blockquote><p>捕获型()：捕获型分组会把每个捕获分组所匹配的内容暂且存储在某个地方，以便下次使用。在JavaScript中，捕获性分组所匹配的内容都是以$1,$2,$3…的格式保存的。因此捕获型分组会有性能上的损失。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;sjds24324abcabc1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(abc)&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line">string.match(regexp); <span class="comment">// [&#x27;abcabc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>非捕获型(?:)：非捕获型分组只会返回一个不含各个分组匹配（不含字串）的结果。所以会提高匹配速度。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;sjds24324abcabc1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?:abc)&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line">string.match(regexp); <span class="comment">// [&#x27;abcabc&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="正则命名组捕获"><a href="#正则命名组捕获" class="headerlink" title="正则命名组捕获"></a>正则命名组捕获</h4><blockquote><p>正则命名组捕获使用符号 ?<name>表示，对匹配到的正则结果按名称访问。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。</name></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line">regexp.exec(<span class="string">&#x27;2023-01-01&#x27;</span>); <span class="comment">// &#123; year: &#x27;2023&#x27;, month: &#x27;01&#x27;, day: &#x27;01&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div></article></section><footer id="footer"><div class="footer-wrapper"><a href="/" class="footer-title">LiuZheng's Blog</a><p>Theme from by Lite</p></div><div class="frosted-glass"></div></footer></div></div></body></html>