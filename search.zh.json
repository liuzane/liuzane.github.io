[{"title":"醉酒帖子：我作为高级工程师学到的东西","url":"/zh/2025/11/01/drunk-post-things-ive-learned-as-a-sr-engineer.html","content":"","categories":["reprints"]},{"title":"Webpack 模块联邦","url":"/zh/2025/10/26/webpack-module-federation.html","content":"最近鼓捣了以下 Webpack 模块联邦，记录一下血泪历程。   什么是 Webpack 模块联邦(Module Federation)   Webpack 模块联邦(Module Federation)是 Webpack 5 新增的一个功能，它允许你将一个 Webpack 应用程序的模块分发给其他应用程序使用。   说人话就是   微前端系统有三个应用，可以共用一个 react/vue 版本，减少浏览器重复下载依赖包的问题。   模块联邦的工作原理   模块联邦分为两个部分：   主应用程序（Host Application）：负责加载其他应用程序的模块。   远程应用程序（Remote Application）：负责提供模块给主应用程序使用。   主应用在启动时，如果遇到了一个远程应用提供的模块，它会通过 js 加载该模块，加载完成后 Webpack 会判断该模块中的共享依赖包是否已加载：如果共享依赖包未加载，远程应用会先请求共享依赖包，加载完成后标记为已加载。如果共享依赖包已加载就不再请求共享依赖包。   流程图如下：   图看完了，把朕的代码呈上来。。。   Webpack 模块联邦配置说明   看到 Webpack 配置是不是就头疼，但是你先别头疼，因为更头疼的在后面呢。。。😏   // 模块联邦插件无需安装，Webpack 5 已经内置了该插件const { ModuleFederationPlugin } = require(&#39;webpack&#39;).container;module.exports = {  // ...  plugins: [    new ModuleFederationPlugin({      // 应用名称，用于在主应用中引用远程应用的模块时使用      name: &#39;{appName}&#39;,      // 远程应用的入口文件名称，用于其他应用加载该应用的模块      filename: &#39;remoteEntry.js&#39;,      // 主应用的配置，用于加载哪些远程应用的模块      remotes: {        // key 是在主应用中import的名称，value 是远程应用的入口文件地址        remote1: &#39;{appName}@http://localhost:{port}/{filename}.js&#39;,        // value 也可以是一段 promise 代码        remote2: `promise new Promise((resolve) =&gt; {          // 这里可以在运行时动态决定远程模块的入口文件地址          const remoteUrl = getRemoteUrlFromSomewhere(); // 你的自定义逻辑          const container = await import(/* webpackIgnore:false */ remoteUrl);          container.init(__webpack_share_scopes__.default); // 初始化共享作用域          resolve(container);        })`      },      // 远程应用的配置，用于暴露哪些模块给主应用使用，      // 远程应用至少暴露一个模块，不然无法暴露远程地址，      // 也就无法使用共享依赖功能了。      exposes: {        &#39;./remoteModule1&#39;: &#39;./src/remoteModule1.js&#39;,        &#39;./remoteModule2&#39;: &#39;./src/remoteModule2.js&#39;,      },      // 共享依赖配置，有三种声明方式：      // 1. 数组形式：版本从package.json中推断，没有版本检查，它将始终使用找到的较高版本      shared: [&#39;lodash&#39;],      // 2. 简单对象形式：版本从package.json中推断，它将使用最高的lodash版本，即&gt;= 4.17 and &lt; 5      shared: {        lodash: &#39;^4.17.0&#39;,      },      // 3. 详细对象形式：共享依赖可以配置更多的选项来控制共享的行为      shared: {        // 共享依赖库的名称        lodash: {          // 只允许该依赖在共享作用域中存在一个版本的共享依赖，默认值为 false。          // 对于全局依赖库（如 React、Vue 等），应该将 singleton 设置为 true，          // 以确保所有使用该依赖的应用程序都使用相同的实例。          singleton: boolean,          // 软件包所需的版本，默认值为 false。          // 设置 &#39;^2.0.0&#39; 要求远程应用程序使用的 lodash 版本必须&gt;= 2.0.0，&lt; 3.0.0。          requiredVersion: string | false,          // 在加载远程模块时，是否立即加载该共享依赖，默认值为 false。          // 如果设置为 true，webpack 会将共享依赖的包都打进应用的 bundle 中，          // 而不是在使用时才请求。          eager: boolean,          // 本地后备依赖加载，默认值为当前依赖库名称，即 &#39;lodash&#39;。          // 当设置为字符串（依赖库名称）时，Webpack 会尝试从共享作用域中加载该共享依赖，          // 如果在共享作用域内没有找到共享依赖或版本无效，Webpack 会回退到本地加载该共享依赖。          // 当设置为 false 时，Webpack 不会加载本地依赖，只从共享作用域中加载。          import: false | string,          // 严格版本检查，默认值为 true。          // 当本地后备依赖可用且共享依赖的 singleton 为 false 时，          // 则要求远程应用程序使用的 lodash 版本在共享作用域中必须匹配          strictVersion: boolean,          // 所提供依赖的版本，默认值为 false。          // 它允许 webpack 替换匹配的较低版本，但不能替换匹配的较高版本。          version: false | string,          // 共享作用域中共享依赖的键名，默认值为依赖库名称，即 &#39;lodash&#39;。          // 从共享作用域中根据此键名查找所请求的共享依赖，          // 可以设置为不同的键名，应用于各个应用相同依赖库的不同版本。          shareKey: string,          // 共享作用域的名称，默认值为 &#39;default&#39;。          // 主应用和远程应用可以配置不同的共享作用域名称，          // 以避免不同应用之间的共享依赖冲突。          shareScope: string,          // 依赖名称          packageName: string,        }      },    })  ],};   共享依赖配置必须在主应用和远程应用中都被声明才能使共享依赖功能生效。   无论是主应用还是远程应用配置了共享依赖不等于不用安装共享依赖包,    import    配置为    false    时除外（不建议）。   主应用和远程应用在请求共享依赖时，如果共享依赖不可用或者版本不匹配，会加载本地后备依赖。   主应用也可以是远程应用，通过暴露自身模块，其他应用可以加载主应用的模块。   Webpack 模块联邦配置官方文档   现在配置说明看完了，你应该知道所有的共享依赖配置选项了，让我们看看你学会了多少。😎   主应用程序配置   const { ModuleFederationPlugin } = require(&#39;webpack&#39;).container;module.exports = {  entry: &#39;./src/main.js&#39;,  // ...  plugins: [    new ModuleFederationPlugin({      name: &#39;host&#39;,      remotes: {        remote1: &#39;remote1@http://localhost:5001/remoteEntry.js&#39;,        remote2: &#39;remote2@http://localhost:5002/remoteEntry.js&#39;,      },      shared: {        lodash: {           singleton: true,          requiredVersion: &#39;2.0.0&#39;,        }      },    })  ],};import(&#39;./bootstrap&#39;);import _ from &#39;lodash&#39;;// some code...import(&#39;remote1/remoteModule&#39;).then(({ bootstrap, hello }) =&gt; {  bootstrap();  console.log(hello());});// some code...import(&#39;remote2/remoteModule&#39;).then(({ bootstrap, hello }) =&gt; {  bootstrap();  console.log(hello());});// some code...   看到这里你肯定会迷惑了，为什么根目录多了一个 bootstrap.js 文件？又为什么在 main.js 中引入了 bootstrap.js 文件？这不是脱裤子放屁-多此一举吗？答案还真不是，看看官网怎么说的：   应用程序正急切地执行一个作为全局主机运行的应用程序。我们强烈建议使用异步边界(asynchronous boundary)。它将把初始化代码分离成更大的块，以避免任何额外的开销，以提高总体性能。   点我查看   意思就是说，如果没有异步边界而又没有开启    eager: true   ，那么主应用会立即加载 lodash 这个共享依赖包，但是依赖包在    eager: false    时都是异步加载的，所以主应用就报共享依赖包不可用的错误。   远程应用程序配置   远程应用可以有多个，主应用中配置了两个地址，分别是 remote1 和 remote2，这里只展示 remote1 的配置，remote2 配置类似。   const { ModuleFederationPlugin } = require(&#39;webpack&#39;).container;module.exports = {  entry: &#39;./src/bootstrap.js&#39;,  // ...  plugins: [    new ModuleFederationPlugin({      name: &#39;remote1&#39;,      filename: &#39;remoteEntry.js&#39;,      exposes: {        &quot;./remoteModule&quot;: &quot;./src/exposes.js&quot;,      },      shared: {        lodash: {           singleton: true,          requiredVersion: &#39;2.0.0&#39;,        }      },    }),  ],};export function bootstrap() {  import(&#39;./bootstrap&#39;);}export function hello() {  return &#39;Hello Remote1&#39;;}import _ from &#39;lodash&#39;;// some code...   远程应用的配置与主应用有所不同：首先需要启动远程应用并对外暴露特定模块。随后，Webpack 模块联邦会生成该远程模块的访问地址。将该地址配置到主应用的模块联邦设置中并启动主应用后，当主应用执行类似    import(&#39;remote1/remoteModule&#39;)    的代码时，Webpack 模块联邦容器会通过该地址加载远程模块。同时，它会检查该远程模块所声明的共享依赖是否已在当前共享作用域中存在。如果依赖不可用，或版本不兼容，模块联邦将自动回退至加载主应用本地的后备依赖。   Demo 在线演示   Demo Github 代码   疑问和解答:   问   ：   主应用和远程应用都配置了共享依赖 lodash，但是主应用和远程应用的 lodash 版本不一致，会发生什么？   答   ：当版本不一致时，   requiredVersion   会根据共享作用域中的版本是否符合要求版本范围，如果不符合，会加载本地的后备依赖。   问   ：   singleton 配置项的作用是什么，版本协商机制又是怎么工作的？   答   ：singleton 用于指定是否将该共享依赖作为唯一版本在共享作用域中共享，如果设置为 true，共享作用域中只能存在一个版本。如果有多个不同的版本的共享依赖，Webpack 会使用版本协商机制（会尝试使用最高版本的共享依赖，即使配置了低版本的应用先加载也会使用最高版本的共享依赖），且会强制所有配置了   singleton: true   的应用使用该版本。以 lodash 为例：   /* App1 */// ...lodash: {  singleton: true, // 单例唯一版本  requiredVersion: &#39;^1.0.0&#39;, // 大于等于 1.0.0 小于 2.0.0}// .../* App2 */// ...lodash: {  singleton: true, // 单例唯一版本  requiredVersion: &#39;^2.0.0&#39;, // 大于等于 2.0.0 小于 3.0.0 }// .../* App3 */// ...lodash: {  singleton: false, // 非单例版本  requiredVersion: &#39;^3.0.0&#39;, // 大于等于 3.0.0 小于 4.0.0}// ...   App1 使用了单例唯一版本且 lodash 要求版本   大于等于    1.0.0    小于    2.0.0   App2 使用了单例唯一版本且 lodash 要求版本   大于等于    2.0.0    小于    3.0.0   App3 没有使用单例唯一版本且 lodash 要求版本   大于等于    3.0.0    小于    4.0.0   那么 App1 和 App2 无论哪个先加载都会使用 App2 配置的最高版本    2.0.0   ，App3 的 lodash 由于匹配不到可用的版本，又指定了    singleton    为    false   ，App3 的 lodash 将会使用本地回退版本    3.0.0   。   问   ：   远程应用只想使用共享依赖，也没有需要暴露自身模块的场景，所以只配置了   shared   ，没有配置   exposes   ，会发生什么？   答   ：远程应用的远程模块 URL 不会生成，主应用访问该远程模块 URL 将返回 404 错误，且模块联邦不会生效，永远只加载自身的后备依赖。   问   ：   主应用安装了 lodash 并配置了共享依赖，远程应用可以只配置共享依赖而不安装 npm 依赖包吗？   答   ：可以，但是不推荐。当主应用和远程应用都配置了 lodash 共享依赖，但是远程应用没有安装 npm 依赖包时，远程应用需要这样配置：   // ...lodash: {  import: false, // 不加载本地后备依赖，只从共享作用域中加载  singleton: true, // 单例唯一版本  requiredVersion: &#39;*&#39;, // 任何版本}// ...   但是不推荐这样做，因为当主应用的 lodash 版本因为网络或者其他原因导致 lodash 加载失败时，远程应用会报错，而不是使用本地后备依赖。   问   ：   在主应用配置中必须通过动态引入   import(&#39;{remotesKey}/{exposesKey}&#39;)   远程模块吗？可以通过其他方式引入吗？   答   ：必须这样引入，其他方式例如 HTML 引入也会报错。","categories":["guides"]},{"title":"数字序号批量重命名文件","url":"/zh/2025/10/25/batch-rename-files-with-digital-serial-numbers.html","content":"介绍   批量重命名文件，并在文件后面添加数字序号例如有以下文件结构：   图片文件夹|- 0asu78rec5k1.jpg|- 7ajzsdb1b32a.jpg|- ib1bls015hsh.jpg...   执行脚本之后，文件结构如下：   图片文件夹|- 图片_01.jpg|- 图片_02.jpg|- 图片_03.jpg...   该脚本排序只会按照字母顺序递增排序，不会考虑文件的创建时间或其他因素。如果希望按照创建时间排序，请先按照当前顺序批量重命名文件，再执行该脚本。   如何使用            ```bash    ./rename.sh ./图片文件夹 -p \"图片_\" -s 1 -z true    ```              ```cmd    .\\rename.cmd -d \".\\图片文件夹\" -p \"图片_\" -s 1 -z true    ```     参数   说明   默认值   -d   目标目录   当前目录   -p   前缀   空字符串   -s   起始序号   1   -z   是否补零   true   -h   显示帮助   无   源码            ```bash rename.sh    #!/bin/bash# 批量重命名指定文件夹下的所有文件，支持自定义前缀和序号起始值# 默认参数设置TARGET_DIR=&quot;.&quot;prefix=&quot;&quot;start_number=1pad_zero=true# 显示用法信息show_usage() {  echo &quot;用法: $0 [-d 目录路径] [-p 文件名前缀] [-s 序号起始值] [-z 是否补零(true/false)]&quot;  echo &quot;&quot;  echo &quot;选项:&quot;  echo &quot;  -d 目录路径    指定要处理的目录，默认为当前目录&quot;  echo &quot;  -p 文件名前缀  新文件名的前缀，默认为空&quot;  echo &quot;  -s 序号起始值  序号从哪个数字开始，默认为1&quot;  echo &quot;  -z true/false  序号小于10时是否补零，默认为true&quot;  echo &quot;  -h             显示此帮助信息&quot;  echo &quot;&quot;  echo &quot;示例:&quot;  echo &quot;  $0 -d /path/to/dir -p img_ -s 1 -z true&quot;  echo &quot;  $0 -d /path/to/dir -p photo_ -s 10 -z false&quot;}# 解析命令行参数while getopts &quot;d:p:s:z:h&quot; opt; do  case $opt in    d) TARGET_DIR=&quot;$OPTARG&quot; ;;    p) prefix=&quot;$OPTARG&quot; ;;    s) start_number=&quot;$OPTARG&quot; ;;    z)      if [ &quot;$OPTARG&quot; = &quot;false&quot; ]; then        pad_zero=false      else        pad_zero=true      fi      ;;    h) show_usage; exit 0 ;;    *) show_usage; exit 1 ;;  esacdone# 检查目录是否存在if [ ! -d &quot;$TARGET_DIR&quot; ]; then  echo &quot;错误：目录 &#39;$TARGET_DIR&#39; 不存在&quot;  exit 1fi# 进入目标目录cd &quot;$TARGET_DIR&quot; || exit 1echo &quot;开始重命名&#39;$TARGET_DIR&#39;目录下的文件...&quot;echo &quot;前缀: &#39;$prefix&#39;&quot;echo &quot;序号起始值: $start_number&quot;echo &quot;补零: $pad_zero&quot;echo &quot;&quot;# 获取所有文件并按照首字母从小到大排序，排除目录和当前脚本files=()script_name=&quot;$(basename &quot;$0&quot;)&quot;while IFS= read -r file; do  # 确保是文件而不是目录，且排除当前脚本  if [ -f &quot;$file&quot; ] &amp;&amp; [ &quot;$file&quot; != &quot;$script_name&quot; ]; then    files+=(&quot;$file&quot;)  fidone &lt; &lt;(ls -1 | grep -v &quot;^$script_name$&quot;)# 检查是否有文件需要重命名if [ ${#files[@]} -eq 0 ]; then  echo &quot;错误：目录 &#39;$TARGET_DIR&#39; 中没有可重命名的文件&quot;  exit 1fi# 文件序号从指定值开始count=$start_number# 遍历重命名文件for file in &quot;${files[@]}&quot;; do  # 获取文件后缀  extension=&quot;${file##*.}&quot;    # 根据是否补零设置格式化字符串  if [ &quot;$pad_zero&quot; = true ]; then    format=&quot;%02d&quot;  else    format=&quot;%d&quot;  fi    # 格式化数字  new_name=&quot;${prefix}$(printf &quot;$format&quot; &quot;$count&quot;)&quot;    # 如果文件有后缀，则保留  if [ &quot;$file&quot; != &quot;$extension&quot; ]; then      new_name=&quot;${new_name}.${extension}&quot;  fi    # 检查新文件名是否已存在  if [ -e &quot;$new_name&quot; ] &amp;&amp; [ &quot;$file&quot; != &quot;$new_name&quot; ]; then    echo &quot;警告：文件 &#39;$new_name&#39; 已存在，跳过重命名 &#39;$file&#39;&quot;    continue  fi    # 执行重命名  mv &quot;$file&quot; &quot;$new_name&quot;  echo &quot;重命名: &#39;$file&#39; -&gt; &#39;$new_name&#39;&quot;    count=$((count + 1))doneecho &quot;&quot;echo &quot;重命名完成，共处理 ${#files[@]} 个文件&quot;```              ```cmd rename.cmd    @echo off    chcp 65001 >nul    setlocal enabledelayedexpansionrem 批量重命名文件脚本 - 支持命令行参数rem 默认参数设置set &quot;TARGET_DIR=.&quot;set &quot;prefix=pic_&quot;set &quot;start_num=1&quot;set &quot;zero_pad=true&quot;rem 判断是否有命令行参数:has_argsif &quot;%~1&quot;==&quot;&quot; (  echo &quot;%~1&quot;  call :show_usage  exit 0)if &quot;%~1&quot;==&quot;-h&quot; (  call :show_usage  exit 0)rem 解析命令行参数:parse_argsif &quot;%~1&quot;==&quot;-d&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;TARGET_DIR=%~2&quot;    shift /1    shift /1    goto parse_args  ))if &quot;%~1&quot;==&quot;-p&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;prefix=%~2&quot;    shift /1    shift /1    goto parse_args  ))if &quot;%~1&quot;==&quot;-s&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;start_num=%~2&quot;    shift /1    shift /1    goto parse_args  ))if &quot;%~1&quot;==&quot;-z&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;zero_pad=%~2&quot;    shift /1    shift /1    goto parse_args  )):args_donerem 检查目录是否存在if not exist &quot;%TARGET_DIR%&quot; (  echo 错误：目录 &quot;%TARGET_DIR%&quot; 不存在  exit 1)rem 进入目标目录pushd &quot;%TARGET_DIR%&quot; || (  echo 错误：无法进入目录 &quot;%TARGET_DIR%&quot;  exit 1)echo 开始重命名&quot;%TARGET_DIR%&quot;目录下的文件...rem 使用临时文件存储文件名列表set &quot;TEMP_FILE=%TEMP%\\rename_files_list.txt&quot;rem 获取所有文件（不包括目录和当前脚本），按照首字母顺序排序dir /b /a-d | findstr /v /i &quot;%~nx0&quot; &gt; &quot;%TEMP_FILE%&quot;rem 检查是否有文件需要重命名if not exist &quot;%TEMP_FILE%&quot; (  echo 错误：无法创建临时文件  goto cleanup)for %%I in (&quot;%TEMP_FILE%&quot;) do (  if %%~zI equ 0 (    echo 错误：目录 &quot;%TARGET_DIR%&quot; 中没有可重命名的文件    goto cleanup  ))rem 使用起始序号作为计数器set &quot;count=%start_num%&quot;rem 遍历重命名文件for /f &quot;usebackq delims=&quot; %%F in (&quot;%TEMP_FILE%&quot;) do (  rem 获取文件后缀  set &quot;file=%%F&quot;  set &quot;extension=&quot;  for %%E in (&quot;%%F&quot;) do set &quot;extension=%%~xE&quot;    rem 格式化序号（根据是否需要补零）  if &quot;!zero_pad!&quot;==&quot;true&quot; (    rem 只对小于10的序号补零    if !count! lss 10 (      set &quot;formatted_count=0!count!&quot;    ) else (      set &quot;formatted_count=!count!&quot;    )  ) else (    set &quot;formatted_count=!count!&quot;  )    rem 构建新文件名  set &quot;new_name=!prefix!!formatted_count!&quot;    rem 如果文件有后缀，则保留  if not &quot;!extension!&quot;==&quot;&quot; (    set &quot;new_name=!new_name!!extension!&quot;  )    rem 检查新文件名是否已存在  if exist &quot;!new_name!&quot; if not &quot;!new_name!&quot;==&quot;!file!&quot; (    echo 警告：文件 &quot;!new_name!&quot; 已存在，跳过重命名 &quot;!file!&quot;    set /a &quot;count+=1&quot;    goto next_file  )    rem 执行重命名  ren &quot;!file!&quot; &quot;!new_name!&quot;  echo 重命名: &quot;!file!&quot; -^&gt; &quot;!new_name!&quot;    :next_file  rem 增加计数器  set /a &quot;count+=1&quot;):cleanuprem 清理临时文件if exist &quot;%TEMP_FILE%&quot; del &quot;%TEMP_FILE%&quot; 2&gt;nulrem 返回原目录popdecho 重命名完成exit 0rem 显示帮助信息函数:show_usageecho 用法: %~nx0 [选项]echo 选项:echo   -d 目录路径    指定要处理的目录 (默认: 当前目录)echo   -p 前缀        指定文件前缀 (默认: pic_)echo   -s 起始序号    指定起始序号 (默认: 1)echo   -z [true/false] 是否补零 (默认: true)echo   -h            显示此帮助信息exit 0```","categories":["scripts"]},{"title":"小东西3岁了","url":"/zh/2025/10/13/little-thing-turned-3.html","content":"","categories":["my-cat"]},{"title":"ESLint 自动格式化配置","url":"/zh/2025/09/05/eslint-automatic-formatting-configuration.html","content":"在项目开发过程中，面对风格混乱的代码令人十分困扰，而手动调整代码风格又非常耗时。因此，我们需要在编辑器保存时自动格式化代码的功能。本文旨在介绍如何配置项目的 ESLint，并设置编辑器以实现保存时自动格式化。   ESLint 配置   这里不详细介绍如何配置 ESLint，因为每个前端框架的 ESLint 插件不一样。   如何安装ESLint配置   VSCode 配置   首先去 VSCode 的插件市场下载 ESLint 插件。   如果项目的 ESLint 配置已经完成，安装完插件后重启 VSCode。重启后，打开 VSCode 底部控制台，切换到 Output 标签页，点击右侧的选择器，选择 ESLint。随后，你将在下方的控制台输出中看到相关的日志信息。   2025-09-05 09:12:31.749 [info] ESLint server is starting.2025-09-05 09:12:32.542 [info] ESLint server running in node v20.19.12025-09-05 09:12:32.546 [info] ESLint server is running.   这时 VSCode 已经读取到 ESLint 的配置并成功启动服务了。   接下来配置 VSCode ，在项目根目录创建一个 .vscode 文件夹（如果没有），创建 settings.json 和 extensions.json 这两个文件，settings.json 是编辑器的设置文件，extensions.json 是项目需要安装的插件列表。   {  // 启用 ESLint 格式化  &quot;eslint.format.enable&quot;: true,  // 启用对 JS, JSX, TS, TSX, Vue, HTML 文件的 ESLint 检查  &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;typescript&quot;, &quot;typescriptreact&quot;, &quot;vue&quot;, &quot;html&quot;],  // 关闭 VS Code 自带的保存时格式化（避免冲突）  &quot;editor.formatOnSave&quot;: false,  // 启用保存时自动修复 ESLint 可修复的问题  &quot;editor.codeActionsOnSave&quot;: {    &quot;source.fixAll.eslint&quot;: &quot;explicit&quot;  },  // 强制使用 ESLint 作为格式化工具  &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;,  // Vue 文件强制使用 ESLint 作为格式化工具  &quot;[vue]&quot;: {    &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;  },  // React TSX 文件强制使用 ESLint 作为格式化工具  &quot;[tsx]&quot;: {    &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;  },}{  &quot;recommendations&quot;: [    &quot;dbaeumer.vscode-eslint&quot; // ESLint 插件  ]}   以上配置设置完成后应该可以看到不符合 ESLint 规范的代码有红色波浪线，   此时保存文件会自动按照 ESLint 规则格式化代码，但是有部分代码不会自动格式化，需要手动调整   ，或者使用强力格式化插件 Prettier。   Prettier 配置","categories":["guides"]},{"title":"虾仁炒蛋","url":"/zh/2025/04/04/shrimp-omelet.html","content":"食材用料   食材   数量   虾仁   100克   鸡蛋   4个   葱   适量   盐   适量   油   适量   做法步骤   图片   步骤   1.    准备食材   2.    鸡蛋放入葱末，虾仁加水放入一勺盐腌制   3.    鸡蛋打散并放入虾仁（盐水也加入）   4.    放油冒烟放入鸡蛋炸成型后翻炒   5.    出锅   6.    装盘","categories":["cookbooks"]},{"title":"莴笋炒肉","url":"/zh/2025/04/04/stir-fried-meat-with-lettuce.html","content":"食材用料   食材   数量   莴笋   2根   猪肉   400克   蒜苗叶   2根   葱   适量   蒜   适量   干辣椒   适量   花椒   适量   八角   适量   盐   适量   生抽   适量   老抽   适量   耗油   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：葱、蒜、辣椒、花椒、八角   3.    莴笋对半切，然后切片   4.    蒜苗叶切片   5.    猪肉切片   6.    放油下猪肉、调料、老抽爆炒   7.    炒好的肉收起备用   8.    放油爆炒莴笋，然后放入肉翻炒   9.    放入耗油、生抽、盐翻炒   10.    放入蒜苗叶翻炒   11.    出锅   12.    装盘","categories":["cookbooks"]},{"title":"炒油麦菜","url":"/zh/2025/04/04/stir-fried-romaine.html","content":"食材用料   食材   数量   油麦菜   500克   青椒   2颗   油   适量   大蒜   适量   盐   适量   生抽   适量   耗油   适量   做法步骤   图片   步骤   1.    准备食材   2.    青椒切段和大蒜切末放一起   3.    放油爆炒青椒和大蒜   4.    放入油麦菜爆炒后放入耗油、生抽、盐再爆炒   5.    出锅   6.    装盘","categories":["cookbooks"]},{"title":"芹菜蒜苗炒牛肉","url":"/zh/2025/04/04/stir-fried-beef-with-celery.html","content":"食材用料   食材   数量   芹菜   250克   蒜苗   4根   卤牛肉   400克   油   适量   葱   适量   蒜   适量   辣椒   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：辣椒、花椒、葱、蒜   3.    青椒切段   4.    蒜苗叶切段   5.    蒜苗根从中间切两半，然后切段   6.    芹菜切段   7.    牛肉切片   8.    蒜苗根和芹菜放一起备用   9.    蒜苗叶和牛肉放一起备用   10.    放油炒蒜苗根和芹菜   11.    放入调料翻炒   12.    放入蒜苗叶和牛肉翻炒熟透   13.    放入生抽、老抽、盐翻炒   14.    出锅   15.    装盘","categories":["cookbooks"]},{"title":"香菇蒜苗炒肉","url":"/zh/2025/03/17/stir-fried-meat-with-mushrooms-and-garlic-sprouts.html","content":"食材用料   食材   数量   香菇   500克   蒜苗   4根   猪肉   500克   油   适量   葱   适量   蒜   适量   辣椒   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：花椒、辣椒、葱、蒜   3.    香菇切片   4.    蒜苗切段   5.    猪肉切丝   6.    香菇焯水备用   7.    放油下猪肉炒出香味，加入老抽上色   8.    肉撇到一边，放入调料炒香   9.    放入香菇翻炒   10.    放入蒜苗、盐、生抽翻炒均匀   11.    出锅   12.    装盘","categories":["cookbooks"]},{"title":"NPM 命令","url":"/zh/2024/11/01/npm-command.html","content":"NPM 命令   # 查询有哪些依赖库有更新npm outdated# 查询 xxx 依赖库的最新版本信息npm view xxx versions# 或者npm info xxx# 安装 xxx 1.0.0 版本的依赖库到 dependencies，@latest 表示安装最新版本npm install xxx@1.0.0 --save# 或者简写npm i xxx@1.0.0 -S# 升级 xxx 到最新版本的依赖库到 devDependenciesnpm update xxx --save-dev# 查看所有的依赖库列表树，包括依赖库的依赖库npm list# 只查看 package.json 下安装的依赖库列表，包括 devDependenciesnpm list --depth=0   使用 npm-check 查看哪些依赖库有更新   npm install -g npm-check  # 先全局安装 npm-checknpm-check -u              # 查询当前项目下的包更新npm-check -u -g           # 查询全局安装的包更新   npm-check -u   会列出所有的更新，上下键控制，空格选中或取消选中，选好了以后按回车就行了。   NPM 安装错误解决   postinstall error:   环境   版本   windows   10   node   20.14.0   pnpm   9.4.0   当第一次执行    pnpm install    或    npm install    时 PNPM报错：npm postinstall failed command not found node ./scripts/postinstall.js   解决方案1:   运行命令   rimraf .\\node_modules\\   npm cache clean --force   pnpm store prune   解决方案2:   找到报错的插件所在的 package.json 文件   把 package.json 中的 scripts.postinstall 的命令找个地方记录下来，并修改命令为    pnpm --version   然后执行一次    pnpm install    完成后将会发现报错的插件 postinstall 执行成功   挨个进入报错的插件所在的 package.json 文件层级   挨个执行该插件原有的 postinstall 命令   pnpm dev    启动成功。。。   node-pre-gyp error:   插件   版本   linux   13.6.0   node   18.20.4   npm   10.7.0   当第一次执行    npm install    时，有时会出现 npm error node-pre-gyp。   原因:   https://github.com/mozilla/pdf.js#user-content-getting-the-code   On MacOS M1/M2 you may see some node-gyp-related errors when running npm install. This is because one of our dependencies, &quot;canvas&quot;, does not provide pre-built binaries for this platform and instead npm will try to build it from source. Please make sure to first install the necessary native dependencies using brew:    https://github.com/Automattic/node-canvas#compiling   .   解决方案：   参考    https://github.com/Automattic/node-canvas#compiling    给的解决办法，给环境添加图片插件支持。   移除项目中所有与 canvas (项目名: node-canvas) 相关的插件。","categories":["notes"]},{"title":"Git 配置","url":"/zh/2024/01/25/git-configuration.html","content":"Git 获取配置命令   # 获取全局 + 本地 Git 配置git config --list# 获取全局 Git 配置git config --global --list   Git 配置   # 设置文件名大小写敏感git config --global core.ignorecase false# true: Git会忽略文件名大小写差异（例如在大小写不敏感的系统上，README.md和readme.md会被视为同一文件）# false: Git会区分文件名大小写# 设置换行符自动转换git config --global core.autocrlf false# true: 自动将CRLF转换为LF，或在检出时转换为CRLF# false: 不进行换行符转换# 设置混合换行符检查git config --global core.safecrlf true# warn(默认): 提交包含混合换行符的文件时发出警告# true: 拒绝提交包含混合换行符的文件（会显示Fatal错误）# false: 允许提交包含混合换行符的文件   Git 代理   # 检查 Git 的代理设置git config --global --get http.proxygit config --global --get https.proxy# 设置 Git 代理git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy http://127.0.0.1:7890# 移除 Git 代理git config --global --unset http.proxygit config --global --unset https.proxy   .gitattributes    文件配置   # 设置默认行为（适用于未设置core.autocrlf的情况）* text=auto# 声明需要标准化并在检出时转换为本地换行符的文本文件*.c text*.h text# 声明在检出时始终使用CRLF换行符的文件*.sln text eol=crlf# 声明真正的二进制文件（不应被修改）*.png binary   Gvim 配置   打开_vimrc文件，添加以下配置：   # 设置显示^M和$符号:set encoding=utf-8:scriptencoding utf-8:set binary:set list:set listchars=tab:&gt;-,eol:$,space:·","categories":["notes"]},{"title":"常用系统命令","url":"/zh/2023/11/23/common-system-commands.html","content":"删除文件和目录            ```bash    # 强制递归删除 node_modules 目录    rm -rf ./node_modules# 删除文件rm filename.txt# 递归删除目录。-r 递归删除，用于删除目录及其内容rm -r folder_name# 强制删除文件。-f 强制删除，不提示确认rm -f filename.txt# 安全删除（交互式确认）。-i：在删除每个文件前提示确认rm -i filename.txtrm -ri folder_name```              ```powershell    # 强制递归删除 node_modules 目录    rm -r -Force .\\node_modules# 删除文件Remove-Item filename.txt# 别名rm 或 rd# 删除文件夹rm -r folder_name# 强制递归删除文件和目录。 -Recurse 或 -r 递归删除，-Force 强制删除，不提示确认rm -Recurse -Force -Path folder_name# 安全删除（带确认）。-Confirm 在删除文件前提示确认rm important_file.txt -Confirm# 从当前文件夹中删除具有 .txt 文件扩展名和不包含 important 的名称的所有文件。rm * -Include *.txt -Exclude *important*```              ```cmd    REM 强制递归删除 node_modules 目录    rd /s /q .\\node_modulesREM 删除文件del filename.txtREM 删除目录rd folder_nameREM 递归删除文件夹。 /s 递归删除目录及其内容rd /s .\\folder_nameREM 递归删除目录树，不确认。 /q 安静模式rd /s /q .\\folder_name```     查看文件和文件夹            ```bash    # 基本命令    ls# 查看详细列表。参数组合（-l 列表显示，-a 显示隐藏文件）ls -la# 查看文件大小详细列表（需要配合 -l 使用）ls -lh# 按时间排序。-t 表示按时间排序，-r 表示反向排序（最新的在最后）ls -ltr# 按文件大小排序。-S 表示按文件大小排序，-r 表示反向排序（最大的在最后）ls -lSr# 递归显示所有子目录ls -R```              ```powershell    # 基本命令    Get-ChildItem# 别名ls 或 dir# 格式化输出ls | Format-Table Name, Length, LastWriteTime# 显示隐藏文件ls -Force# 递归显示所有子目录 -Recurse 或 -rls -r# 按扩展名过滤ls *.txt 或 ls -Filter *.txt```              ```cmd    REM 基本命令    dirREM 显示所有文件，包括隐藏文件和系统文件。dir /aREM 按时间排序。/o 按时间排序，d 按日期时间，/r 表示反向排序（最新的在最后）dir /od /rREM 按大小排序。/o 按大小排序，s 按文件大小，/r 表示反向排序（最大的在最后）dir /os /rREM 递归显示所有子目录，包括隐藏目录。dir /s```     查看本地 IP 地址            ```bash    # 显示所有接口的详细信息    ip addr show# 只显示 IPv4 地址hostname -I```              ```powershell    # 这个命令会列出所有 IPv4 地址，并排除本地回环地址 (127.0.0.1)，同时显示对应的网络连接名称。    Get-NetIPAddress | Where-Object {$_.AddressFamily -eq 'IPv4' -and $_.IPAddress -ne '127.0.0.1'} | Format-Table InterfaceAlias, IPAddress    # 兼容 CMD，快速查看ipconfig```              ```cmd    REM 经典命令，显示基本信息    ipconfigREM 显示所有详细信息ipconfig /allREM 只显示 IPv4 地址ipconfig | findstr /i &quot;IPv4&quot;```     查找端口占用并删除进程            ```bash    # 查找占用端口 8080 的进程    lsof -i :8080    # 结束进程kill -9 &lt;进程ID&gt;# fuser 命令结束进程。-k 结束进程，-i 在终止进程之前询问用户确认， -u 显示进程所有者。fuser -ki -u 8080/tcp```              ```powershell    # 查找占用端口 8080 的进程    Get-Process -Id (Get-NetTCPConnection -LocalPort 8080).OwningProcess# 结束进程Stop-Process -Id (Get-NetTCPConnection -LocalPort 8080).OwningProcess```              ```cmd    REM 查找占用端口 8080 的进程    netstat -ano | findstr 8080REM 结束进程taskkill /F /PID &lt;进程ID&gt;```","categories":["notes"]},{"title":"运维的未来是平台工程","url":"/zh/2023/07/19/platform-engineering.html","content":"","categories":["reprints"]},{"title":"软件吃软件，编程工作会越来越多吗？","url":"/zh/2023/07/07/will-programmers-increase.html","content":"","categories":["reprints"]},{"title":"大盘鸡","url":"/zh/2022/08/16/big-plate-chicken.html","content":"食材用料   食材   数量   鸡   一只   土豆   两个   青椒   两个   油   适量   白糖   适量   葱   适量   姜   适量   蒜   适量   辣椒   适量   花椒   适量   八角   适量   香叶   适量   桂皮   适量   盐   适量   生抽   适量   老抽   适量   辣椒油   适量   料酒   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜、姜、蒜、辣椒、花椒、八角、香叶、桂皮   3.    鸡块焯水，放入姜片、料酒   4.    土豆切滚刀块   5.    鸡块去除浮沫后捞出   6.    放油大火，放入白糖或者冰糖炒化   7.    放入鸡块翻炒，炒出香味   8.    放入调料翻炒   9.    放入盐、生抽、老抽、辣椒油、料酒翻炒均匀   10.    放入土豆翻炒，然后加入水没过土豆，盖上锅盖   11.    煮到一半放入青椒，大火收汁   12.    装盘","categories":["cookbooks"]},{"title":"语言标签","url":"/zh/2022/04/10/language-tags.html","content":"语言标签   ISO 639-1   语言   地区   描述   ar-SA   ar   Arabic   Saudi Arabia   阿拉伯语（沙特阿拉伯）   bn-BD   bn   Bangla   Bangladesh   孟加拉语（孟加拉国）   bn-IN   bn   Bangla   India   孟加拉语（印度）   cs-CZ   cs   Czech   Czech Republic   捷克语（捷克共和国）   da-DK   da   Danish   Denmark   丹麦语（丹麦）   de-AT   de   German   Austria   奥地利德语   de-CH   de   German   Switzerland   瑞士德语   de-DE   de   German   Germany   标准德语（德国使用）   el-GR   el   Greek   Greece   现代希腊语   en-AU   en   English   Australia   澳大利亚英语   en-CA   en   English   Canada   加拿大英语   en-GB   en   English   United Kingdom   英国英语   en-IE   en   English   Ireland   爱尔兰英语   en-IN   en   English   India   印度英语   en-NZ   en   English   New Zealand   新西兰英语   en-US   en   English   United States   美国英语   en-ZA   en   English   South Africa   英语（南非）   es-AR   es   Spanish   Argentina   阿根廷西班牙语   es-CL   es   Spanish   Chile   智利西班牙语   es-CO   es   Spanish   Columbia   哥伦比亚西班牙语   es-ES   es   Spanish   Spain   卡斯蒂利亚西班牙语（西班牙中北部使用）   es-MX   es   Spanish   Mexico   墨西哥西班牙语   es-US   es   Spanish   United States   美国西班牙语   fi-FI   fi   Finnish   Finland   芬兰语（芬兰）   fr-BE   fr   French   Belgium   比利时法语   fr-CA   fr   French   Canada   加拿大法语   fr-CH   fr   French   Switzerland   瑞士法语   fr-FR   fr   French   France   标准法语（法国使用）   he-IL   he   Hebrew   Israel   希伯来语（以色列）   hi-IN   hi   Hindi   India   印地语（印度）   hu-HU   hu   Hungarian   Hungary   匈牙利语（匈牙利）   id-ID   id   Indonesian   Indonesia   印尼语（印度尼西亚）   it-CH   it   Italian   Switzerland   瑞士意大利语   it-IT   it   Italian   Italy   标准意大利语（意大利使用）   ja-JP   ja   Japanese   Japan   日语（日本）   ko-KR   ko   Korean   Republic of Korea   韩语（韩国）   nl-BE   nl   Dutch   Belgium   比利时荷兰语   nl-NL   nl   Dutch   The Netherlands   标准荷兰语（荷兰使用）   no-NO   no   Norwegian   Norway   挪威语（挪威）   pl-PL   pl   Polish   Poland   波兰语（波兰）   pt-BR   pt   Portuguese   Brazil   巴西葡萄牙语   pt-PT   pt   Portuguese   Portugal   欧洲葡萄牙语（葡萄牙书面和口语）   ro-RO   ro   Romanian   Romania   罗马尼亚语（罗马尼亚）   ru-RU   ru   Russian   Russian Federation   俄语（俄罗斯联邦）   sk-SK   sk   Slovak   Slovakia   斯洛伐克语（斯洛伐克）   sv-SE   sv   Swedish   Sweden   瑞典语（瑞典）   ta-IN   ta   Tamil   India   印度泰米尔语   ta-LK   ta   Tamil   Sri Lanka   斯里兰卡泰米尔语   th-TH   th   Thai   Thailand   泰语（泰国）   tr-TR   tr   Turkish   Turkey   土耳其语（土耳其）   zh-CN   zh   Chinese   China   中国大陆简体中文   zh-HK   zh   Chinese   Hong Kong   香港繁体中文   zh-TW   zh   Chinese   Taiwan   台湾繁体中文","categories":["notes"]},{"title":"香菇炖羊排","url":"/zh/2021/10/19/stewed-lamb-chop-with-mushroom.html","content":"食材用料   食材   数量   羊排   6个   香菇   300克   油   多量   盐   适量   辣椒   适量   花椒   适量   八角   适量   孜然   适量   羊排必须焯水去血沫，不然腥味重。   做法步骤   图片   步骤   1.    准备食材   2.    调料盘：辣椒、花椒、八角、孜然   3.    羊排加水放血   4.    温水焯水捞出   5.    放入调料中火翻炒羊排   6.    加水，放入切好的香菇，放入盐   7.    中火炖煮30分钟   8.    装盘","categories":["cookbooks"]},{"title":"青椒炒肉","url":"/zh/2021/09/05/green-pepper-parch-meat.html","content":"食材用料   食材   数量   青椒   300克   猪肉   120克   油   适量   蒜   适量   盐   适量   生抽   适量   老抽   少量   料酒   适量   肉嫩青椒好吃关键：不能大火，全程中火。   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜、辣椒   3.    青椒切成丝   4.    肉切丝，捏掉水，放入淀粉、生抽、料酒   5.    搅拌成粘稠状腌一下   6.    放油中火，放调料爆香   7.    放肉丝炒熟   8.    放入青椒翻炒均匀   9.    放入盐、老抽翻炒   10.    收锅   11.    装盘","categories":["cookbooks"]},{"title":"番茄香肠炒鸡蛋","url":"/zh/2021/06/14/scrambled-egg-with-tomato-sausage.html","content":"食材用料   食材   数量   番茄   250克   鸡蛋   两个   香肠   60克   油   适量   干辣椒   适量   盐   适量   冰糖   适量   做法步骤   图片   步骤   1.    准备食材   2.    番茄底部切掉，为了煮开的时候更好裂皮   3.    开水煮到番茄表面裂皮   4.    番茄剥皮   5.    番茄切成小块   6.    打入鸡蛋、葱花搅拌   7.    香肠切片和辣椒装在一起   8.    热锅热油，油冒烟放入鸡蛋液   9.    放入香肠辣椒翻炒均匀   10.    放入番茄块翻炒均匀，放入盐（番茄块用锅铲摁烂）   11.    收锅   12.    装盘","categories":["cookbooks"]},{"title":"JavaScript 注释规范","url":"/zh/2021/04/28/javascript-document-convertions.html","content":"Type 语法   类型名   语法示例   描述   Symbol name   {string}, {myNamespace.MyClass}   指定符号的名称。   Multiple types   {number|boolean}   这意味着值可能是几种类型中的一种，用&quot;|&quot;分隔类型的完整列表。   Arrays   {string[]}, {MyClass[]}   表达式   string[]   表示字符串数组，    表达式   {MyClass[]}   标识具有MyClass实例的数组   Objects   {a: number, b: string, c}     // or     {object} myObj     {number} myObj.a     {string} myObj.b     {any} myObj.c   对象“MyObj”中具有属性 &#39;a&#39; (一个数字) &#39;b&#39; (一个字符串) 和 &#39;c&#39; (任何类型)，    对于具有一组已知的属性的对象，    你可以使用 Closure Compiler 语法文档化标注的类型。    你也可以分别描述每个属性，    这使你能够提供有关每个属性的更多详细信息。   Nullable type   {?number}   指明类型为指定的类型，或者为null。   Non-nullable type   {!number}   指明类型为指定的类型，但是绝对不会是null。   Variable number of that type   @param {...number} num   表示该函数接受可变数量的参数，并指定一个类型的参数。   Optional parameter   @param {number} [foo=1]   指示参数是可选的, 你还可以指明参数的默认值。   Callbacks   @callback myCallback     @param {number} x - ...   使用@callback标签指明一个回调。    和@typedef标签是相同的，    不同之处在于回调的类型始终是&quot;function&quot;。   Type definitions   @typedef {object} PropertiesHash     @property {string} id     @property {string} name     @property {number} age   你可以使用@typedef标签记录复杂类型。   常用注释关键字   注释名   别名   描述   @param   @argument, @arg   记录传递给一个函数的参数。   @return   @returns   记录一个函数的返回值。   @method   @function, @func   描述一个函数或方法。   @typedef   记录一个自定义的类型。   @property   @prop   记录一个对象的属性。   @callback   描述一个回调函数。   @author   指定项目的作者。   @copyright   描述一个文件的版权信息。   @description   描述一个标识。   @param   记录传递给一个函数的参数。   别名： @arg，@argument   /** * @param {string} somebody - Somebody&#39;s name. */function sayHello(somebody) {  alert(&#39;Hello &#39; + somebody);}   如果参数是一个对象，有特定的属性：   /** * Assign the project to an employee. * @param {object} employee            - The employee who is responsible for the project. * @param {string} employee.name       - The name of the employee. * @param {string} employee.department - The employee&#39;s department. */Project.prototype.assign = function(employee) { ... };   如果参数的属性值在数组中：   /** * Assign the project to a list of employees. * @param {object[]} employees            - The employees who are responsible for the project. * @param {string} employees[].name       - The name of an employee. * @param {string} employees[].department - The employee&#39;s department. */Project.prototype.assign = function(employees) { ... };   一个可选参数和默认值：   /** * @param {string} [somebody=John Doe] - Somebody&#39;s name. */function sayHello(somebody) {  if (!somebody) {    somebody = &#39;John Doe&#39;;  }  alert(&#39;Hello &#39; + somebody);}   允许一个类型或另一个类型：   /** * @param {string|string[]} [somebody=John Doe] - Somebody&#39;s name, or an array of names. */function sayHello(somebody) {  if (!somebody) {    somebody = &#39;John Doe&#39;;  } else if (Array.isArray(somebody)) {    somebody = somebody.join(&#39;, &#39;);  }  alert(&#39;Hello &#39; + somebody);}   参数接受一个回调函数：   /** * @param {requestCallback} cb *//** * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage */function doSomethingAsynchronously(cb) { ... }   @return   记录一个函数的返回值。   别名： @returns   /** * Returns the sum of a and b * @param {number} a * @param {number} b * @param {boolean} retArr If set to true, the function will return an array * @return {number|array} Sum of a and b or an array that contains a, b and the sum of a and b. */function sum(a, b, retArr) {  if (retArr) {    return [a, b, a + b];  }  return a + b;}   @method   描述一个函数或方法。   别名： @function, @func   /** * Returns the sum of a and b * @method sum * @param {number} a * @param {number} b * @return {number} Sum of a and b or an array that contains a, b and the sum of a and b. */function sum(a, b) {  return a + b;}   @typedef   记录一个自定义的类型。   /** * The complete Triforce, or one or more components of the Triforce. * @typedef {Object} WishGranter~Triforce * @property {boolean} hasCourage - Indicates whether the Courage component is present. * @property {boolean} hasPower   - Indicates whether the Power component is present. * @property {boolean} hasWisdom  - Indicates whether the Wisdom component is present. */ /** * A class for granting wishes, powered by the Triforce. * @class * @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects * containing all three components of the Triforce. */function WishGranter() {}   @property   记录一个对象的属性。   /** * @namespace * @property {object}  defaults               - The default values for parties. * @property {number}  defaults.players       - The default number of players. * @property {string}  defaults.level         - The default level for the party. * @property {object}  defaults.treasure      - The default treasure. * @property {number}  defaults.treasure.gold - How much gold the party starts with. */var config = {  defaults: {    players: 1,    level: &#39;beginner&#39;,    treasure: {      gold: 0    }  }};   @callback   描述一个回调函数。   /** * @class */function Requester() {}/** * Send a request. * @param {Requester~requestCallback} cb - The callback that handles the response. */Requester.prototype.send = function(cb) {  // code};/** * This callback is displayed as part of the Requester class. * @callback Requester~requestCallback * @param {number} responseCode * @param {string} responseMessage */   @author   指定项目的作者。   /** * @author Zane Liu &lt;liuzane@example.com&gt; */function MyClass() {}   @copyright   描述一些版权信息。   /** * @file This is my cool script. * @copyright Zane Liu 2021 */   @description   描述一个标识。   /** * @param {number} a * @param {number} b * @returns {number} * @description Add two numbers. */function add(a, b) {  return a + b;}","categories":["notes"]},{"title":"香辣虾","url":"/zh/2020/12/27/fried-shrimp-with-chilli.html","content":"食材用料   食材   数量   基围虾   10个   油   适量   葱   适量   蒜   适量   姜   适量   辣椒   适量   香叶   适量   盐   适量   清水   半碗   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    葱切段，姜切撕，蒜切末装盘   3.    调料汁：清水、生抽、盐、香叶   4.    虾洗净，挑去虾线   5.    热锅热油，下虾，煎至两面成漂亮的红色出虾油后，盛出虾（用锅铲轻轻压一压虾，红油出的多）   6.    把葱和姜放入虾油锅中爆香   7.    放入煎好的虾，倒入调料汁   8.    大火收汁   9.    装盘","categories":["cookbooks"]},{"title":"localStorage","url":"/zh/2020/12/10/local-storage.html","content":"setStorage(key, data, hours)   设置localStorage   /*** @method setStorage* @param {string} key* @param {any} data* @param {number} hours* @return {boolean}*/function setStorage(key, data, hours) {  let expires;  if (!key || !data) {    console.error(&#39;[localStorage Error]: Key and Data is a must parameter&#39;);    return false;  }  expires = hours ? new Date().getTime() + 1000 * 60 * 60 * hours : new Date(0).getTime();  localStorage.setItem(key, JSON.stringify({ data, expires }));  return true;}   getStorage(key)   获取localStorage   /*** @method getStorage* @param {string} key* @return {boolean|null}*/function getStorage(key) {  let data, nowTime = new Date().getTime();  if (!key) console.error(&#39;[localStorage Error]: Key is a must parameter&#39;);  try {    data = JSON.parse(localStorage.getItem(key));  } catch (error) {    return localStorage.getItem(key);  }  if (!data) return null;  if (!Boolean(data.expires) || data.expires &gt;= nowTime) {    return data.data;  } else {    localStorage.removeItem(key);    return null;  }}   clearStorage(key)   清除localStorage   /*** @method clearStorage* @param {string} key*/function clearStorage(key) {  if (key) {    localStorage.removeItem(key);  } else {    localStorage.clear();  }}","categories":["notes"]},{"title":"Cookies","url":"/zh/2020/12/10/cookies.html","content":"setCookie(params)   设置Cookie   /*** @method setCookie* @param {object} options* @param {string} options.key* @param {string} options.value* @param {number} [options.hours]* @param {string} [options.path]   - path: &#39;/&#39;* @param {string} [options.domain] - domain: document.domain*/function setCookie(options) {  let time = new Date(), expires = &#39;&#39;, path = &#39;&#39;, domain = &#39;&#39;;  if (!options.key || !options.value) {    console.error(&#39;[Cookie Error]: key, value must be set.&#39;);    return;  }  if (options.hours) {    try {      Number(options.hours);    } catch (e) {      console.error(&#39;[Cookie Error]: expires must is number.&#39;);    }    time.toGMTString(time.setTime(time.getTime() + 1000 * 60 * 60 * options.hours));    expires = &#39;expires=&#39; + time + &#39;;&#39;;  }  if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;  if (options.domain) domain = &#39;domain=&#39; + options.domain;  document.cookie = options.key + &#39;=&#39; + options.value + &#39;;&#39; + expires + path + domain;}   getCookie(key)   获取Cookie   /*** @method getCookie* @param {string} key * @return {undefined|string|null}*/function getCookie(key) {  if (!key) {    console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);    return;  }  const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;);  const result = document.cookie.match(regexp);  const value = result ? result[0].replace(/[; ]/g, &#39;&#39;).split(&#39;=&#39;)[1] : null;  return value;}   deleteCookie(param)   /*** @method deleteCookie* @param {string|object} param* @param {string} param.key* @param {string} [param.path]* @param {string} [param.domain]* @return {undefined|string|null}*/function deleteCookie(param) {  const options = typeof param === &#39;object&#39; ? param : {};  const key = typeof param === &#39;string&#39; ? param : options.key;  if (!key) {    console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);    return;  }  if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;  if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;  const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;);  const result = document.cookie.match(regexp);  const item = result ? result[0].replace(/[; ]/g, &#39;&#39;) : &#39;&#39;;  const time = new Date();  time.toGMTString(time.setTime(0));  document.cookie = item + &#39;;expires=&#39; + time + &#39;;&#39; + options.path + options.domain;}   clearCookie(params)   清除Cookie   /*** @method clearCookie* @param {object} [options]* @param {string} [options.path]* @param {string} [options.domain]*/function clearCookie(options) {  let arr = document.cookie.split(&#39;;&#39;), path = &#39;&#39;, domain = &#39;&#39;;  if (!options) options = {};  if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;  if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;  for (let i = 0; i &lt; arr.length; i++) {    let key = arr[i].substring(0, arr[i].indexOf(&#39;=&#39;));    document.cookie = key + &#39;=0;expires=Thu, 01 Jan 1970 00:00:00 GMT;&#39; + path + domain;  }}","categories":["notes"]},{"title":"JavaScript Utility Functions","url":"/zh/2020/12/10/javascript-utility-functions.html","content":"方法集合：   方法名称   描述   typeOf   验证数据类型。   deepCopy   深拷贝。   uuid   生成 UUID。   download   下载。   getUrlArg   根据名称获取路径参数。   getUrlQuery   将路径参数转化为对象格式。   setUrlQuery   将对象格式转化为路径参数。   getDeepValueOfObject   获取对象深层值。   toThousands   转化为千位分隔符格式。   typeOf(anything)   验证数据类型。   返回值均为字符串   enum TypeValue {  Boolean = &#39;boolean&#39;,  Number = &#39;number&#39;,  String = &#39;string&#39;,  Function = &#39;function&#39;,  Array = &#39;array&#39;,  Date = &#39;date&#39;,  RegExp = &#39;regexp&#39;,  Undefined = &#39;undefined&#39;,  Null = &#39;null&#39;,  Object = &#39;object&#39;}const TypeMap: Record&lt;string, TypeValue&gt; = {  &#39;[object Boolean]&#39;: TypeValue.Boolean,   &#39;[object Number]&#39;: TypeValue.Number,  &#39;[object String]&#39;: TypeValue.String,  &#39;[object Function]&#39;: TypeValue.Function,  &#39;[object Array]&#39;: TypeValue.Array,  &#39;[object Date]&#39;: TypeValue.Date,  &#39;[object RegExp]&#39;: TypeValue.RegExp,  &#39;[object Undefined]&#39;: TypeValue.Undefined,  &#39;[object Null]&#39;: TypeValue.Null,  &#39;[object Object]&#39;: TypeValue.Object};/** * Validate data type. * @method typeOf * @param {any} obj * @return {string} */export function typeOf(obj: unknown): TypeValue {  const toString = Object.prototype.toString;  return TypeMap[toString.call(obj)];}console.log(typeOf(&#39;abc&#39;)); // stringconsole.log(typeOf([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])); // arrayconsole.log(typeOf({ a: 1, b: 2, c: 3 })); // object   deepCopy(data)   深拷贝。   该方法需要结合    typeOf()    方法一起使用   /** * Data deep copy. * @method deepCopy * @param {array|object} data * @return {array|object} */export function deepCopy&lt;T&gt;(data: T): T {  const type: TypeValue = typeOf(data);  switch (type) {    case TypeValue.Array: {      const array: unknown[] = [];      for (let index = 0; index &lt; (data as unknown[]).length; index++) {        array.push(deepCopy(data[index]));      }      return array as T;    }    case TypeValue.Object: {      const object: Record&lt;string, unknown&gt; = {};      for (const key in data) {        if (Object.prototype.hasOwnProperty.call(data, key)) {          object[key] = deepCopy(data[key]);        }      }      return object as T;    }    default:      return data;  }}const obj1 = { a: 1, b: 2, c: 3 };const obj2 = deepCopy(obj1);console.log(obj1 === obj2); // false   formatDate(date, format)   日期格式化。   /** * Time and date formatting. * @method formatDate * @param {string|date} time * @return {string} */export function formatDate(time: string | Date, format = &#39;yyyy-MM-dd hh:mm:ss&#39;): string {  const date: Date = time ? new Date(time) : new Date();  const dateValues: Record&lt;string, number&gt; = {    &#39;M+&#39;: date.getMonth() + 1, // 月    &#39;d+&#39;: date.getDate(), // 日    &#39;h+&#39;: date.getHours(), // 时    &#39;m+&#39;: date.getMinutes(), // 分    &#39;s+&#39;: date.getSeconds(), // 秒    &#39;q+&#39;: Math.floor((date.getMonth() + 3) / 3), // 季度    &#39;S&#39;: date.getMilliseconds() // 毫秒  };  if (/(y{4})/.test(format)) {    format = format.replace(RegExp.$1, (date.getFullYear() + &#39;&#39;).substr(4 - RegExp.$1.length));  }  for (const key in dateValues) {    if (new RegExp(&#39;(&#39; + key + &#39;)&#39;).test(format)) {      const value = dateValues[key].toString();      format = format.replace(RegExp.$1, (RegExp.$1.length === 1) ? value : (&#39;00&#39; + value).substr(value.length));    }  }  return format;}console.log(formatDate(&#39;2024-05-01&#39;)); // &#39;2024-05-01 00:00:00&#39;console.log(formatDate(&#39;2024-05-01&#39;, &#39;yyyy-MM-dd&#39;)); // &#39;2024-05-01&#39;   uuid()   生成 UUID。   /** * @method uuid * @return {string} */function uuid() {  return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) {    const r = Math.random() * 16 | 0;    const v = c === &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);    return v.toString(16);  });}console.log(uuid()); // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   download(url, name)   下载。   /** * @method download * @param {string} url * @param {string} name */function download(url, name) {  const aDom = document.createElement(&#39;a&#39;);  aDom.download = name;  aDom.href = url;  document.body.appendChild(aDom);  aDom.click();  aDom.remove();}console.log(download(&#39;word.docx&#39;, &#39;https://www.test.com/word.docx&#39;)); // word.docx   getUrlArg(name)   根据名称获取路径参数。   /** * @method getUrlArg * @param {string} name * @return {string} */function getUrlArg(name) {  const search = window.location.search;  const regexp = new RegExp(`(^|&amp;)${name}=([^&amp;]*)(&amp;|$)`);  const arg = search.substr(1).match(regexp);  return arg ? arg[2] : &#39;&#39;;}   getUrlQuery(url)   将路径参数转化为对象格式。   /** * @method getUrlQuery * @param {string} url * @return {object} */function getUrlQuery(url) {  const query = url.substring(url.indexOf(&#39;?&#39;) + 1).split(&#39;&amp;&#39;);  const params = {};  query.forEach(item =&gt; {    const key_value = item.split(&#39;=&#39;);    params[key_value[0]] = key_value[1];  });  return params;}const url = &#39;https://www.test.com/query?a=1&amp;b=2&amp;c=3&#39;;console.log(getUrlQuery(url)); // { a: 1, b: 2, c: 3 }   setUrlQuery(url)   将对象格式转化为路径参数。   /** * @method setUrlQuery * @param {object} params * @return {string} */function setUrlQuery(params) {  const querys = [];  for (const key in params) {    if (params.hasOwnProperty(key)) {      querys.push(key + &#39;=&#39; + params[key]);    }  }  return querys.join(&#39;&amp;&#39;);}const params = { a: 1, b: 2, c: 3 };console.log(setUrlQuery(params)); // &#39;a=1&amp;b=2&amp;c=3&#39;   getDeepValueOfObject(object, keyPath, defaultValue)   获取对象深层值。   /** * @method getDeepValueOfObject * @param {object|array} object * @param {string} keyPath * @param {any} [defaultValue] * @return {any} */function getDeepValueOfObject(object, keyPath, defaultValue) {  const isString = typeof keyPath === &#39;string&#39;;  if (!isString) {    console.warn(&#39;[getDeepValueOfObject warn]: keyPath is not a string, type &#39; + typeof keyPath);  }    if (object &amp;&amp; keyPath &amp;&amp; isString) {    const keys = keyPath.split(&#39;.&#39;);    let value = object;    for (let index = 0; index &lt; keys.length; index++) {      const key = keys[index];      if (value[key] !== undefined) {        value = value[key];      } else {        value = defaultValue;      }    }    return value;  } else {    return defaultValue;  }}const obj = {  foo: {    number: 3  },  bar: 2,};const arr = [ obj ];console.log(getDeepValueOfObject(obj, &#39;foo.number&#39;)); // 3console.log(getDeepValueOfObject(obj, &#39;bar.number&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;bar.number&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(obj, &#39;&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(arr, 0)); // undefinedconsole.log(getDeepValueOfObject(arr, &#39;0.foo.number&#39;)); // 3   toThousands(number)   转化为千位分隔符格式   /** * @method toThousands * @param {number|string} number * @return {string} */function toThousands(number) {  if (Math.abs(Number(number)) &gt;= 1000) {    const [integer, float] = (number || 0).toString().split(&#39;.&#39;);    const thousandsInteger = integer.replace(/(\\d)(?=(?:\\d{3})+$)/g, &#39;$1,&#39;);    return thousandsInteger + (float ? &#39;.&#39; + float : &#39;&#39;);  } else {    return number;  }}","categories":["notes"]},{"title":"黄瓜炒香肠","url":"/zh/2020/12/05/sauteed-cucumber-sausage.html","content":"食材用料   食材   数量   黄瓜   1根   香肠   2根   油   适量   蒜   适量   盐   适量   鸡精   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    蒜切末装盘   3.    黄瓜切成片   4.    香肠斜切成片   5.    热锅热油，下香肠，炒至表面略焦装盘备用   6.    另起油下蒜末爆香   7.    下黄瓜片翻炒均匀   8.    加入香肠、盐、生抽和鸡精翻炒均匀   9.    收锅   10.    装盘","categories":["cookbooks"]},{"title":"芹菜炒肉","url":"/zh/2020/11/30/celery-fried-meat.html","content":"食材用料   食材   数量   芹菜   200克   鸡胸肉   半块   油   适量   蒜   适量   胡椒粉   适量   淀粉   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片   3.    芹菜切段，焯水   4.    肉切片，捏掉水，加入生抽、胡椒粉、淀粉   5.    搅拌至粘稠   6.    放油中火，放入调料爆香   7.    放入肉片翻炒   8.    放入芹菜段，再加入一点点水大火翻炒   9.    放盐、一点点老抽翻炒   10.    收锅   11.    装盘","categories":["cookbooks"]},{"title":"芹菜香肠炒鸡蛋","url":"/zh/2020/11/29/scrambled-eggs-with-celery-sausage.html","content":"食材用料   食材   数量   芹菜   150克   香肠   2根   鸡蛋   2个   油   少量   蒜   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    蒜切末装起来   3.    芹菜切段   4.    香肠切片   5.    鸡蛋打散   6.    热锅热油，倒入鸡蛋炒成定型，盛出备用   7.    锅烧热，下油加香肠炒一下   8.    香肠表面略焦加入蒜末和芹菜翻炒   9.    加入鸡蛋、盐、生抽翻炒入味   10.    收锅   11.    装盘","categories":["cookbooks"]},{"title":"手撕鸡肉","url":"/zh/2020/11/27/hand-tore-the-chicken.html","content":"食材用料   食材   数量   无骨鸡腿   2个   姜   适量   料酒   适量   葱   适量   蒜   适量   辣椒粉   适量   盐   适量   生抽   适量   香油   适量   藤椒油   适量   做法步骤   图片   步骤   1.    准备食材   2.    煮鸡腿调料：葱段、姜片、盐和料酒   3.    锅中放鸡腿、煮鸡腿调料，加水开始煮20分钟左右   4.    期间准备腌料：葱段、蒜末、辣椒粉、盐、生抽、藤椒油、香油   5.    鸡腿煮好后捞出撕碎   6.    把腌料倒进去拌匀   7.    装盘","categories":["cookbooks"]},{"title":"麻辣鸡中翅","url":"/zh/2020/10/31/spicy-chicken-medium-wing.html","content":"食材用料   食材   数量   鸡中翅   4块   油   少量   葱   适量   姜   适量   蒜   适量   八角   2个   干辣椒   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   香油   适量   鸡翅必须焯水去血沫，不然菜味会变腥。   做法步骤   图片   步骤   1.    准备食材   2.    葱切葱花，蒜切末，姜切片，和干辣椒、花椒、八角装起来   3.    鸡中翅解冻洗净割口（想入味又不想割口可以拿牙签刺）   4.    热锅热油，下鸡中翅炒至表面金黄   5.    下葱花、蒜末、辣椒圈、花椒、八角爆香   6.    加入半碗水、生抽、老抽、盐   7.    汤汁剩少许时加入香油出锅   8.    装盘","categories":["cookbooks"]},{"title":"青菜炒肉","url":"/zh/2020/10/31/green-vegetables-meat.html","content":"食材用料   食材   数量   青菜   250克   鸡胸肉   半块   油   多量   蒜   适量   辣椒圈   适量   花椒   适量   盐   适量   生抽   适量   老抽   适量   青菜不出水关键：多放油，炒完菜最后放盐。   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：蒜切片、花椒、辣椒圈   3.    青菜洗净焯水   4.    肉切片，捏掉水，加入淀粉、生抽、一点点老抽   5.    搅拌至粘稠   6.    放油中火，放入蒜、辣椒圈、花椒爆香   7.    放入肉片翻炒至肉熟   8.    翻入青菜大火翻炒   9.    最后放入盐简单翻炒两下入味   10.    出锅   11.    装盘","categories":["cookbooks"]},{"title":"土豆块炖肉","url":"/zh/2020/10/21/potato-cubes-stew-with-meat.html","content":"食材用料   食材   数量   土豆   400克   鸡胸肉   半块   油   适量   葱   适量   姜   适量   蒜   适量   辣椒圈   适量   花椒   适量   桂叶   1片   盐   适量   老抽   少量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    准备调料：葱花、蒜末、辣椒圈、花椒   3.    土豆切成块，加清水泡防止变色   4.    肉切片，捏掉水   5.    放油放入调料爆香   6.    中火放入肉炒熟   7.    放入土豆块翻炒均匀   8.    放入生抽、老抽、盐大火翻炒   9.    放香叶，加水，没过食材，大火收汁   10.    收锅   11.    装盘","categories":["cookbooks"]},{"title":"土豆肉丝","url":"/zh/2020/10/21/potato-with-meat-shreds.html","content":"食材用料   食材   数量   土豆   250克   猪肉   120克   油   适量   青椒   适量   蒜   适量   干辣椒   适量   花椒   适量   盐   适量   生抽   适量   做法步骤   图片   步骤   1.    准备食材   2.    青椒切条，蒜切片，和辣椒圈花椒装起来   3.    土豆切成丝，冲洗一遍去掉淀粉，加清水泡防止变色   4.    猪肉切成丝   5.    肉丝解冻，捏去多余水分   6.    热锅热油，油冒烟下肉丝爆香翻炒（肉丝有水注意锅里油乱蹦）   7.    放入青椒调料等，翻炒爆香   8.    放入土豆丝翻炒均匀，加入生抽、盐后翻炒均匀入味   9.    收锅   10.    装盘","categories":["cookbooks"]},{"title":"前端自动部署 GitHub Page","url":"/zh/2019/12/05/deploy-github-page.html","content":"自己的项目部署在GitHub Page的时候很麻烦，要先build然后再把文件推到master/docs或者gh-pages分支上面，现在github有一个插件可以帮你完成上面步骤：   github地址：   gh-pages   安装：   $ npm install gh-pages --save-dev   注意：该模块需要git版本大于等于1.9   配置：   在 package.json 的 script 字段中添加以下代码   &quot;scripts&quot;: {  &quot;deploy&quot;: &quot;npm run build &amp; gh-pages -d dist&quot;,}   接下来运行    npm run deploy    就会先执行build命令，然后开始向该项目的gh-pages分支推送刚build的文件，随后在github项目的 Settings &gt; GitHub Pages 在 Sourse 中选择 gh-pages branch ，稍等几分钟后打开网址查看   https://${username}.github.io/${project}   命令行参数说明   参数   说明   -d   要推送文件的目录，这里写的是项目根目录 dist 文件夹。   -m   推送信息，信息如果过长带空格的话在json中需要加上双引号    -m \\&quot;Update GitHub Page\\&quot;   -b   推送的分支，默认gh-pages   更多参数请在命令行中输入以下命令   $ gh-pages --help","categories":["guides"]},{"title":"海浪涛天，一个老水兵的亲身经历","url":"/zh/2019/10/31/wave-and-sky.html","content":"","categories":["reprints"]},{"title":"图片 JPEG 显示优化","url":"/zh/2019/10/31/gradual-jpeg.html","content":"1. JPEG介绍   JPEG 是Joint Photographic Experts Group（联合图像专家小组）的缩写，是第一个国际图像压缩标准。JPEG图像压缩算法能够在提供良好的压缩性能的同时，具有比较好的重建质量，被广泛应用于图像、视频处理领域。   2. 保存方式   JPEG文件格式有两种保存方式。他们是Baseline JPEG和Progressive JPEG.两种格式有相同尺寸以及图像数据，他们的扩展名也是相同的，唯一的区别是二者显示的方式不同。   2.1 Baseline JPEG （基线）   这种类型的JPEG文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在JPEG文件中。打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来，直到所有的数据都被读完，就完成了整张图片的显示。如果文件较大或者网络下载速度较慢，那么就会看到图片被一行行加载的效果，这种格式的JPEG没有什么优点，因此，一般都推荐使用Progressive JPEG   2.2 Progressive JPEG （渐进）   和Baseline一遍扫描不同，Progressive JPEG文件包含多次扫描，这些扫描顺寻的存储在JPEG文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。这种格式的主要优点是在网络较慢的情况下，可以看到图片的轮廓知道正在加载的图片大概是什么。在一些网站打开较大图片时，你就会注意到这种技术。   3. 如何创建   使用Photoshop   文件 &gt; 存储为 &gt; 先点击保存，随后会弹出JPEG选项   如果想创建渐进式JPEG，选择连续   4. 应用   基本JPEG和渐进JPEG该什么时候使用？   当您的JPEG图像低于10K时，最好保存为基本JPEG（估计有75％的可能性会更小）对于超过10K的文件，渐进式JPEG将为您提供更好的压缩（在94％的情况下）Chrome + Firefox + IE9浏览器下，渐进式图片加载更快，而且是快很多，至于其他浏览器，与基本式图片的加载一致，至少不会拖后腿。3.渐进式图片也有不足，就是吃CPU吃内存。","categories":["guides"]},{"title":"母鸡与前端工程师","url":"/zh/2019/10/25/hen-and-front-end-engineer.html","content":"","categories":["reprints"]},{"title":"RegExp","url":"/zh/2019/10/22/regexp.html","content":"JavaScript RegExp 对象   语法   var regexp = new RegExp(pattern, modifiers);    // 通过 RegExp 构造函数创建var regexp = /[pattern]/[modifiers];            // 通过字面量创建   pattern（模式） 描述了表达式的模式   modifiers (修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配   注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的：    var regexp = new RegExp(&#39;\\\\w+&#39;);var regexp = /\\w+/;   修饰符   修饰符 (Modifiers) 用于指定全局匹配、区分大小写的匹配和多行匹配：   修饰符   描述   i   执行对大小写不敏感的匹配。   g   执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。   m   执行多行匹配。   s   允许 . 匹配换行符。   u   使用 unicode 码的模式进行匹配。   y   执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。   量词   量词（Quantifiers）定义了重复匹配字符的确数或约数：   量词   描述   n+   匹配任何包含至少一个 n 的字符串。   n*   匹配任何包含零个或多个 n 的字符串。   n?   匹配任何包含零个或一个 n 的字符串。   n{X}   匹配包含 X 个 n 的序列的字符串。   n{X,}   匹配包含最少 x 个、最多 y 个 n 的序列的字符串。   n{X,Y}   匹配包含至少 x 个 n 的序列的字符串。   ^n   匹配任何开头为 n 的字符串。   n$   匹配任何结尾为 n 的字符串。   ?=n   匹配任何其后紧接指定字符串 n 的字符串。   ?!n   匹配任何其后没有紧接指定字符串 n 的字符串。   元字符   元字符（Metacharacter）是拥有特殊含义的字符：   元字符   描述   .   （小数点）默认匹配除   换行符   之外的任何单个字符。   \\w   匹配单词字符（数字，字母，下划线）。   \\W   匹配非单词字符。   \\d   匹配数字。   \\D   匹配非数字字符。   \\s   匹配空白字符。   \\S   匹配非空白字符。   \\b   匹配单词边界。   \\B   匹配非单词边界。   \\0   匹配 NULL 字符。   \\n   匹配换行符。   \\f   匹配换页符。   \\r   匹配回车符。   \\t   匹配制表符。   \\v   匹配垂直制表符。   \\xxx   匹配以八进制数 xxx 规定的字符。   \\xdd   匹配以十六进制数 dd 规定的字符。   \\uxxxx   匹配以十六进制数 xxxx 规定的 Unicode 字符。   方括号   方括号用于查找某个范围内的字符：   表达式   描述   [^]   匹配任意任何字符。（可以匹配到   换行符   ）   [abc]   匹配方括号之间的任何字符。   [^abc]   匹配任何不在方括号之间的字符。   [0-9]   匹配任何从 0 至 9 的数字。   [a-z]   匹配任何从小写 a 到小写 z 的字符。   [A-Z]   匹配任何从大写 A 到大写 Z 的字符。   [A-z]   匹配任何从大写 A 到小写 z 的字符。   (red|blue|green)   匹配任何指定的选项。   RegExp 对象方法   表达式   描述   compile   编译正则表达式。   exec   检索字符串中指定的值。返回找到的值，并确定其位置。   test   检索字符串中指定的值。返回 true 或 false。   支持正则表达式的 String 对象的方法   表达式   描述   search   检索与正则表达式相匹配的值。。   match   找到一个或多个正则表达式的匹配。   replace   替换与正则表达式匹配的子串。   split   把字符串分割为字符串数组。   在多行文本中使用正则表达式   var string = &#39;Please yes\\nmake my day!&#39;;string.match(/yes.*day/); // nullstring.match(/yes[^]*day/); // &#39;yes\\nmake my day&#39;   先行断言和先行否定断言   先行断言（lookahead）指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。   var string = &#39;100% of US presidents have been male&#39;;/\\d+(?=%)/.exec(string); // [&#39;100&#39;]/have(?=%)/.exec(string); // null   先行否定断言（negative lookahead）x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。   var string = &#39;that’s all 44 of them&#39;;/\\d+(?!%)/.exec(string); // [&#39;44&#39;]/\\d+(?!.*of)/.exec(string); // null/\\d+(?!.*all)/.exec(string); // [&#39;44&#39;]/\\d+(?!.*of|.*all)/.exec(string); // null   后行断言和后行否定断言   ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。后行断言（lookbehind）指的是，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成 /(?&lt;=\\$)\\d+/。   var string = &#39;Benjamin Franklin is on the $100 bill&#39;;/(?&lt;=\\$)\\d+/.exec(string);  // [&quot;100&quot;]   后行否定断言（negative lookbehind）指的是，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成 /(?&lt;!\\$)\\d+/。   var string = &#39;it’s is worth about €90&#39;;/(?&lt;!\\$)\\d+/.exec(string);  // [&quot;90&quot;]   贪婪模式和非贪婪模式   贪婪模式: 正则表达式一般趋向于最大长度匹配，总是尝试匹配尽可能多的字符。   var html = &#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;;var regexp = /(&lt;.*&gt;)/;html.match(regexp); // [&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;]   非贪婪模式: 非贪婪匹配就是匹配到结果就好，总是尝试匹配尽可能少的字符。   var html = &#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;;var regexp = /(&lt;.*?&gt;)/;html.match(regexp); // [&#39;&lt;html&gt;&#39;]   针对 6 种重复类惰性匹配的简单描述如下：   {n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。   {n}?：尽量匹配 n 次。   {n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。   ??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。   +?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。   *? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。   捕获型分组和非捕获型分组   捕获型()：捕获型分组会把每个捕获分组所匹配的内容暂且存储在某个地方，以便下次使用。在JavaScript中，捕获性分组所匹配的内容都是以$1,$2,$3…的格式保存的。因此捕获型分组会有性能上的损失。   var string = &#39;sjds24324abcabc1234&#39;;var regexp = /(abc){2}/;string.match(regexp); // [&#39;abcabc&#39;, &#39;abc&#39;]   非捕获型(?:)：非捕获型分组只会返回一个不含各个分组匹配（不含字串）的结果。所以会提高匹配速度。   var string = &#39;sjds24324abcabc1234&#39;;var regexp = /(?:abc){2}/;string.match(regexp); // [&#39;abcabc&#39;]   正则命名组捕获   正则命名组捕获使用符号 ?&lt;name&gt; 表示，对匹配到的正则结果按名称访问。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。   var date = &#39;2023-01-01&#39;;var regexp = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u;regexp.exec(&#39;2023-01-01&#39;); // { year: &#39;2023&#39;, month: &#39;01&#39;, day: &#39;01&#39; }","categories":["notes"]},{"title":"VSCode 配置","url":"/zh/2019/09/21/vscode-configuration.html","content":"格式化代码快捷键：            ```    Shift + Alt + F    ```              ```    Shift (⇧) + Option (⌥) + F    ```              ```    Ctrl + Shift + I    ```     快捷键配置：   Redo（反撤销）：            ```    Ctrl + Shift + Z   ->   Ctrl + Y    ```              ```    Command (⌘) + Shift (⇧) + Z   ->   Command (⌘) + Y    ```     Copy Line Down（快速拷贝一行）:            ```    Shift + Alt + ↓   ->   Ctrl + D    ```              ```    Shift (⇧) + Option (⌥) + ↓   ->   Command (⌘) + D    ```     Transform to Uppercase（转为大写）:            ```    Null   ->   Ctrl + Shift + U    ```              ```    Null   ->   Command (⌘) + Shift (⇧) + U    ```     Transform to Lowercase（转为小写）:            ```    Null   ->   Ctrl + Shift + L    ```              ```    Null   ->   Command (⌘) + Shift (⇧) + L    ```     插件   GitLens   ：显示某一行代码是谁写的   vscode-fileheader   ：显示文件作者修改信息   ESLint   ：使用项目下的eslint配置文件检查项目代码   Prettier - Code formatter   ：prettier格式化代码   Tailwind CSS IntelliSense   ：Tailwind css语法提示插件   {  &quot;recommendations&quot;: [    &quot;eamodio.gitlens&quot;,    &quot;dbaeumer.vscode-eslint&quot;,    &quot;esbenp.prettier-vscode&quot;,    &quot;bradlc.vscode-tailwindcss&quot;  ]}   VSCode编辑器设置：   {  &quot;editor.detectIndentation&quot;: true,  &quot;editor.tabSize&quot;: 2,  &quot;files.eol&quot;: &quot;\\n&quot;,  &quot;files.autoSave&quot;: &quot;off&quot;,}   缩进    Indentation   detectIndentation    - 控制打开文件时是否根据文件内容自动检测“editor.tabSize”和“editor.insertSpaces”。   tabSize    - 制表符等于空格数。 当“editor.detectIndentation”打开时，此设置将根据文件内容被覆盖。   insertSpaces    - 按“Tab”时插入空格。 当“editor.detectIndentation”打开时，此设置将根据文件内容被覆盖。   {  &quot;editor.detectIndentation&quot;: true,  &quot;editor.tabSize&quot;: 2,  &quot;editor.insertSpaces&quot;: true}   行结束符   默认的行结束符。   值   说明   \\n   LF (Linux)   \\r\\n   CRLF (Windows)   auto   Uses operating system specific end of line character.   {  &quot;files.eol&quot;: &quot;\\n&quot;,  // Configure settings to be overridden for the shellscript language.  &quot;[shellscript]&quot;: {    &quot;files.eol&quot;: &quot;\\n&quot;  }}   自动保存    Auto Save   值   说明   off   to disable auto save.   afterDelay   to save files after a configured delay (default 1000 ms).   onFocusChange   to save files when focus moves out of the editor of the dirty file.   onWindowChange   to save files when the focus moves out of the VS Code window.   {  &quot;files.autoSave&quot;: &quot;off&quot;,  &quot;files.autoSaveDelay&quot;: 1000}   自动格式化    Formatting   formatOnSave    - 保存时格式化代码文件   formatOnType    - 输入后格式化该行代码   formatOnPaste    - 格式化粘贴内容   {  &quot;editor.formatOnSave&quot;: true,  &quot;editor.formatOnType&quot;: false,  &quot;editor.formatOnPaste&quot;: false}   默认格式化插件    Default formatter   dbaeumer.vscode-eslint    - Eslint Plugin.   esbenp.prettier-vscode    - Prettier - Code formatter.   {  // 将根据eslint配置格式化代码  &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;}   换行   代码长度超过编辑器可视宽度是否换行   {  &quot;editor.wordWrap&quot;: &quot;on&quot;}   展开缩写    Emmet   使用快捷语法展开标签，例如 ul&gt;li*3&gt;span.hello   {  &quot;emmet.triggerExpansionOnTab&quot;: true}   粘滞滚动    Sticky Scroll   https://code.visualstudio.com/updates/v1_85#_sticky-scroll-in-trees   {  &quot;workbench.tree.enableStickyScroll&quot;: false,  &quot;editor.stickyScroll.enabled&quot;: false}   其他        dragAndDrop    - 控制编辑器是否允许拖放来移动选中的内容     ignoreRecommendations    - 设置true可以禁止推荐插件推送，    详情见这里        proxy    - 编辑器设置代理   {  &quot;editor.dragAndDrop&quot;: false,  &quot;extensions.ignoreRecommendations&quot;: true,  &quot;http.proxy&quot;: &quot;http://127.0.0.1:1000&quot;}","categories":["notes"]},{"title":"Webstorm 配置","url":"/zh/2019/09/20/webstorm-configuration.html","content":"设置中文字体   Show only monospaced fonts 取消打钩   Font：consolas   Size：14   Line spacing: 1.2   Fallback font：Microsoft YaHei   格式化代码快捷键：   Ctrl + Alt + L   键盘快捷键：   Add Or Remove Caret（多光标）:   Alt+ Button1 Click   Redo（反撤销）:   Ctrl + Shift + Z   Expand Live Template / Emmet Abbreviation（展开标签）:   Tab   Fix ESLint Problems（修复ESLint错误）:   Alt + Shift + L   花括号和中括号之间加上空格配置：   Setting &gt; Editor &gt; Code Style &gt; JavaScript &gt; Space,  找到 Within，勾选以下几项并打上勾：   Object literal braces   ES6 import/export braces   Array brackets   Interpolation expressions   配置ESlint   Setting &gt; Plugins，安装ESlint插件   Setting &gt; ESLint Settings，配置   Setting 搜索ESLint，或者查找 Setting &gt; Languages &amp; Frameworks &gt; JavaScript &gt; Code Quality Tools &gt; ESLint   取消webstorm自动保存   第一步：   Settings &gt; Appearance &amp; Behavior &gt; System Settings&gt; Synchronization   &gt; Synchroniza files on frame or editor tab activation           // 激活当前窗口时保存   &gt; Save files on frame deactivation                                       // 切换到其他窗口时保存   &gt; Save files automatically if application is idle for  15 sec.    // 设定一个时间自动保存   &gt; Use &quot;safe write&quot; (save changes to a temporary file first)    // 安全写入,这个选项会不停的保存源文件,因此关闭最后一个就好   第二步：   Settings &gt; Editor &gt; General &gt; Editor Tabs&gt; Appearance   &gt; Mark modified(*)   // 被修改的文件会出现 * 号（在文件图标右下角）","categories":["notes"]}]