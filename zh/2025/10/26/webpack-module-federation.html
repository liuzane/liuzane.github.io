<!doctype html><html lang="zh"><head><meta charset="utf-8"><title>Webpack 模块联邦</title><meta name="author" content="柳叶刀编码"><meta name="keywords" content="Webpack,模块联邦,Module Federation,微前端,共享依赖,Webpack5,配置指南"><meta name="description" content="Webpack模块联邦(Module Federation)详细教程，包括概念解析、工作原理、主应用与远程应用配置示例，以及常见问题解答，帮助开发者实现微前端架构中的依赖共享。"><meta name="robots" content="index, follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="alternate" href="https://liuzane.github.io/en" hreflang="en"><link rel="alternate" href="https://liuzane.github.io/zh" hreflang="zh"><link rel="alternate" href="https://liuzane.github.io/ja" hreflang="ja"><link rel="alternate" href="https://liuzane.github.io" hreflang="x-default"><link rel="canonical" href="https://liuzane.github.io/zh/2025/10/26/webpack-module-federation.html"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/article.css"></head><body><div id="container"><div id="nav" class="frosted-glass fade-in"><nav id="nav-wrap"><a class="nav-link" href="/zh">首页</a> <a class="nav-link" href="/zh/archives">归档</a> <a class="nav-link" href="/zh/categories">分类</a> <a class="nav-link" href="/zh/works">作品</a> <a class="nav-link" href="/zh/about">关于</a></nav><div id="nav-lang"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="970" width="1.2rem" height="1.2rem"><path d="M1011.712 399.9744A512.1536 512.1536 0 0 0 512 0C229.2224 0 0 229.2224 0 512c0 282.7264 229.2224 512 512 512s512-229.2736 512-512c0-38.4512-4.2496-75.9808-12.288-112.0256zM94.976 512c0-52.1216 9.5744-101.9392 27.0336-147.968 22.1184 12.544 51.8656 14.848 51.8656 39.7824 0 82.432 3.072 170.8032 82.1248 172.1856 2.2528 0 44.032 15.0528 64 64 6.8608 16.896 34.1504 0 64 0 14.8992 0 0 23.808 0 75.264 0 51.3536 116.6848 130.304 116.6848 130.304-0.512 33.9456 0.9216 61.44 3.8912 83.3536a417.024 417.024 0 0 1-409.6-416.9216z m518.144 404.6336c16.4352-66.4064 24.4224-103.5776 58.7776-131.7888 49.664-40.8576 5.888-86.2208-31.8976-80.896-29.7984 4.3008-10.9568-34.9696-37.5808-37.12-26.624-2.0992-61.2864-52.224-99.584-69.4784-20.2752-9.1648-40.2432-33.6384-71.5264-34.7136-27.7504-1.024-68.2496 22.2208-68.2496 4.3008 0-57.7024-6.144-98.9184-7.424-115.3536-1.024-13.2096-9.1136-4.4544 28.3648-3.584 20.3776 0.512 10.4448-38.8608 30.6176-40.3968 19.8656-1.4848 67.072 17.6128 79.1552 9.984 11.2128-7.0656 82.2272 176.7936 82.2272 30.4128 0-17.408-9.472-47.616 0-64 37.5296-65.024 72.704-117.9648 69.5296-125.7472-1.792-4.352-38.4-7.936-67.6864 1.3824-9.8816 3.072 3.1232 17.7664-11.0592 20.9408-53.1968 11.6224-100.1984-13.6192-83.7632-37.376 16.896-24.2688 77.9264-10.5472 83.3024-59.3408 3.072-27.904 5.632-60.2624 7.3216-84.3264a417.536 417.536 0 0 1 326.4 259.584c-141.9776 103.424-105.6256 175.616-58.9824 216.8832 24.576 21.7088 47.9232 54.3744 63.1808 77.824a417.8944 417.8944 0 0 1-291.1232 262.8096z" p-id="971"></path></svg></div><div id="nav-lang-list" class="hidden"><a class="lang-link" href="/en/2025/10/26/webpack-module-federation.html" hreflang="en">English</a> <a class="lang-link" href="/zh/2025/10/26/webpack-module-federation.html" hreflang="zh">简体中文</a> <a class="lang-link" href="/ja/2025/10/26/webpack-module-federation.html" hreflang="ja">日本語</a></div></div><div id="scroller" class="fade-in"><div id="wrapper"><header id="header" class="frosted-glass"><div class="header-wrapper"><img src="/images/aodamiao.jpg" alt="柳叶刀编码" class="header-avatar"><p class="header-author">柳叶刀编码</p><p class="header-description">好好学习，天天向上</p></div></header><section id="content"><article class="article"><a class="article-back" href="javascript: history.back(-1)">&lt; 返回</a><header class="article-header"><h1 class="article-title">Webpack 模块联邦</h1><div class="article-meta"><time datetime="2025-10-26T09:51:17.000Z" class="article-date">2025-10-26</time></div></header><div class="article-content"><p>最近鼓捣了以下 Webpack 模块联邦，记录一下血泪历程。</p><h3 id="什么是-Webpack-模块联邦-Module-Federation"><a href="#什么是-Webpack-模块联邦-Module-Federation" class="headerlink" title="什么是 Webpack 模块联邦(Module Federation)"></a>什么是 Webpack 模块联邦(Module Federation)</h3><p>Webpack 模块联邦(Module Federation)是 Webpack 5 新增的一个功能，它允许你将一个 Webpack 应用程序的模块分发给其他应用程序使用。</p><p>说人话就是<strong>微前端系统有三个应用，可以共用一个 react&#x2F;vue 版本，减少浏览器重复下载依赖包的问题。</strong></p><h3 id="模块联邦的工作原理"><a href="#模块联邦的工作原理" class="headerlink" title="模块联邦的工作原理"></a>模块联邦的工作原理</h3><p>模块联邦分为两个部分：</p><ol><li>主应用程序（Host Application）：负责加载其他应用程序的模块。</li><li>远程应用程序（Remote Application）：负责提供模块给主应用程序使用。</li></ol><p>主应用在启动时，如果遇到了一个远程应用提供的模块，它会通过 js 加载该模块，加载完成后 Webpack 会判断该模块中的共享依赖包是否已加载：<br>如果共享依赖包未加载，远程应用会先请求共享依赖包，加载完成后标记为已加载。<br>如果共享依赖包已加载就不再请求共享依赖包。</p><p>流程图如下：</p><p><img src="/images/guides/webpack-module-federation/zh.jpg" alt="微前端模块联邦流程图"></p><p>图看完了，把朕的代码呈上来。。。</p><h3 id="Webpack-模块联邦配置说明"><a href="#Webpack-模块联邦配置说明" class="headerlink" title="Webpack 模块联邦配置说明"></a>Webpack 模块联邦配置说明</h3><p>看到 Webpack 配置是不是就头疼，但是你先别头疼，因为更头疼的在后面呢。。。😏</p><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块联邦插件无需安装，Webpack 5 已经内置了该插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">ModuleFederationPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>).<span class="property">container</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 应用名称，用于在主应用中引用远程应用的模块时使用</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;&#123;appName&#125;&#x27;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 远程应用的入口文件名称，用于其他应用加载该应用的模块</span></span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;remoteEntry.js&#x27;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 主应用的配置，用于加载哪些远程应用的模块</span></span><br><span class="line">      <span class="attr">remotes</span>: &#123;</span><br><span class="line">        <span class="comment">// key 是在主应用中import的名称，value 是远程应用的入口文件地址</span></span><br><span class="line">        <span class="attr">remote1</span>: <span class="string">&#x27;&#123;appName&#125;@http://localhost:&#123;port&#125;/&#123;filename&#125;.js&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value 也可以是一段 promise 代码</span></span><br><span class="line">        <span class="attr">remote2</span>: <span class="string">`promise new Promise((resolve) =&gt; &#123;</span></span><br><span class="line"><span class="string">          // 这里可以在运行时动态决定远程模块的入口文件地址</span></span><br><span class="line"><span class="string">          const remoteUrl = getRemoteUrlFromSomewhere(); // 你的自定义逻辑</span></span><br><span class="line"><span class="string">          const container = await import(/* webpackIgnore:false */ remoteUrl);</span></span><br><span class="line"><span class="string">          container.init(__webpack_share_scopes__.default); // 初始化共享作用域</span></span><br><span class="line"><span class="string">          resolve(container);</span></span><br><span class="line"><span class="string">        &#125;)`</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 远程应用的配置，用于暴露哪些模块给主应用使用，</span></span><br><span class="line">      <span class="comment">// 远程应用至少暴露一个模块，不然无法暴露远程地址，</span></span><br><span class="line">      <span class="comment">// 也就无法使用共享依赖功能了。</span></span><br><span class="line">      <span class="attr">exposes</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;./remoteModule1&#x27;</span>: <span class="string">&#x27;./src/remoteModule1.js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;./remoteModule2&#x27;</span>: <span class="string">&#x27;./src/remoteModule2.js&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 共享依赖配置，有三种声明方式：</span></span><br><span class="line">      <span class="comment">// 1. 数组形式：版本从package.json中推断，没有版本检查，它将始终使用找到的较高版本</span></span><br><span class="line">      <span class="attr">shared</span>: [<span class="string">&#x27;lodash&#x27;</span>],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 简单对象形式：版本从package.json中推断，它将使用最高的lodash版本，即&gt;= 4.17 and &lt; 5</span></span><br><span class="line">      <span class="attr">shared</span>: &#123;</span><br><span class="line">        <span class="attr">lodash</span>: <span class="string">&#x27;^4.17.0&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 详细对象形式：共享依赖可以配置更多的选项来控制共享的行为</span></span><br><span class="line">      <span class="attr">shared</span>: &#123;</span><br><span class="line">        <span class="comment">// 共享依赖库的名称</span></span><br><span class="line">        <span class="attr">lodash</span>: &#123;</span><br><span class="line">          <span class="comment">// 只允许该依赖在共享作用域中存在一个版本的共享依赖，默认值为 false。</span></span><br><span class="line">          <span class="comment">// 对于全局依赖库（如 React、Vue 等），应该将 singleton 设置为 true，</span></span><br><span class="line">          <span class="comment">// 以确保所有使用该依赖的应用程序都使用相同的实例。</span></span><br><span class="line">          <span class="attr">singleton</span>: boolean,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 软件包所需的版本，默认值为 false。</span></span><br><span class="line">          <span class="comment">// 设置 &#x27;^2.0.0&#x27; 要求远程应用程序使用的 lodash 版本必须&gt;= 2.0.0，&lt; 3.0.0。</span></span><br><span class="line">          <span class="attr">requiredVersion</span>: string | <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在加载远程模块时，是否立即加载该共享依赖，默认值为 false。</span></span><br><span class="line">          <span class="comment">// 如果设置为 true，webpack 会将共享依赖的包都打进应用的 bundle 中，</span></span><br><span class="line">          <span class="comment">// 而不是在使用时才请求。</span></span><br><span class="line">          <span class="attr">eager</span>: boolean,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 本地后备依赖加载，默认值为当前依赖库名称，即 &#x27;lodash&#x27;。</span></span><br><span class="line">          <span class="comment">// 当设置为字符串（依赖库名称）时，Webpack 会尝试从共享作用域中加载该共享依赖，</span></span><br><span class="line">          <span class="comment">// 如果在共享作用域内没有找到共享依赖或版本无效，Webpack 会回退到本地加载该共享依赖。</span></span><br><span class="line">          <span class="comment">// 当设置为 false 时，Webpack 不会加载本地依赖，只从共享作用域中加载。</span></span><br><span class="line">          <span class="attr">import</span>: <span class="literal">false</span> | string,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 严格版本检查，默认值为 true。</span></span><br><span class="line">          <span class="comment">// 当本地后备依赖可用且共享依赖的 singleton 为 false 时，</span></span><br><span class="line">          <span class="comment">// 则要求远程应用程序使用的 lodash 版本在共享作用域中必须匹配</span></span><br><span class="line">          <span class="attr">strictVersion</span>: boolean,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 所提供依赖的版本，默认值为 false。</span></span><br><span class="line">          <span class="comment">// 它允许 webpack 替换匹配的较低版本，但不能替换匹配的较高版本。</span></span><br><span class="line">          <span class="attr">version</span>: <span class="literal">false</span> | string,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 共享作用域中共享依赖的键名，默认值为依赖库名称，即 &#x27;lodash&#x27;。</span></span><br><span class="line">          <span class="comment">// 从共享作用域中根据此键名查找所请求的共享依赖，</span></span><br><span class="line">          <span class="comment">// 可以设置为不同的键名，应用于各个应用相同依赖库的不同版本。</span></span><br><span class="line">          <span class="attr">shareKey</span>: string,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 共享作用域的名称，默认值为 &#x27;default&#x27;。</span></span><br><span class="line">          <span class="comment">// 主应用和远程应用可以配置不同的共享作用域名称，</span></span><br><span class="line">          <span class="comment">// 以避免不同应用之间的共享依赖冲突。</span></span><br><span class="line">          <span class="attr">shareScope</span>: string,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 依赖名称</span></span><br><span class="line">          <span class="attr">packageName</span>: string,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ol><li>共享依赖配置必须在主应用和远程应用中都被声明才能使共享依赖功能生效。</li><li>无论是主应用还是远程应用配置了共享依赖不等于不用安装共享依赖包, <code>import</code> 配置为 <code>false</code> 时除外（不建议）。</li><li>主应用和远程应用在请求共享依赖时，如果共享依赖不可用或者版本不匹配，会加载本地后备依赖。</li><li>主应用也可以是远程应用，通过暴露自身模块，其他应用可以加载主应用的模块。</li></ol></blockquote><p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/module-federation-plugin/#Options">Webpack 模块联邦配置官方文档</a></p><p>现在配置说明看完了，你应该知道所有的共享依赖配置选项了，让我们看看你学会了多少。😎</p><h3 id="主应用程序配置"><a href="#主应用程序配置" class="headerlink" title="主应用程序配置"></a>主应用程序配置</h3><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">ModuleFederationPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>).<span class="property">container</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;host&#x27;</span>,</span><br><span class="line">      <span class="attr">remotes</span>: &#123;</span><br><span class="line">        <span class="attr">remote1</span>: <span class="string">&#x27;remote1@http://localhost:5001/remoteEntry.js&#x27;</span>,</span><br><span class="line">        <span class="attr">remote2</span>: <span class="string">&#x27;remote2@http://localhost:5002/remoteEntry.js&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">shared</span>: &#123;</span><br><span class="line">        <span class="attr">lodash</span>: &#123; </span><br><span class="line">          <span class="attr">singleton</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">requiredVersion</span>: <span class="string">&#x27;2.0.0&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./bootstrap&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>bootstrap.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some code...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;remote1/remoteModule&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; bootstrap, hello &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">bootstrap</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hello</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// some code...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;remote2/remoteModule&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; bootstrap, hello &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">bootstrap</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hello</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// some code...</span></span><br></pre></td></tr></table></figure><p>看到这里你肯定会迷惑了，为什么根目录多了一个 bootstrap.js 文件？又为什么在 main.js 中引入了 bootstrap.js 文件？<br>这不是脱裤子放屁-多此一举吗？<br>答案还真不是，看看官网怎么说的：</p><blockquote><p>应用程序正急切地执行一个作为全局主机运行的应用程序。我们强烈建议使用异步边界(asynchronous boundary)。它将把初始化代码分离成更大的块，以避免任何额外的开销，以提高总体性能。<a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/module-federation/#Uncaught-Error-Shared-module-is-not-available-for-eager-consumption">点我查看</a></p></blockquote><p>意思就是说，如果没有异步边界而又没有开启 <code>eager: true</code>，那么主应用会立即加载 lodash 这个共享依赖包，但是依赖包在 <code>eager: false</code> 时都是异步加载的，所以主应用就报共享依赖包不可用的错误。</p><h3 id="远程应用程序配置"><a href="#远程应用程序配置" class="headerlink" title="远程应用程序配置"></a>远程应用程序配置</h3><blockquote><p>远程应用可以有多个，主应用中配置了两个地址，分别是 remote1 和 remote2，这里只展示 remote1 的配置，remote2 配置类似。</p></blockquote><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">ModuleFederationPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>).<span class="property">container</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/bootstrap.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ModuleFederationPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;remote1&#x27;</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;remoteEntry.js&#x27;</span>,</span><br><span class="line">      <span class="attr">exposes</span>: &#123;</span><br><span class="line">        <span class="string">&quot;./remoteModule&quot;</span>: <span class="string">&quot;./src/exposes.js&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">shared</span>: &#123;</span><br><span class="line">        <span class="attr">lodash</span>: &#123; </span><br><span class="line">          <span class="attr">singleton</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">requiredVersion</span>: <span class="string">&#x27;2.0.0&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>exposes.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">bootstrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./bootstrap&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello Remote1&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>bootstrap.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some code...</span></span><br></pre></td></tr></table></figure><p>远程应用的配置与主应用有所不同：首先需要启动远程应用并对外暴露特定模块。随后，Webpack 模块联邦会生成该远程模块的访问地址。将该地址配置到主应用的模块联邦设置中并启动主应用后，当主应用执行类似 <code>import(&#39;remote1/remoteModule&#39;)</code> 的代码时，Webpack 模块联邦容器会通过该地址加载远程模块。同时，它会检查该远程模块所声明的共享依赖是否已在当前共享作用域中存在。如果依赖不可用，或版本不兼容，模块联邦将自动回退至加载主应用本地的后备依赖。</p><p><a href="https://liuzane.github.io/webpack-module-federation-demo">Demo 在线演示</a><br><a target="_blank" rel="noopener" href="https://github.com/liuzane/webpack-module-federation-demo">Demo Github 代码</a></p><h3 id="疑问和解答"><a href="#疑问和解答" class="headerlink" title="疑问和解答:"></a>疑问和解答:</h3><ol><li><p><strong>问</strong>：<strong>主应用和远程应用都配置了共享依赖 lodash，但是主应用和远程应用的 lodash 版本不一致，会发生什么？</strong><br><strong>答</strong>：当版本不一致时，<code>requiredVersion</code>会根据共享作用域中的版本是否符合要求版本范围，如果不符合，会加载本地的后备依赖。</p></li><li><p><strong>问</strong>：<strong>singleton 配置项的作用是什么，版本协商机制又是怎么工作的？</strong><br><strong>答</strong>：singleton 用于指定是否将该共享依赖作为唯一版本在共享作用域中共享，如果设置为 true，共享作用域中只能存在一个版本。如果有多个不同的版本的共享依赖，Webpack 会使用版本协商机制（会尝试使用最高版本的共享依赖，即使配置了低版本的应用先加载也会使用最高版本的共享依赖），且会强制所有配置了<code>singleton: true</code>的应用使用该版本。<br>以 lodash 为例：</p><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* App1 */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">lodash</span>: &#123;</span><br><span class="line">  <span class="attr">singleton</span>: <span class="literal">true</span>, <span class="comment">// 单例唯一版本</span></span><br><span class="line">  <span class="attr">requiredVersion</span>: <span class="string">&#x27;^1.0.0&#x27;</span>, <span class="comment">// 大于等于 1.0.0 小于 2.0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* App2 */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">lodash</span>: &#123;</span><br><span class="line">  <span class="attr">singleton</span>: <span class="literal">true</span>, <span class="comment">// 单例唯一版本</span></span><br><span class="line">  <span class="attr">requiredVersion</span>: <span class="string">&#x27;^2.0.0&#x27;</span>, <span class="comment">// 大于等于 2.0.0 小于 3.0.0 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* App3 */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">lodash</span>: &#123;</span><br><span class="line">  <span class="attr">singleton</span>: <span class="literal">false</span>, <span class="comment">// 非单例版本</span></span><br><span class="line">  <span class="attr">requiredVersion</span>: <span class="string">&#x27;^3.0.0&#x27;</span>, <span class="comment">// 大于等于 3.0.0 小于 4.0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>App1 使用了单例唯一版本且 lodash 要求版本<strong>大于等于 <code>1.0.0</code> 小于 <code>2.0.0</code></strong><br>App2 使用了单例唯一版本且 lodash 要求版本<strong>大于等于 <code>2.0.0</code> 小于 <code>3.0.0</code></strong><br>App3 没有使用单例唯一版本且 lodash 要求版本<strong>大于等于 <code>3.0.0</code> 小于 <code>4.0.0</code></strong><br>那么 App1 和 App2 无论哪个先加载都会使用 App2 配置的最高版本 <code>2.0.0</code>，App3 的 lodash 由于匹配不到可用的版本，又指定了 <code>singleton</code> 为 <code>false</code>，App3 的 lodash 将会使用本地回退版本 <code>3.0.0</code>。</p></li><li><p><strong>问</strong>：<strong>远程应用只想使用共享依赖，也没有需要暴露自身模块的场景，所以只配置了<code>shared</code>，没有配置<code>exposes</code>，会发生什么？</strong><br><strong>答</strong>：远程应用的远程模块 URL 不会生成，主应用访问该远程模块 URL 将返回 404 错误，且模块联邦不会生效，永远只加载自身的后备依赖。</p></li><li><p><strong>问</strong>：<strong>主应用安装了 lodash 并配置了共享依赖，远程应用可以只配置共享依赖而不安装 npm 依赖包吗？</strong><br><strong>答</strong>：可以，但是不推荐。当主应用和远程应用都配置了 lodash 共享依赖，但是远程应用没有安装 npm 依赖包时，远程应用需要这样配置：</p><figure class="highlight javascript"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">lodash</span>: &#123;</span><br><span class="line">  <span class="attr">import</span>: <span class="literal">false</span>, <span class="comment">// 不加载本地后备依赖，只从共享作用域中加载</span></span><br><span class="line">  <span class="attr">singleton</span>: <span class="literal">true</span>, <span class="comment">// 单例唯一版本</span></span><br><span class="line">  <span class="attr">requiredVersion</span>: <span class="string">&#x27;*&#x27;</span>, <span class="comment">// 任何版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>但是不推荐这样做，因为当主应用的 lodash 版本因为网络或者其他原因导致 lodash 加载失败时，远程应用会报错，而不是使用本地后备依赖。</p></li><li><p><strong>问</strong>：<strong>在主应用配置中必须通过动态引入<code>import(&#39;&#123;remotesKey&#125;/&#123;exposesKey&#125;&#39;)</code>远程模块吗？可以通过其他方式引入吗？</strong><br><strong>答</strong>：必须这样引入，其他方式例如 HTML 引入也会报错。</p></li></ol></div><div class="comment-divider"></div><script src="https://giscus.app/client.js" data-lang="zh-CN" data-repo="liuzane&#x2F;liuzane.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMTY3ODEyNDM&#x3D;" data-category="Announcements" data-category-id="DIC_kwDODOvRu84CwfsS" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" crossorigin="anonymous" async></script></article></section><footer id="footer" class="frosted-glass"><div class="footer-wrapper"><a href="/" class="footer-title">柳叶刀编码的博客</a><p>这片小天地由俺搭建</p></div></footer></div></div><script src="/js/i18n.js"></script></div></body></html>