<!doctype html><html lang="zh"><head><meta charset="utf-8"><title>RegExp</title><meta name="author" content="柳叶刀编码"><meta name="keywords" content="RegExp, 正则表达式, 浏览器, 操作, 匹配, 搜索, 替换"><meta name="description" content="介绍 JavaScript RegExp 对象，包括语法、修饰符、量词和方法。"><meta name="robots" content="index, follow"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="alternate" href="https://liuzane.github.io/en" hreflang="en"><link rel="alternate" href="https://liuzane.github.io/zh" hreflang="zh"><link rel="alternate" href="https://liuzane.github.io/ja" hreflang="ja"><link rel="alternate" href="https://liuzane.github.io" hreflang="x-default"><link rel="canonical" href="https://liuzane.github.io/zh/2019/10/22/regexp.html"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/article.css"></head><body><div id="container"><div id="nav" class="frosted-glass fade-in"><nav id="nav-wrap"><a class="nav-link" href="/zh">首页</a> <a class="nav-link" href="/zh/archives">归档</a> <a class="nav-link" href="/zh/categories">分类</a> <a class="nav-link" href="/zh/works">作品</a> <a class="nav-link" href="/zh/about">关于</a></nav><div id="nav-lang"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="970" width="1.2rem" height="1.2rem"><path d="M1011.712 399.9744A512.1536 512.1536 0 0 0 512 0C229.2224 0 0 229.2224 0 512c0 282.7264 229.2224 512 512 512s512-229.2736 512-512c0-38.4512-4.2496-75.9808-12.288-112.0256zM94.976 512c0-52.1216 9.5744-101.9392 27.0336-147.968 22.1184 12.544 51.8656 14.848 51.8656 39.7824 0 82.432 3.072 170.8032 82.1248 172.1856 2.2528 0 44.032 15.0528 64 64 6.8608 16.896 34.1504 0 64 0 14.8992 0 0 23.808 0 75.264 0 51.3536 116.6848 130.304 116.6848 130.304-0.512 33.9456 0.9216 61.44 3.8912 83.3536a417.024 417.024 0 0 1-409.6-416.9216z m518.144 404.6336c16.4352-66.4064 24.4224-103.5776 58.7776-131.7888 49.664-40.8576 5.888-86.2208-31.8976-80.896-29.7984 4.3008-10.9568-34.9696-37.5808-37.12-26.624-2.0992-61.2864-52.224-99.584-69.4784-20.2752-9.1648-40.2432-33.6384-71.5264-34.7136-27.7504-1.024-68.2496 22.2208-68.2496 4.3008 0-57.7024-6.144-98.9184-7.424-115.3536-1.024-13.2096-9.1136-4.4544 28.3648-3.584 20.3776 0.512 10.4448-38.8608 30.6176-40.3968 19.8656-1.4848 67.072 17.6128 79.1552 9.984 11.2128-7.0656 82.2272 176.7936 82.2272 30.4128 0-17.408-9.472-47.616 0-64 37.5296-65.024 72.704-117.9648 69.5296-125.7472-1.792-4.352-38.4-7.936-67.6864 1.3824-9.8816 3.072 3.1232 17.7664-11.0592 20.9408-53.1968 11.6224-100.1984-13.6192-83.7632-37.376 16.896-24.2688 77.9264-10.5472 83.3024-59.3408 3.072-27.904 5.632-60.2624 7.3216-84.3264a417.536 417.536 0 0 1 326.4 259.584c-141.9776 103.424-105.6256 175.616-58.9824 216.8832 24.576 21.7088 47.9232 54.3744 63.1808 77.824a417.8944 417.8944 0 0 1-291.1232 262.8096z" p-id="971"></path></svg></div><div id="nav-lang-list" class="hidden"><a class="lang-link" href="/en/2019/10/22/regexp.html" hreflang="en">English</a> <a class="lang-link" href="/zh/2019/10/22/regexp.html" hreflang="zh">简体中文</a> <a class="lang-link" href="/ja/2019/10/22/regexp.html" hreflang="ja">日本語</a></div></div><div id="scroller" class="fade-in"><div id="wrapper"><header id="header" class="frosted-glass"><div class="header-wrapper"><img src="/images/aodamiao.jpg" alt="柳叶刀编码" class="header-avatar"><p class="header-author">柳叶刀编码</p><p class="header-description">好好学习，天天向上</p></div></header><section id="content"><article class="article"><a class="article-back" href="javascript: history.back(-1)">&lt; 返回</a><header class="article-header"><h1 class="article-title">RegExp</h1><div class="article-meta"><time datetime="2025-07-05T08:57:39.000Z" class="article-date">2025-07-05</time></div></header><div class="article-content"><h2 id="JavaScript-RegExp-对象"><a href="#JavaScript-RegExp-对象" class="headerlink" title="JavaScript RegExp 对象"></a>JavaScript RegExp 对象</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(pattern, modifiers);    <span class="comment">// 通过 RegExp 构造函数创建</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/[pattern]/</span>[modifiers];            <span class="comment">// 通过字面量创建</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>pattern（模式） 描述了表达式的模式</li><li>modifiers (修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</li></ul><p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\w+&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/\w+/</span>;</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><blockquote><p>修饰符 (Modifiers) 用于指定全局匹配、区分大小写的匹配和多行匹配：</p></blockquote><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>执行对大小写不敏感的匹配。</td></tr><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td>m</td><td>执行多行匹配。</td></tr><tr><td>s</td><td>允许 . 匹配换行符。</td></tr><tr><td>u</td><td>使用 unicode 码的模式进行匹配。</td></tr><tr><td>y</td><td>执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始。</td></tr></tbody></table><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><blockquote><p>量词（Quantifiers）定义了重复匹配字符的确数或约数：</p></blockquote><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td>n?</td><td>匹配任何包含零个或一个 n 的字符串。</td></tr><tr><td>n{X}</td><td>匹配包含 X 个 n 的序列的字符串。</td></tr><tr><td>n{X,}</td><td>匹配包含最少 x 个、最多 y 个 n 的序列的字符串。</td></tr><tr><td>n{X,Y}</td><td>匹配包含至少 x 个 n 的序列的字符串。</td></tr><tr><td>^n</td><td>匹配任何开头为 n 的字符串。</td></tr><tr><td>n$</td><td>匹配任何结尾为 n 的字符串。</td></tr><tr><td>?&#x3D;n</td><td>匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td>?!n</td><td>匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><blockquote><p>元字符（Metacharacter）是拥有特殊含义的字符：</p></blockquote><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>（小数点）默认匹配除<em><strong>换行符</strong></em>之外的任何单个字符。</td></tr><tr><td>\w</td><td>匹配单词字符（数字，字母，下划线）。</td></tr><tr><td>\W</td><td>匹配非单词字符。</td></tr><tr><td>\d</td><td>匹配数字。</td></tr><tr><td>\D</td><td>匹配非数字字符。</td></tr><tr><td>\s</td><td>匹配空白字符。</td></tr><tr><td>\S</td><td>匹配非空白字符。</td></tr><tr><td>\b</td><td>匹配单词边界。</td></tr><tr><td>\B</td><td>匹配非单词边界。</td></tr><tr><td>\0</td><td>匹配 NULL 字符。</td></tr><tr><td>\n</td><td>匹配换行符。</td></tr><tr><td>\f</td><td>匹配换页符。</td></tr><tr><td>\r</td><td>匹配回车符。</td></tr><tr><td>\t</td><td>匹配制表符。</td></tr><tr><td>\v</td><td>匹配垂直制表符。</td></tr><tr><td>\xxx</td><td>匹配以八进制数 xxx 规定的字符。</td></tr><tr><td>\xdd</td><td>匹配以十六进制数 dd 规定的字符。</td></tr><tr><td>\uxxxx</td><td>匹配以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><h4 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h4><blockquote><p>方括号用于查找某个范围内的字符：</p></blockquote><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[^]</td><td>匹配任意任何字符。（可以匹配到<em><strong>换行符</strong></em>）</td></tr><tr><td>[abc]</td><td>匹配方括号之间的任何字符。</td></tr><tr><td>[^abc]</td><td>匹配任何不在方括号之间的字符。</td></tr><tr><td>[0-9]</td><td>匹配任何从 0 至 9 的数字。</td></tr><tr><td>[a-z]</td><td>匹配任何从小写 a 到小写 z 的字符。</td></tr><tr><td>[A-Z]</td><td>匹配任何从大写 A 到大写 Z 的字符。</td></tr><tr><td>[A-z]</td><td>匹配任何从大写 A 到小写 z 的字符。</td></tr><tr><td>(red|blue|green)</td><td>匹配任何指定的选项。</td></tr></tbody></table><h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>compile</td><td>编译正则表达式。</td></tr><tr><td>exec</td><td>检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td>test</td><td>检索字符串中指定的值。返回 true 或 false。</td></tr></tbody></table><h4 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>search</td><td>检索与正则表达式相匹配的值。。</td></tr><tr><td>match</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td>replace</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td>split</td><td>把字符串分割为字符串数组。</td></tr></tbody></table><h4 id="在多行文本中使用正则表达式"><a href="#在多行文本中使用正则表达式" class="headerlink" title="在多行文本中使用正则表达式"></a>在多行文本中使用正则表达式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Please yes\nmake my day!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(<span class="regexp">/yes.*day/</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(<span class="regexp">/yes[^]*day/</span>); <span class="comment">// &#x27;yes\nmake my day&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="先行断言和先行否定断言"><a href="#先行断言和先行否定断言" class="headerlink" title="先行断言和先行否定断言"></a>先行断言和先行否定断言</h4><blockquote><p>先行断言（lookahead）指的是，x只有在y前面才匹配，必须写成&#x2F;x(?&#x3D;y)&#x2F;。比如，只匹配百分号之前的数字，要写成&#x2F;\d+(?&#x3D;%)&#x2F;。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;100% of US presidents have been male&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?=%)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// [&#x27;100&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/have(?=%)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><blockquote><p>先行否定断言（negative lookahead）x只有不在y前面才匹配，必须写成&#x2F;x(?!y)&#x2F;。比如，只匹配不在百分号之前的数字，要写成&#x2F;\d+(?!%)&#x2F;。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;that’s all 44 of them&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!%)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// [&#x27;44&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!.*of)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!.*all)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// [&#x27;44&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">/\d+(?!.*of|.*all)/</span>.<span class="title function_">exec</span>(string); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h4 id="后行断言和后行否定断言"><a href="#后行断言和后行否定断言" class="headerlink" title="后行断言和后行否定断言"></a>后行断言和后行否定断言</h4><blockquote><p>ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。<br>后行断言（lookbehind）指的是，x只有在y后面才匹配，必须写成&#x2F;(?&lt;&#x3D;y)x&#x2F;。比如，只匹配美元符号之后的数字，要写成 &#x2F;(?&lt;&#x3D;\$)\d+&#x2F;。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Benjamin Franklin is on the $100 bill&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/(?&lt;=\$)\d+/</span>.<span class="title function_">exec</span>(string);  <span class="comment">// [&quot;100&quot;]</span></span><br></pre></td></tr></table></figure><blockquote><p>后行否定断言（negative lookbehind）指的是，x只有不在y后面才匹配，必须写成&#x2F;(?&lt;!y)x&#x2F;。比如，只匹配不在美元符号后面的数字，要写成 &#x2F;(?&lt;!\$)\d+&#x2F;。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;it’s is worth about €90&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/(?&lt;!\$)\d+/</span>.<span class="title function_">exec</span>(string);  <span class="comment">// [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h4><blockquote><p>贪婪模式: 正则表达式一般趋向于最大长度匹配，总是尝试匹配尽可能多的字符。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(&lt;.*&gt;)/</span>;</span><br><span class="line"></span><br><span class="line">html.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>非贪婪模式: 非贪婪匹配就是匹配到结果就好，总是尝试匹配尽可能少的字符。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(&lt;.*?&gt;)/</span>;</span><br><span class="line"></span><br><span class="line">html.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;&lt;html&gt;&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>针对 6 种重复类惰性匹配的简单描述如下：</p><ul><li>{n,m}?：尽量匹配 n 次，但是为了满足限定条件也可能最多重复 m 次。</li><li>{n}?：尽量匹配 n 次。</li><li>{n,}?：尽量匹配 n 次，但是为了满足限定条件也可能匹配任意次。</li><li>??：尽量匹配，但是为了满足限定条件也可能最多匹配 1 次，相当于 {0,1}?。</li><li>+?：尽量匹配 1 次，但是为了满足限定条件也可能匹配任意次，相当于 {1,}?。</li><li>*? ：尽量不匹配，但是为了满足限定条件也可能匹配任意次，相当于 {0,}?。</li></ul></blockquote><h4 id="捕获型分组和非捕获型分组"><a href="#捕获型分组和非捕获型分组" class="headerlink" title="捕获型分组和非捕获型分组"></a>捕获型分组和非捕获型分组</h4><blockquote><p>捕获型()：捕获型分组会把每个捕获分组所匹配的内容暂且存储在某个地方，以便下次使用。在JavaScript中，捕获性分组所匹配的内容都是以$1,$2,$3…的格式保存的。因此捕获型分组会有性能上的损失。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;sjds24324abcabc1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(abc)&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;abcabc&#x27;, &#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>非捕获型(?:)：非捕获型分组只会返回一个不含各个分组匹配（不含字串）的结果。所以会提高匹配速度。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;sjds24324abcabc1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?:abc)&#123;2&#125;/</span>;</span><br><span class="line"></span><br><span class="line">string.<span class="title function_">match</span>(regexp); <span class="comment">// [&#x27;abcabc&#x27;]</span></span><br></pre></td></tr></table></figure><h4 id="正则命名组捕获"><a href="#正则命名组捕获" class="headerlink" title="正则命名组捕获"></a>正则命名组捕获</h4><blockquote><p>正则命名组捕获使用符号 ?&lt;name&gt; 表示，对匹配到的正则结果按名称访问。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="string">&#x27;2023-01-01&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line">regexp.<span class="title function_">exec</span>(<span class="string">&#x27;2023-01-01&#x27;</span>); <span class="comment">// &#123; year: &#x27;2023&#x27;, month: &#x27;01&#x27;, day: &#x27;01&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div><div class="comment-divider"></div><script src="https://giscus.app/client.js" data-lang="zh-CN" data-repo="liuzane&#x2F;liuzane.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMTY3ODEyNDM&#x3D;" data-category="Announcements" data-category-id="DIC_kwDODOvRu84CwfsS" data-mapping="title" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" crossorigin="anonymous" async></script></article></section><footer id="footer" class="frosted-glass"><div class="footer-wrapper"><a href="/" class="footer-title">柳叶刀编码的博客</a><p>这片小天地由俺搭建</p></div></footer></div></div><script src="/js/i18n.js"></script></div></body></html>