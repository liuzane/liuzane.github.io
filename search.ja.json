[{"title":"酔ったポスト:私は\" srエンジニアとして学んだこと","url":"/ja/2025/11/01/drunk-post-things-ive-learned-as-a-sr-engineer.html","content":"","categories":["reprints"]},{"title":"Webpack モジュール連携","url":"/ja/2025/10/26/webpack-module-federation.html","content":"最近、Webpackモジュール連携（Module Federation）をいじってみたので、苦闘の記録を残しておきます。   Webpackモジュール連携（Module Federation）とは   Webpackモジュール連携はWebpack 5で追加された機能で、あるWebpackアプリケーションのモジュールを他のアプリケーションで使用できるようにします。   わかりやすく言うと、   マイクロフロントエンドシステムに3つのアプリケーションがある場合、それらが同じreact/vueバージョンを共有でき、ブラウザが依存パッケージを重複してダウンロードする問題を減らせます。   モジュール連携の仕組み   モジュール連携は2つの部分で構成されます：   ホストアプリケーション（Host Application）：他のアプリケーションのモジュールを読み込みます。   リモートアプリケーション（Remote Application）：ホストアプリケーションが使用するモジュールを提供します。   ホストアプリケーションは起動時に、リモートアプリケーションが提供するモジュールに遭遇すると、JavaScriptを通じてそのモジュールを読み込みます。読み込みが完了すると、Webpackはそのモジュール内の共有依存パッケージが既に読み込まれているかどうかを判断します：   共有依存パッケージがまだ読み込まれていない場合、リモートアプリケーションはまず共有依存パッケージを要求し、読み込みが完了すると「読み込み済み」としてマークします。   共有依存パッケージが既に読み込まれている場合は、再度要求しません。   フローチャートは以下の通りです：   図を見たところで、コードを見せてください。。。   Webpackモジュール連携設定説明   Webpack設定を見ると頭が痛くなりますか？でも、まだ頭を痛めないでください。この後にもっと頭が痛くなることが待っていますから。。。😏   // モジュール連携プラグインはインストール不要です。Webpack 5に組み込まれています。const { ModuleFederationPlugin } = require(&#39;webpack&#39;).container;module.exports = {  // ...  plugins: [    new ModuleFederationPlugin({      // アプリケーション名。ホストアプリケーションがリモートアプリケーションのモジュールを参照する際に使用します。      name: &#39;{appName}&#39;,      // リモートアプリケーションのエントリーファイル名。他のアプリケーションがこのアプリケーションのモジュールを読み込む際に使用します。      filename: &#39;remoteEntry.js&#39;,      // ホストアプリケーションの設定。どのリモートアプリケーションのモジュールを読み込むかを指定します。      remotes: {        // keyはホストアプリケーションでのimport名、valueはリモートアプリケーションのエントリーファイルアドレスです。        remote1: &#39;{appName}@http://localhost:{port}/{filename}.js&#39;,        // valueはPromiseコードでも構いません。        remote2: `promise new Promise((resolve) =&gt; {          // ここで実行時にリモートモジュールのエントリーファイルアドレスを動的に決定できます。          const remoteUrl = getRemoteUrlFromSomewhere(); // カスタムロジック          const container = await import(/* webpackIgnore:false */ remoteUrl);          container.init(__webpack_share_scopes__.default); // 共有スコープを初期化          resolve(container);        })`      },      // リモートアプリケーションの設定。ホストアプリケーションにどのモジュールを公開するかを指定します。      // リモートアプリケーションは少なくとも1つのモジュールを公開する必要があります。そうでないとリモートアドレスを公開できず、      // 共有依存機能も使用できません。      exposes: {        &#39;./remoteModule1&#39;: &#39;./src/remoteModule1.js&#39;,        &#39;./remoteModule2&#39;: &#39;./src/remoteModule2.js&#39;,      },      // 共有依存設定。宣言方法は3つあります：      // 1. 配列形式：バージョンはpackage.jsonから推測され、バージョンチェックはありません。常に見つかった高いバージョンを使用します。      shared: [&#39;lodash&#39;],      // 2. 簡易オブジェクト形式：バージョンはpackage.jsonから推測されます。最高のlodashバージョン、つまり&gt;= 4.17 and &lt; 5を使用します。      shared: {        lodash: &#39;^4.17.0&#39;,      },      // 3. 詳細オブジェクト形式：共有依存の動作を制御するためのより多くのオプションを設定できます。      shared: {        // 共有依存ライブラリの名前。        lodash: {          // この依存関係を共有スコープ内で単一バージョンのみとするかどうか。デフォルトはfalse。          // React、Vueなどのグローバル依存ライブラリの場合、singletonをtrueに設定する必要があります。          // これにより、この依存関係を使用するすべてのアプリケーションが同じインスタンスを使用するようになります。          singleton: boolean,          // パッケージに必要なバージョン。デフォルトはfalse。          // &#39;^2.0.0&#39;を設定すると、リモートアプリケーションが使用するlodashバージョンは2.0.0以上3.0.0未満でなければなりません。          requiredVersion: string | false,          // リモートモジュールを読み込む際、この共有依存を即時に読み込むかどうか。デフォルトはfalse。          // trueに設定すると、webpackは共有依存のパッケージをアプリケーションのバンドルに含めます。          // 使用時に要求するのではなく。          eager: boolean,          // ローカルフォールバック依存の読み込み。デフォルトは現在の依存ライブラリ名、つまり &#39;lodash&#39;。          // 文字列（依存ライブラリ名）に設定すると、Webpackは共有スコープから共有依存の読み込みを試みます。          // 共有スコープ内に共有依存が見つからないか、バージョンが無効な場合、Webpackはローカルで共有依存を読み込むようにフォールバックします。          // falseに設定すると、Webpackはローカル依存を読み込まず、共有スコープからのみ読み込みます。          import: false | string,          // 厳密なバージョンチェック。デフォルトはtrue。          // ローカルフォールバック依存が利用可能で、共有依存のsingletonがfalseの場合、          // リモートアプリケーションが使用するlodashバージョンは共有スコープ内のものと一致しなければなりません。          strictVersion: boolean,          // 提供される依存関係のバージョン。デフォルトはfalse。          // これにより、webpackは一致する低いバージョンを置き換えることができますが、一致する高いバージョンは置き換えられません。          version: false | string,          // 共有スコープ内の共有依存のキー名。デフォルトは依存ライブラリ名、つまり &#39;lodash&#39;。          // このキー名に基づいて共有スコープから要求された共有依存を検索します。          // 異なるキー名に設定することで、同じ依存ライブラリの異なるバージョンを各アプリケーションに適用できます。          shareKey: string,          // 共有スコープの名前。デフォルトは &#39;default&#39;。          // ホストアプリケーションとリモートアプリケーションは、異なる共有スコープ名を設定できます。          // これにより、異なるアプリケーション間の共有依存の衝突を避けられます。          shareScope: string,          // 依存関係名。          packageName: string,        }      },    })  ],};   共有依存設定は、ホストアプリケーションとリモートアプリケーションの両方で宣言されなければ、共有依存機能は有効になりません。   ホストアプリケーションまたはリモートアプリケーションのいずれかで共有依存を設定しても、共有依存パッケージをインストールする必要がなくなるわけではありません（   import   が   false   に設定されている場合を除く、非推奨）。   ホストアプリケーションとリモートアプリケーションが共有依存を要求する際、共有依存が利用できないかバージョンが一致しない場合、ローカルのフォールバック依存が読み込まれます。   ホストアプリケーションもリモートアプリケーションになり得ます。自身のモジュールを公開することで、他のアプリケーションはホストアプリケーションのモジュールを読み込めます。   Webpackモジュール連携設定公式ドキュメント   設定説明を読んだので、すべての共有依存設定オプションを知っているはずです。どれだけ理解したか見てみましょう。😎   ホストアプリケーション設定   const { ModuleFederationPlugin } = require(&#39;webpack&#39;).container;module.exports = {  entry: &#39;./src/main.js&#39;,  // ...  plugins: [    new ModuleFederationPlugin({      name: &#39;host&#39;,      remotes: {        remote1: &#39;remote1@http://localhost:5001/remoteEntry.js&#39;,        remote2: &#39;remote2@http://localhost:5002/remoteEntry.js&#39;,      },      shared: {        lodash: {           singleton: true,          requiredVersion: &#39;2.0.0&#39;,        }      },    })  ],};import(&#39;./bootstrap&#39;);import _ from &#39;lodash&#39;;// 何らかのコード...import(&#39;remote1/remoteModule&#39;).then(({ bootstrap, hello }) =&gt; {  bootstrap();  console.log(hello());});// 何らかのコード...import(&#39;remote2/remoteModule&#39;).then(({ bootstrap, hello }) =&gt; {  bootstrap();  console.log(hello());});// 何らかのコード...   これを見て、きっと困惑しているでしょう。なぜルートディレクトリに   bootstrap.js   ファイルが追加されているのか？なぜ   main.js   で   bootstrap.js   ファイルをインポートしているのか？これは無駄なことをしているのではないか？答えは実はノーです。公式ドキュメントではこう述べています：   アプリケーションは、グローバルホストとして実行されるアプリケーションを熱心に実行しています。非同期境界（asynchronous boundary）の使用を強く推奨します。これにより、初期化コードが大きなチャンクに分離され、追加のオーバーヘッドを回避し、全体的なパフォーマンスが向上します。   クリックして表示   つまり、非同期境界がなく、   eager: true   が有効になっていない場合、ホストアプリケーションはすぐにlodashなどの共有依存パッケージを読み込もうとします。しかし、   eager: false   の場合、依存パッケージは非同期で読み込まれるため、ホストアプリケーションは共有依存パッケージが利用できないというエラーをスローします。   リモートアプリケーション設定   リモートアプリケーションは複数存在できます。ホストアプリケーションは   remote1   と   remote2   の2つのアドレスを設定しています。ここでは   remote1   の設定のみを示します。   remote2   も同様です。   const { ModuleFederationPlugin } = require(&#39;webpack&#39;).container;module.exports = {  entry: &#39;./src/bootstrap.js&#39;,  // ...  plugins: [    new ModuleFederationPlugin({      name: &#39;remote1&#39;,      filename: &#39;remoteEntry.js&#39;,      exposes: {        &quot;./remoteModule&quot;: &quot;./src/exposes.js&quot;,      },      shared: {        lodash: {           singleton: true,          requiredVersion: &#39;2.0.0&#39;,        }      },    }),  ],};export function bootstrap() {  import(&#39;./bootstrap&#39;);}export function hello() {  return &#39;Hello Remote1&#39;;}import _ from &#39;lodash&#39;;// 何らかのコード...   リモートアプリケーションの設定はホストアプリケーションとは異なります：まず、リモートアプリケーションを起動し、特定のモジュールを外部に公開する必要があります。その後、Webpackモジュール連携はそのリモートモジュールのアクセスアドレスを生成します。このアドレスをホストアプリケーションのモジュール連携設定に構成し、ホストアプリケーションを起動すると、ホストアプリケーションが   import(&#39;remote1/remoteModule&#39;)   のようなコードを実行する際、Webpackモジュール連携コンテナはそのアドレスを通じてリモートモジュールを読み込みます。同時に、そのリモートモジュールが宣言する共有依存が現在の共有スコープに既に存在するかどうかをチェックします。依存関係が利用できないか、バージョンに互換性がない場合、モジュール連携は自動的にホストアプリケーションのローカルフォールバック依存の読み込みにフォールバックします。   デモ オンラインデモ   デモ Github コード   疑問と回答:   質問   :    ホストアプリケーションとリモートアプリケーションの両方が共有依存lodashを設定していますが、ホストとリモートのlodashバージョンが一致しません。何が起こりますか？   回答   : バージョンが一致しない場合、   requiredVersion   は共有スコープ内のバージョンが要求バージョン範囲を満たしているかどうかをチェックします。満たしていない場合、ローカルのフォールバック依存が読み込まれます。   質問   :    singleton   設定オプションの目的は何ですか？また、バージョン交渉メカニズムはどのように機能しますか？   回答   :    singleton   は、この依存関係を共有スコープ内で単一バージョンとして共有するかどうかを指定するために使用されます。   true   に設定すると、共有スコープ内に存在できるバージョンは1つだけです。異なるバージョンの共有依存が複数存在する場合、Webpackはバージョン交渉メカニズムを使用します（共有依存の最も高いバージョンを使用しようとします。低いバージョンを設定したアプリケーションが先に読み込まれても、最も高いバージョンが使用されます）。そして、   singleton: true   が設定されているすべてのアプリケーションにそのバージョンの使用を強制します。lodashを例に挙げます：   /* App1 */// ...lodash: {  singleton: true, // シングルトン固有バージョン  requiredVersion: &#39;^1.0.0&#39;, // 1.0.0以上2.0.0未満}// .../* App2 */// ...lodash: {  singleton: true, // シングルトン固有バージョン  requiredVersion: &#39;^2.0.0&#39;, // 2.0.0以上3.0.0未満}// .../* App3 */// ...lodash: {  singleton: false, // 非シングルトンバージョン  requiredVersion: &#39;^3.0.0&#39;, // 3.0.0以上4.0.0未満}// ...   App1はシングルトン固有バージョンを使用し、lodashバージョンが   1.0.0以上2.0.0未満   であることを要求します。App2はシングルトン固有バージョンを使用し、lodashバージョンが   2.0.0以上3.0.0未満   であることを要求します。App3はシングルトン固有バージョンを使用せず、lodashバージョンが   3.0.0以上4.0.0未満   であることを要求します。すると、どちらが先に読み込まれても、App1とApp2はApp2で設定された最高バージョン   2.0.0   を使用します。App3のlodashは、使用可能なバージョンが見つからず、   singleton   が   false   に設定されているため、ローカルのフォールバックバージョン   3.0.0   を使用します。   質問   :    リモートアプリケーションは共有依存を使用したいだけで、自身のモジュールを公開するシナリオがありません。そのため、   shared   のみを設定し、   exposes   を設定していません。何が起こりますか？   回答   : リモートアプリケーションのリモートモジュールURLは生成されません。ホストアプリケーションがそのリモートモジュールURLにアクセスすると404エラーが返され、モジュール連携は有効になりません。常に自身のフォールバック依存のみを読み込みます。   質問   :    ホストアプリケーションはlodashをインストールし、共有依存を設定しています。リモートアプリケーションはnpm依存パッケージをインストールせずに、共有依存のみを設定できますか？   回答   : はい、できますが推奨されません。ホストアプリケーションとリモートアプリケーションの両方がlodashを共有依存として設定しているが、リモートアプリケーションがnpm依存パッケージをインストールしていない場合、リモートアプリケーションは次のように設定する必要があります：   // ...lodash: {  import: false, // ローカルフォールバック依存を読み込まず、共有スコープからのみ読み込む。  singleton: true, // シングルトン固有バージョン  requiredVersion: &#39;*&#39;, // 任意のバージョン}// ...   ただし、これは推奨されません。ネットワークやその他の理由でホストアプリケーションのlodashバージョンの読み込みに失敗した場合、リモートアプリケーションはエラーをスローし、ローカルフォールバック依存を使用しないためです。   質問   :    ホストアプリケーション設定では、リモートモジュールを動的インポート   import(&#39;{remotesKey}/{exposesKey}&#39;)   でインポートする必要がありますか？他の方法でインポートできますか？   回答   : この方法でインポートする必要があります。HTMLインポートなどの他の方法でもエラーが発生します。","categories":["guides"]},{"title":"デジタルシリアル番号でファイルを一括名前変更","url":"/ja/2025/10/25/batch-rename-files-with-digital-serial-numbers.html","content":"紹介   ファイルにデジタルシリアル番号を追加して一括名前変更します。例えば以下のようなファイル構造がある場合：   image_folder|- 0asu78rec5k1.jpg|- 7ajzsdb1b32a.jpg|- ib1bls015hsh.jpg...   スクリプトを実行すると、ファイル構造は以下のようになります：   image_folder|- image_01.jpg|- image_02.jpg|- image_03.jpg...   注：このスクリプトはファイルをアルファベット順にのみソートし、ファイルの作成時間やその他の要因は考慮しません。作成時間でソートしたい場合は、現在の順序でファイルを一括名前変更した後、このスクリプトを実行してください。   使い方です            ```shell    ./rename.sh ./image_folder -p \"image_\" -s 1 -z true    ```              ```cmd    .\\rename.cmd -d \".\\image_folder\" -p \"image_\" -s 1 -z true    ```     パラメータ   説明   デフォルト値   -d   ターゲットディレクトリ   現在のディレクトリ   -p   新しいファイル名のプレフィックス   空文字列   -s   シーケンスの開始番号   1   -z   10未満の番号にゼロを埋めるかどうか   true   -h   このヘルプメッセージを表示   なし   ソースコード            ```shell rename.sh    #!/bin/bash# 指定フォルダ内のすべてのファイルを一括名前変更し、カスタムプレフィックスと開始番号をサポート# デフォルトパラメータ設定TARGET_DIR=&quot;.&quot;prefix=&quot;&quot;start_number=1pad_zero=true# 用法情報を表示します。show_usage() {  echo &quot;使い方: $0 [-d ディレクトリパス] [-p ファイルプレフィックス] [-s 開始番号] [-z ゼロ埋め(true/false)]&quot;  echo &quot;&quot;  echo &quot;オプション:&quot;  echo &quot;  -d ディレクトリパス    処理するディレクトリを指定します（デフォルト: 現在のディレクトリ）&quot;  echo &quot;  -p ファイルプレフィックス  新しいファイル名のプレフィックス（デフォルト: 空）&quot;  echo &quot;  -s 開始番号  シーケンスの開始番号（デフォルト: 1）&quot;  echo &quot;  -z true/false  10未満の番号にゼロを埋めるかどうか（デフォルト: true）&quot;  echo &quot;  -h             このヘルプメッセージを表示&quot;  echo &quot;&quot;  echo &quot;例:&quot;  echo &quot;  $0 -d /path/to/dir -p img_ -s 1 -z true&quot;  echo &quot;  $0 -d /path/to/dir -p photo_ -s 10 -z false&quot;}# コマンドライン引数を解析while getopts &quot;d:p:s:z:h&quot; opt; do  case $opt in    d) TARGET_DIR=&quot;$OPTARG&quot; ;;    p) prefix=&quot;$OPTARG&quot; ;;    s) start_number=&quot;$OPTARG&quot; ;;    z)      if [ &quot;$OPTARG&quot; = &quot;false&quot; ]; then        pad_zero=false      else        pad_zero=true      fi      ;;    h) show_usage; exit 0 ;;    *) show_usage; exit 1 ;;  esacdone# ディレクトリが存在するか確認if [ ! -d &quot;$TARGET_DIR&quot; ]; then  echo &quot;エラー: ディレクトリ &#39;$TARGET_DIR&#39; が存在しません&quot;  exit 1fi# ターゲットディレクトリに移動cd &quot;$TARGET_DIR&quot; || exit 1echo &quot;&#39;$TARGET_DIR&#39;ディレクトリ内のファイルの名前変更を開始します...&quot;echo &quot;プレフィックス: &#39;$prefix&#39;&quot;echo &quot;開始番号: $start_number&quot;echo &quot;ゼロ埋め: $pad_zero&quot;echo &quot;&quot;# すべてのファイルをアルファベット順に並べて取得し、ディレクトリと現在のスクリプトを除外files=()script_name=&quot;$(basename &quot;$0&quot;)&quot;while IFS= read -r file; do  # ファイル（ディレクトリでない）であることを確認し、現在のスクリプトを除外  if [ -f &quot;$file&quot; ] &amp;&amp; [ &quot;$file&quot; != &quot;$script_name&quot; ]; then    files+=(&quot;$file&quot;)  fidone &lt; &lt;(ls -1 | grep -v &quot;^$script_name$&quot;)# 名前を変更するファイルがあるか確認if [ ${#files[@]} -eq 0 ]; then  echo &quot;エラー: ディレクトリ &#39;$TARGET_DIR&#39; に名前を変更できるファイルがありません&quot;  exit 1fi# ファイルシーケンスは指定された値から開始count=$start_number# ファイルを繰り返し処理して名前を変更for file in &quot;${files[@]}&quot;; do  # ファイルの拡張子を取得  extension=&quot;${file##*.}&quot;    # ゼロ埋めオプションに基づいてフォーマット文字列を設定  if [ &quot;$pad_zero&quot; = true ]; then    format=&quot;%02d&quot;  else    format=&quot;%d&quot;  fi    # 数字をフォーマット  new_name=&quot;${prefix}$(printf &quot;$format&quot; &quot;$count&quot;)&quot;    # ファイルに拡張子がある場合は、それを保持  if [ &quot;$file&quot; != &quot;$extension&quot; ]; then      new_name=&quot;${new_name}.${extension}&quot;  fi    # 新しいファイル名が既に存在するか確認  if [ -e &quot;$new_name&quot; ] &amp;&amp; [ &quot;$file&quot; != &quot;$new_name&quot; ]; then    echo &quot;警告: ファイル &#39;$new_name&#39; は既に存在します。&#39;$file&#39; の名前変更をスキップします&quot;    continue  fi    # 名前変更を実行  mv &quot;$file&quot; &quot;$new_name&quot;  echo &quot;名前変更: &#39;$file&#39; -&gt; &#39;$new_name&#39;&quot;    count=$((count + 1))doneecho &quot;&quot;echo &quot;名前変更が完了しました。合計 ${#files[@]} ファイルを処理しました&quot;```              ```cmd rename.cmd    @echo off    chcp 65001 >nul    setlocal enabledelayedexpansionrem ファイル一括名前変更スクリプト - コマンドライン引数をサポートrem デフォルトパラメータ設定set &quot;TARGET_DIR=.&quot;set &quot;prefix=pic_&quot;set &quot;start_num=1&quot;set &quot;zero_pad=true&quot;rem コマンドライン引数があるか確認:has_argsif &quot;%~1&quot;==&quot;&quot; (  echo &quot;%~1&quot;  call :show_usage  exit 0)if &quot;%~1&quot;==&quot;-h&quot; (  call :show_usage  exit 0)rem コマンドライン引数を解析:parse_argsif &quot;%~1&quot;==&quot;-d&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;TARGET_DIR=%~2&quot;    shift /1    shift /1    goto parse_args  ))if &quot;%~1&quot;==&quot;-p&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;prefix=%~2&quot;    shift /1    shift /1    goto parse_args  ))if &quot;%~1&quot;==&quot;-s&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;start_num=%~2&quot;    shift /1    shift /1    goto parse_args  ))if &quot;%~1&quot;==&quot;-z&quot; (  if not &quot;%~2&quot;==&quot;&quot; (    set &quot;zero_pad=%~2&quot;    shift /1    shift /1    goto parse_args  )):args_donerem ディレクトリが存在するか確認if not exist &quot;%TARGET_DIR%&quot; (  echo エラー: ディレクトリ &quot;%TARGET_DIR%&quot; が存在しません  exit 1)rem ターゲットディレクトリに移動pushd &quot;%TARGET_DIR%&quot; || (  echo エラー: ディレクトリ &quot;%TARGET_DIR%&quot; にアクセスできません  exit 1)echo &quot;%TARGET_DIR%&quot;ディレクトリ内のファイルの名前変更を開始します...rem 一時ファイルを使用してファイル名リストを保存set &quot;TEMP_FILE=%TEMP%\\rename_files_list.txt&quot;rem すべてのファイル（ディレクトリと現在のスクリプトを除く）をアルファベット順に取得dir /b /a-d | findstr /v /i &quot;%~nx0&quot; &gt; &quot;%TEMP_FILE%&quot;rem 名前を変更するファイルがあるか確認if not exist &quot;%TEMP_FILE%&quot; (  echo エラー: 一時ファイルを作成できません  goto cleanup)for %%I in (&quot;%TEMP_FILE%&quot;) do (  if %%~zI equ 0 (    echo エラー: ディレクトリ &quot;%TARGET_DIR%&quot; に名前を変更できるファイルがありません    goto cleanup  ))rem 開始番号をカウンターとして使用set &quot;count=%start_num%&quot;rem ファイルを繰り返し処理して名前を変更for /f &quot;usebackq delims=&quot; %%F in (&quot;%TEMP_FILE%&quot;) do (  rem ファイルの拡張子を取得  set &quot;file=%%F&quot;  set &quot;extension=&quot;  for %%E in (&quot;%%F&quot;) do set &quot;extension=%%~xE&quot;    rem ゼロ埋めオプションに基づいて番号をフォーマット  if &quot;!zero_pad!&quot;==&quot;true&quot; (    rem 10未満の番号のみゼロ埋め    if !count! lss 10 (      set &quot;formatted_count=0!count!&quot;    ) else (      set &quot;formatted_count=!count!&quot;    )  ) else (    set &quot;formatted_count=!count!&quot;  )    rem 新しいファイル名を構築  set &quot;new_name=!prefix!!formatted_count!&quot;    rem ファイルに拡張子がある場合は、それを保持  if not &quot;!extension!&quot;==&quot;&quot; (    set &quot;new_name=!new_name!!extension!&quot;  )    rem 新しいファイル名が既に存在するか確認  if exist &quot;!new_name!&quot; if not &quot;!new_name!&quot;==&quot;!file!&quot; (    echo 警告: ファイル &quot;!new_name!&quot; は既に存在します。&quot;!file!&quot; の名前変更をスキップします    set /a &quot;count+=1&quot;    goto next_file  )    rem 名前変更を実行  ren &quot;!file!&quot; &quot;!new_name!&quot;  echo 名前変更: &quot;!file!&quot; -^&gt; &quot;!new_name!&quot;    :next_file  rem カウンターを増加  set /a &quot;count+=1&quot;):cleanuprem 一時ファイルをクリーンアップif exist &quot;%TEMP_FILE%&quot; del &quot;%TEMP_FILE%&quot; 2&gt;nulrem 元のディレクトリに戻るpopdecho 名前変更が完了しましたexit 0rem ヘルプ情報を表示する関数:show_usageecho 使い方です: %~nx0 [オプション]echo オプション:echo   -d ディレクトリパス    処理するディレクトリを指定（デフォルト: 現在のディレクトリ）echo   -p プレフィックス      ファイルのプレフィックスを指定（デフォルト: pic_）echo   -s 開始番号            開始番号を指定（デフォルト: 1）echo   -z [true/false]        ゼロ埋めをするかどうか（デフォルト: true）echo   -h                     このヘルプメッセージを表示exit 0```","categories":["scripts"]},{"title":"こいっち、もう3歳なんだ","url":"/ja/2025/10/13/little-thing-turned-3.html","content":"","categories":["my-cat"]},{"title":"ESLint自動フォーマット仕様です","url":"/ja/2025/09/05/eslint-automatic-formatting-configuration.html","categories":["guides"]},{"title":"エビ入り卵炒め","url":"/ja/2025/04/04/shrimp-omelet.html","content":"材料   材料   量   むきエビ   100グラム   卵   4個   ネギ   適量   塩   適量   油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    卵にネギのみじん切りを加え、エビは水と塩で下味をつける   3.    卵を溶き、エビ（塩水ごと）を加える   4.    フライパンに油を熱し、卵を入れて固まったら炒める   5.    仕上げる   6.    盛り付ける","categories":["cookbooks"]},{"title":"チシャと豚肉の炒め物","url":"/ja/2025/04/04/stir-fried-meat-with-lettuce.html","content":"材料   材料   量   チシャ   2本   豚肉   400グラム   ニンニクの芽の葉   2本   ネギ   適量   ニンニク   適量   乾燥唐辛子   適量   花椒   適量   八角   適量   塩   適量   醤油   適量   濃口醤油   適量   オイスターソース   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：ネギ、ニンニク、唐辛子、花椒、八角   3.    チシャを縦半分に切り、さらにスライスする   4.    ニンニクの芽の葉をスライスする   5.    豚肉をスライスする   6.    油を入れて豚肉、調味料、濃口醤油を炒める   7.    炒めた豚肉を取り出しておく   8.    油を入れてチシャを炒め、豚肉を加えて炒める   9.    オイスターソース、醤油、塩を加えて炒める   10.    ニンニクの芽の葉を加えて炒める   11.    仕上げる   12.    盛り付ける","categories":["cookbooks"]},{"title":"ロメインレタス炒め","url":"/ja/2025/04/04/stir-fried-romaine.html","content":"材料   材料   量   ロメインレタス   500グラム   ピーマン   2個   油   適量   ニンニク   適量   塩   適量   醤油   適量   オイスターソース   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    ピーマンをカットし、ニンニクをみじん切りにして一緒に用意する   3.    油を入れてピーマンとニンニクを炒める   4.    ロメインレタスを加えて炒め、オイスターソース、醤油、塩を加えてさらに炒める   5.    仕上げる   6.    盛り付ける","categories":["cookbooks"]},{"title":"セロリとニンニクの芽と牛肉の炒め物","url":"/ja/2025/04/04/stir-fried-beef-with-celery.html","content":"材料   材料   量   セロリ   250グラム   ニンニクの芽   4本   煮込み牛肉   400グラム   油   適量   ネギ   適量   ニンニク   適量   唐辛子   適量   花椒   適量   塩   適量   醤油   適量   濃口醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：唐辛子、花椒、ネギ、ニンニク   3.    ピーマンをカットする   4.    ニンニクの芽の葉をカットする   5.    ニンニクの芽の根元を縦半分に切り、さらにカットする   6.    セロリをカットする   7.    牛肉をスライスする   8.    ニンニクの芽の根元とセロリを一緒に用意する   9.    ニンニクの芽の葉と牛肉を一緒に用意する   10.    油を入れてニンニクの芽の根元とセロリを炒める   11.    調味料を加えて炒める   12.    ニンニクの芽の葉と牛肉を加えて火が通るまで炒める   13.    醤油、濃口醤油、塩を加えて炒める   14.    仕上げる   15.    盛り付ける","categories":["cookbooks"]},{"title":"シイタケとニンニクの芽と豚肉の炒め物","url":"/ja/2025/03/17/stir-fried-meat-with-mushrooms-and-garlic-sprouts.html","content":"材料   材料   量   シイタケ   500グラム   ニンニクの芽   4本   豚肉   500グラム   油   適量   ネギ   適量   ニンニク   適量   唐辛子   適量   花椒   適量   塩   適量   醤油   適量   濃口醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：花椒、唐辛子、ネギ、ニンニク   3.    シイタケをスライスする   4.    ニンニクの芽をカットする   5.    豚肉を細切りにする   6.    シイタケを下茹でしておく   7.    油を入れて豚肉を炒め、濃口醤油で色付けする   8.    肉を端に寄せ、調味料を加えて香りを出す   9.    シイタケを加えて炒める   10.    ニンニクの芽、塩、醤油を加えて均一に炒める   11.    仕上げる   12.    盛り付ける","categories":["cookbooks"]},{"title":"NPM 更新パケットコマンドです","url":"/ja/2024/11/01/npm-command.html","content":"NPMコマンド   # 更新可能な依存ライブラリを確認npm outdated# 依存ライブラリxxxの最新バージョン情報を確認npm view xxx versions# またはnpm info xxx# xxxの1.0.0バージョンをdependenciesにインストール（@latestは最新版を意味）npm install xxx@1.0.0 --save# 省略形npm i xxx@1.0.0 -S# xxxを最新バージョンに更新しdevDependenciesに保存npm update xxx --save-dev# 依存ライブラリの全ツリーを表示（依存ライブラリの依存関係を含む）npm list# package.jsonに登録された依存ライブラリのみ表示（devDependenciesを含む）npm list --depth=0   npm-checkで依存ライブラリの更新を確認   npm install -g npm-check  # まずnpm-checkをグローバルインストールnpm-check -u              # 現在のプロジェクトのパッケージ更新を確認npm-check -u -g           # グローバルインストール済みパッケージの更新を確認   npm-check -u   は全ての更新を表示します。矢印キーで移動、スペースキーで選択・解除、選択後エンターキーを押してください。   NPMインストールエラーの解決方法   postinstall error:   環境   バージョン   windows   10   node   20.14.0   pnpm   9.4.0   初めて    pnpm install    または    npm install    を実行すると、PNPMが次のエラーを報告します：npm postinstall failed command not found node ./scripts/postinstall.js   解決策1:   コマンドを実行します   rimraf .\\node_modules\\   npm cache clean --force   pnpm store prune   解決策2:   エラーが発生したプラグインの package.json ファイルを見つけます   package.json の scripts.postinstall のコマンドをどこかにメモし、コマンドを    pnpm --version    に変更します   その後、一度    pnpm install    を実行すると、エラーのあったプラグインの postinstall が正常に実行されます   エラーが発生したプラグインの package.json ファイルのディレクトリにそれぞれ移動します   それぞれのプラグインで元の postinstall コマンドを実行します   pnpm dev    で正常に起動できます。。。   NPM Install Error Solution   node-pre-gyp error:   プラグイン   バージョン   linux   13.6.0   node   18.20.4   npm   10.7.0   初めて    npm install    を実行すると、npm error node-pre-gyp が発生することがあります。   原因:   https://github.com/mozilla/pdf.js#user-content-getting-the-code   On MacOS M1/M2 you may see some node-gyp-related errors when running npm install. This is because one of our dependencies, &quot;canvas&quot;, does not provide pre-built binaries for this platform and instead npm will try to build it from source. Please make sure to first install the necessary native dependencies using brew:    https://github.com/Automattic/node-canvas#compiling   .   解決策:   https://github.com/Automattic/node-canvas#compiling    の解決方法を参考にし、環境に画像プラグインのサポートを追加します。   プロジェクト内の canvas（パッケージ名: node-canvas）関連のすべてのプラグインを削除します。","categories":["notes"]},{"title":"Git 設定","url":"/ja/2024/01/25/git-configuration.html","content":"Git 設定取得コマンド   # グローバル + ローカルのGit設定を取得git config --list# グローバルGit設定を取得git config --global --list   Git 設定   # ファイル名の大文字・小文字の区別を設定git config --global core.ignorecase false# true: Gitはファイル名の大文字・小文字の違いを無視します（例：大文字・小文字を区別しないシステムではREADME.mdとreadme.mdは同じファイルと見なされます）# false: Gitはファイル名の大文字・小文字を区別します# 改行コードの自動変換を設定git config --global core.autocrlf false# true: CRLFをLFに自動変換、またはチェックアウト時にCRLFに変換# false: 改行コードの変換を行わない# 混在する改行コードのチェックを設定git config --global core.safecrlf true# warn（デフォルト）: 混在する改行コードを含むファイルをコミットする際に警告を表示# true: 混在する改行コードを含むファイルのコミットを拒否（Fatalエラーが表示されます）# false: 混在する改行コードを含むファイルのコミットを許可   Git プロキシ   # Git のプロキシ設定を確認git config --global --get http.proxygit config --global --get https.proxy# Git プロキシを設定git config --global http.proxy http://127.0.0.1:7890git config --global https.proxy http://127.0.0.1:7890# Git プロキシを解除git config --global --unset http.proxygit config --global --unset https.proxy   .gitattributes    ファイル設定   # デフォルトの動作を設定（core.autocrlfが未設定の場合に適用）* text=auto# 標準化し、チェックアウト時にローカルの改行コードに変換するテキストファイルを指定*.c text*.h text# チェックアウト時に常にCRLF改行コードを使用するファイルを指定*.sln text eol=crlf# 本当のバイナリファイル（変更すべきでないもの）を指定*.png binary   Gvim 設定   _vimrcファイルを開き、以下の設定を追加してください：   # ^Mと$記号を表示する設定:set encoding=utf-8:scriptencoding utf-8:set binary:set list:set listchars=tab:&gt;-,eol:$,space:·","categories":["notes"]},{"title":"一般的なシステムコマンド","url":"/ja/2023/11/23/common-system-commands.html","content":"ファイルとディレクトリの削除            ```shell    # node_modules ディレクトリを強制的に再帰削除    rm -rf ./node_modules# ファイルを削除rm filename.txt# ディレクトリを再帰的に削除。-r は再帰的削除で、ディレクトリとその内容を削除するために使用rm -r folder_name# ファイルを強制的に削除。-f は確認なしで強制削除rm -f filename.txt# 安全な削除（インタラクティブ確認）。-i：各ファイルを削除する前に確認を求めるrm -i filename.txtrm -ri folder_name```              ```powershell    # node_modules ディレクトリを強制的に再帰削除    rm -r -Force .\\node_modules# ファイルを削除Remove-Item filename.txt# エイリアスrm または rd# フォルダを削除rm -r folder_name# ファイルとディレクトリを強制的に再帰削除。-Recurse または -r は再帰削除、-Force は確認なしで強制削除rm -Recurse -Force -Path folder_name# 安全な削除（確認付き）。-Confirm はファイルを削除する前に確認を求めるrm important_file.txt -Confirm# 現在のフォルダから、.txt ファイル拡張子を持ち、名前に important を含まないすべてのファイルを削除。rm * -Include *.txt -Exclude *important*```              ```cmd    REM node_modules ディレクトリを強制的に再帰削除    rd /s /q .\\node_modulesREM ファイルを削除del filename.txtREM ディレクトリを削除rd folder_nameREM フォルダを再帰的に削除。/s はディレクトリとその内容を再帰的に削除rd /s .\\folder_nameREM 確認なしでディレクトリツリーを再帰的に削除。/q はクワイエットモードrd /s /q .\\folder_name```     ファイルとフォルダの表示            ```shell    # 基本コマンド    ls# 詳細リストを表示。パラメータの組み合わせ（-l はリスト表示、-a は隠しファイルを表示）ls -la# 人間に読みやすい形式でファイルサイズを表示（-l と組み合わせて使用）ls -lh# 時間でソート。-t は時間でソート、-r は逆順（最新が最後）ls -ltr# ファイルサイズでソート。-S はファイルサイズでソート、-r は逆順（最大が最後）ls -lSr# すべてのサブディレクトリを再帰的に表示ls -R```              ```powershell    # 基本コマンド    Get-ChildItem# エイリアスls または dir# 出力をフォーマットls | Format-Table Name, Length, LastWriteTime# 隠しファイルを表示ls -Force# すべてのサブディレクトリを再帰的に表示 -Recurse または -rls -r# 拡張子でフィルタリングls *.txt または ls -Filter *.txt```              ```cmd    REM 基本コマンド    dirREM 隠しファイルやシステムファイルを含むすべてのファイルを表示。dir /aREM 時間でソート。/o は時間でソート、d は日付/時間、/r は逆順（最新が最後）dir /od /rREM サイズでソート。/o はサイズでソート、s はファイルサイズ、/r は逆順（最大が最後）dir /os /rREM 隠しディレクトリを含むすべてのサブディレクトリを再帰的に表示。dir /s```     ローカル IP アドレスの表示            ```shell    # すべてのインターフェースの詳細情報を表示    ip addr show# IPv4 アドレスのみを表示hostname -I```              ```powershell    # このコマンドはすべての IPv4 アドレスをリストし、ローカルループバックアドレス (127.0.0.1) を除外し、対応するネットワーク接続名も表示します。    Get-NetIPAddress | Where-Object {$_.AddressFamily -eq 'IPv4' -and $_.IPAddress -ne '127.0.0.1'} | Format-Table InterfaceAlias, IPAddress    # CMD 互換、簡単に表示ipconfig```              ```cmd    REM 古典的なコマンド、基本情報を表示    ipconfigREM すべての詳細情報を表示ipconfig /allREM IPv4 アドレスのみを表示ipconfig | findstr /i &quot;IPv4&quot;```     ポートの使用状況の確認とプロセスの終了            ```shell    # ポート 8080 を使用しているプロセスを検索    lsof -i :8080    # プロセスを終了kill -9 &lt;プロセスID&gt;# fuser コマンドでプロセスを終了。-k はプロセスを終了、-i はプロセスを終了する前にユーザーに確認を求め、-u はプロセス所有者を表示。fuser -ki -u 8080/tcp```              ```powershell    # ポート 8080 を使用しているプロセスを検索    Get-Process -Id (Get-NetTCPConnection -LocalPort 8080).OwningProcess# プロセスを終了Stop-Process -Id (Get-NetTCPConnection -LocalPort 8080).OwningProcess```              ```cmd    REM ポート 8080 を使用しているプロセスを検索    netstat -ano | findstr 8080REM プロセスを終了taskkill /F /PID &lt;プロセスID&gt;```","categories":["notes"]},{"title":"運用の未来はプラットフォームエンジニアリング","url":"/ja/2023/07/19/platform-engineering.html","content":"","categories":["reprints"]},{"title":"ソフトウェアがソフトウェアを食べる、プログラミングの仕事は増えるのか？","url":"/ja/2023/07/07/will-programmers-increase.html","content":"","categories":["reprints"]},{"title":"ビッグプレートチキン","url":"/ja/2022/08/16/big-plate-chicken.html","content":"材料   材料   分量   鶏肉   1羽   ジャガイモ   2個   ピーマン   2個   油   適量   砂糖   適量   長ネギ   適量   生姜   適量   ニンニク   適量   唐辛子   適量   花椒   適量   八角   適量   月桂葉   適量   桂皮   適量   塩   適量   醤油   適量   濃口醤油   適量   ラー油   適量   料理酒   適量   作り方   画像   手順   1.    材料を準備する   2.    調味料を準備：ニンニク、生姜、長ネギ、唐辛子、花椒、八角、月桂葉、桂皮   3.    鶏肉を湯通しし、生姜と料理酒を加える   4.    ジャガイモを乱切りにする   5.    鶏肉のアクを取り除き、引き上げる   6.    油を強火で熱し、砂糖または氷砂糖を溶かす   7.    鶏肉を加えて炒め、香りを立てる   8.    調味料を加えて炒める   9.    塩、醤油、濃口醤油、ラー油、料理酒を加えて均一に炒める   10.    ジャガイモを加えて炒め、ジャガイモが浸るくらいの水を加えて蓋をする   11.    途中でピーマンを加え、強火で汁をとばす   12.    盛り付ける","categories":["cookbooks"]},{"title":"言語タグ","url":"/ja/2022/04/10/language-tags.html","content":"Language Tag   ISO 639-1   言語   地域   説明   ar-SA   ar   Arabic   Saudi Arabia   サウジアラビアのアラビア語   bn-BD   bn   Bangla   Bangladesh   バングラデシュのベンガル語   bn-IN   bn   Bangla   India   インドのベンガル語   cs-CZ   cs   Czech   Czech Republic   チェコ共和国のチェコ語   da-DK   da   Danish   Denmark   デンマークのデンマーク語   de-AT   de   German   Austria   オーストリアのドイツ語   de-CH   de   German   Switzerland   スイスのドイツ語   de-DE   de   German   Germany   ドイツの標準ドイツ語   el-GR   el   Greek   Greece   ギリシャの現代ギリシャ語   en-AU   en   English   Australia   オーストラリア英語   en-CA   en   English   Canada   カナダ英語   en-GB   en   English   United Kingdom   イギリス英語   en-IE   en   English   Ireland   アイルランド英語   en-IN   en   English   India   インド英語   en-NZ   en   English   New Zealand   ニュージーランド英語   en-US   en   English   United States   アメリカ英語   en-ZA   en   English   South Africa   南アフリカ英語   es-AR   es   Spanish   Argentina   アルゼンチンのスペイン語   es-CL   es   Spanish   Chile   チリのスペイン語   es-CO   es   Spanish   Columbia   コロンビアのスペイン語   es-ES   es   Spanish   Spain   スペイン（中北部）のカスティーリャ語   es-MX   es   Spanish   Mexico   メキシコのスペイン語   es-US   es   Spanish   United States   アメリカのスペイン語   fi-FI   fi   Finnish   Finland   フィンランドのフィンランド語   fr-BE   fr   French   Belgium   ベルギーのフランス語   fr-CA   fr   French   Canada   カナダのフランス語   fr-CH   fr   French   Switzerland   スイスのフランス語   fr-FR   fr   French   France   フランスの標準フランス語   he-IL   he   Hebrew   Israel   イスラエルのヘブライ語   hi-IN   hi   Hindi   India   インドのヒンディー語   hu-HU   hu   Hungarian   Hungary   ハンガリーのハンガリー語   id-ID   id   Indonesian   Indonesia   インドネシアのインドネシア語   it-CH   it   Italian   Switzerland   スイスのイタリア語   it-IT   it   Italian   Italy   イタリアの標準イタリア語   ja-JP   ja   Japanese   Japan   日本語（日本）   ko-KR   ko   Korean   Republic of Korea   韓国の韓国語   nl-BE   nl   Dutch   Belgium   ベルギーのオランダ語   nl-NL   nl   Dutch   The Netherlands   オランダの標準オランダ語   no-NO   no   Norwegian   Norway   ノルウェーのノルウェー語   pl-PL   pl   Polish   Poland   ポーランドのポーランド語   pt-BR   pt   Portuguese   Brazil   ブラジルのポルトガル語   pt-PT   pt   Portuguese   Portugal   ポルトガルのヨーロッパポルトガル語   ro-RO   ro   Romanian   Romania   ルーマニアのルーマニア語   ru-RU   ru   Russian   Russian Federation   ロシアのロシア語   sk-SK   sk   Slovak   Slovakia   スロバキアのスロバキア語   sv-SE   sv   Swedish   Sweden   スウェーデンのスウェーデン語   ta-IN   ta   Tamil   India   インドのタミル語   ta-LK   ta   Tamil   Sri Lanka   スリランカのタミル語   th-TH   th   Thai   Thailand   タイのタイ語   tr-TR   tr   Turkish   Turkey   トルコのトルコ語   zh-CN   zh   Chinese   China   中国本土、簡体字   zh-HK   zh   Chinese   Hong Kong   香港、繁体字   zh-TW   zh   Chinese   Taiwan   台湾、繁体字","categories":["notes"]},{"title":"シイタケとラムチョップの煮込み","url":"/ja/2021/10/19/stewed-lamb-chop-with-mushroom.html","content":"材料   材料   量   ラムチョップ   6本   シイタケ   300グラム   油   多め   塩   適量   唐辛子   適量   花椒   適量   八角   適量   クミン   適量   ラムチョップは必ず下茹でしてアクを取ること。そうしないと臭みが強くなる。   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料皿：唐辛子、花椒、八角、クミン   3.    ラムチョップを水に浸して血抜きする   4.    ぬるま湯で下茹でし、取り出す   5.    調味料と一緒に中火でラムチョップを炒める   6.    水を加え、切ったシイタケと塩を加える   7.    中火で30分煮込む   8.    盛り付ける","categories":["cookbooks"]},{"title":"ピーマンと豚肉の炒め物","url":"/ja/2021/09/05/green-pepper-parch-meat.html","content":"材料   材料   量   ピーマン   300グラム   豚肉   120グラム   油   適量   ニンニク   適量   塩   適量   醤油   適量   濃口醤油   少量   料理酒   適量   肉を柔らかく、ピーマンを美味しく仕上げるコツ：強火ではなく、全工程中火で調理すること。   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：ニンニク、唐辛子   3.    ピーマンを細切りにする   4.    豚肉を細切りにし、水気を取って、でんぷん・醤油・料理酒を加える   5.    粘り気が出るまで混ぜて漬けておく   6.    油を中火で熱し、調味料を入れて香りを出す   7.    豚肉を入れて炒める   8.    ピーマンを加えて均一に炒める   9.    塩と濃口醤油を加えて炒める   10.    仕上げる   11.    盛り付ける","categories":["cookbooks"]},{"title":"トマトとソーセージの卵炒め","url":"/ja/2021/06/14/scrambled-egg-with-tomato-sausage.html","content":"材料   材料   量   トマト   250グラム   卵   2個   ソーセージ   60グラム   油   適量   乾燥唐辛子   適量   塩   適量   氷砂糖   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    トマトの底を切り落とし、湯むきしやすくする   3.    沸騰したお湯でトマトの皮が割れるまで茹でる   4.    トマトの皮をむく   5.    トマトを小さく切る   6.    卵を割り入れ、ネギのみじん切りと混ぜる   7.    ソーセージをスライスし、乾燥唐辛子と一緒に用意する   8.    フライパンを熱し、油が煙を上げたら卵液を入れる   9.    ソーセージと唐辛子を加えて均一に炒める   10.    トマトを加えて均一に炒め、塩を加える（トマトはヘラで潰す）   11.    仕上げる   12.    盛り付ける","categories":["cookbooks"]},{"title":"JavaScript ドキュメントコメント規約","url":"/ja/2021/04/28/javascript-document-convertions.html","content":"Type 構文   型名   構文例   説明   Symbol name   {string}, {myNamespace.MyClass}   シンボル名を指定します。   Multiple types   {number|boolean}   値が複数の型のいずれかであることを意味し、&quot;|&quot; で型のリストを区切ります。   Arrays   {string[]}, {MyClass[]}   string[]    は文字列配列、       {MyClass[]}    は MyClass インスタンスの配列を表します。   Objects   {a: number, b: string, c}     // or     {object} myObj     {number} myObj.a     {string} myObj.b     {any} myObj.c   オブジェクト &quot;MyObj&quot; に &#39;a&#39; (数値)、&#39;b&#39; (文字列)、&#39;c&#39; (任意型) のプロパティがあることを示します。    プロパティが既知のオブジェクトには Closure Compiler 構文で型を記述できます。    各プロパティを個別に記述することもでき、詳細な説明が可能です。   Nullable type   {?number}   指定した型または null であることを示します。   Non-nullable type   {!number}   指定した型であり、null にはなりません。   Variable number of that type   @param {...number} num   可変個数の引数を受け取ることを示し、型を指定します。   Optional parameter   @param {number} [foo=1]   パラメータがオプションであること、またデフォルト値も指定できます。   Callbacks   @callback myCallback     @param {number} x - ...   @callback タグでコールバックを示します。    @typedef タグと似ていますが、コールバックの型は常に &quot;function&quot; です。   Type definitions   @typedef {object} PropertiesHash     @property {string} id     @property {string} name     @property {number} age   @typedef タグで複雑な型を記述できます。   よく使うコメントキーワード   コメント名   別名   説明   @param   @argument, @arg   関数に渡されるパラメータを記述します。   @return   @returns   関数の戻り値を記述します。   @method   @function, @func   関数やメソッドを記述します。   @typedef   独自型を記述します。   @property   @prop   オブジェクトのプロパティを記述します。   @callback   コールバック関数を記述します。   @author   プロジェクトの作者を指定します。   @copyright   ファイルの著作権情報を記述します。   @description   識別子の説明を記述します。   @param   関数に渡されるパラメータを記述します。   別名： @arg，@argument   /** * @param {string} somebody - Somebody&#39;s name. */function sayHello(somebody) {  alert(&#39;Hello &#39; + somebody);}   パラメータがオブジェクトで特定のプロパティを持つ場合：   /** * Assign the project to an employee. * @param {object} employee            - The employee who is responsible for the project. * @param {string} employee.name       - The name of the employee. * @param {string} employee.department - The employee&#39;s department. */Project.prototype.assign = function(employee) { ... };   パラメータのプロパティ値が配列の場合：   /** * Assign the project to a list of employees. * @param {object[]} employees            - The employees who are responsible for the project. * @param {string} employees[].name       - The name of an employee. * @param {string} employees[].department - The employee&#39;s department. */Project.prototype.assign = function(employees) { ... };   オプションパラメータとデフォルト値：   /** * @param {string} [somebody=John Doe] - Somebody&#39;s name. */function sayHello(somebody) {  if (!somebody) {    somebody = &#39;John Doe&#39;;  }  alert(&#39;Hello &#39; + somebody);}   1つまたは複数の型を許容する場合：   /** * @param {string|string[]} [somebody=John Doe] - Somebody&#39;s name, or an array of names. */function sayHello(somebody) {  if (!somebody) {    somebody = &#39;John Doe&#39;;  } else if (Array.isArray(somebody)) {    somebody = somebody.join(&#39;, &#39;);  }  alert(&#39;Hello &#39; + somebody);}   パラメータがコールバック関数の場合：   /** * @param {requestCallback} cb *//** * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage */function doSomethingAsynchronously(cb) { ... }   @return   関数の戻り値を記述します。   別名： @returns   /** * Returns the sum of a and b * @param {number} a * @param {number} b * @param {boolean} retArr If set to true, the function will return an array * @return {number|array} Sum of a and b or an array that contains a, b and the sum of a and b. */function sum(a, b, retArr) {  if (retArr) {    return [a, b, a + b];  }  return a + b;}   @method   関数やメソッドを記述します。   別名： @function, @func   /** * Returns the sum of a and b * @method sum * @param {number} a * @param {number} b * @return {number} Sum of a and b or an array that contains a, b and the sum of a and b. */function sum(a, b) {  return a + b;}   @typedef   独自型を記述します。   /** * The complete Triforce, or one or more components of the Triforce. * @typedef {Object} WishGranter~Triforce * @property {boolean} hasCourage - Indicates whether the Courage component is present. * @property {boolean} hasPower   - Indicates whether the Power component is present. * @property {boolean} hasWisdom  - Indicates whether the Wisdom component is present. */ /** * A class for granting wishes, powered by the Triforce. * @class * @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects * containing all three components of the Triforce. */function WishGranter() {}   @property   オブジェクトのプロパティを記述します。   /** * @namespace * @property {object}  defaults               - The default values for parties. * @property {number}  defaults.players       - The default number of players. * @property {string}  defaults.level         - The default level for the party. * @property {object}  defaults.treasure      - The default treasure. * @property {number}  defaults.treasure.gold - How much gold the party starts with. */var config = {  defaults: {    players: 1,    level: &#39;beginner&#39;,    treasure: {      gold: 0    }  }};   @callback   コールバック関数を記述します。   /** * @class */function Requester() {}/** * Send a request. * @param {Requester~requestCallback} cb - The callback that handles the response. */Requester.prototype.send = function(cb) {  // code};/** * This callback is displayed as part of the Requester class. * @callback Requester~requestCallback * @param {number} responseCode * @param {string} responseMessage */   @author   プロジェクトの作者を指定します。   /** * @author Zane Liu &lt;liuzane@example.com&gt; */function MyClass() {}   @copyright   著作権情報を記述します。   /** * @file This is my cool script. * @copyright Zane Liu 2021 */   @description   識別子の説明を記述します。   /** * @param {number} a * @param {number} b * @returns {number} * @description Add two numbers. */function add(a, b) {  return a + b;}","categories":["notes"]},{"title":"スパイシーエビ炒め","url":"/ja/2020/12/27/fried-shrimp-with-chilli.html","content":"材料   材料   量   クルマエビ   10尾   油   適量   ネギ   適量   ニンニク   適量   ショウガ   適量   唐辛子   適量   ローレル   適量   塩   適量   水   半カップ   醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    ネギはぶつ切り、ショウガはスライス、ニンニクはみじん切りにして皿に盛る   3.    調味液：水、醤油、塩、ローレル   4.    エビを洗い、背ワタを取る   5.    フライパンに油を熱し、エビを入れて両面がきれいな赤色になりエビ油が出たら取り出す（ヘラで軽く押すと赤い油がよく出る）   6.    エビ油の残ったフライパンにネギとショウガを入れて香りを出す   7.    炒めたエビを戻し、調味液を加える   8.    強火で煮詰める   9.    盛り付ける","categories":["cookbooks"]},{"title":"localStorage","url":"/ja/2020/12/10/local-storage.html","content":"setStorage(key, data, hours)   localStorage を設定します   /*** @method setStorage* @param {string} key* @param {any} data* @param {number} hours* @return {boolean}*/function setStorage(key, data, hours) {  let expires;  if (!key || !data) {    console.error(&#39;[localStorage Error]: Key and Data is a must parameter&#39;);    return false;  }  expires = hours ? new Date().getTime() + 1000 * 60 * 60 * hours : new Date(0).getTime();  localStorage.setItem(key, JSON.stringify({ data, expires }));  return true;}   getStorage(key)   localStorage を取得します   /*** @method getStorage* @param {string} key* @return {boolean|null}*/function getStorage(key) {  let data, nowTime = new Date().getTime();  if (!key) console.error(&#39;[localStorage Error]: Key is a must parameter&#39;);  try {    data = JSON.parse(localStorage.getItem(key));  } catch (error) {    return localStorage.getItem(key);  }  if (!data) return null;  if (!Boolean(data.expires) || data.expires &gt;= nowTime) {    return data.data;  } else {    localStorage.removeItem(key);    return null;  }}   clearStorage(key)   localStorage をクリアします   /*** @method clearStorage* @param {string} key*/function clearStorage(key) {  if (key) {    localStorage.removeItem(key);  } else {    localStorage.clear();  }}","categories":["notes"]},{"title":"Cookies","url":"/ja/2020/12/10/cookies.html","content":"setCookie(params)   Cookieを設定する   /*** @method setCookie* @param {object} options* @param {string} options.key* @param {string} options.value* @param {number} [options.hours]* @param {string} [options.path]   - path: &#39;/&#39;* @param {string} [options.domain] - domain: document.domain*/function setCookie(options) {  let time = new Date(), expires = &#39;&#39;, path = &#39;&#39;, domain = &#39;&#39;;  if (!options.key || !options.value) {    console.error(&#39;[Cookie Error]: key, value must be set.&#39;);    return;  }  if (options.hours) {    try {      Number(options.hours);    } catch (e) {      console.error(&#39;[Cookie Error]: expires must is number.&#39;);    }    time.toGMTString(time.setTime(time.getTime() + 1000 * 60 * 60 * options.hours));    expires = &#39;expires=&#39; + time + &#39;;&#39;;  }  if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;  if (options.domain) domain = &#39;domain=&#39; + options.domain;  document.cookie = options.key + &#39;=&#39; + options.value + &#39;;&#39; + expires + path + domain;}   getCookie(key)   Cookieを取得する   /*** @method getCookie* @param {string} key * @return {undefined|string|null}*/function getCookie(key) {  if (!key) {    console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);    return;  }  const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;);  const result = document.cookie.match(regexp);  const value = result ? result[0].replace(/[; ]/g, &#39;&#39;).split(&#39;=&#39;)[1] : null;  return value;}   deleteCookie(param)   /*** @method deleteCookie* @param {string|object} param* @param {string} param.key* @param {string} [param.path]* @param {string} [param.domain]* @return {undefined|string|null}*/function deleteCookie(param) {  const options = typeof param === &#39;object&#39; ? param : {};  const key = typeof param === &#39;string&#39; ? param : options.key;  if (!key) {    console.error(&#39;[Cookie Error]: key is &#39; + (typeof key) + &#39;.&#39;);    return;  }  if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;  if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;  const regexp = new RegExp(&#39;(^|; )&#39; + key + &#39;=.*?(;|$)&#39;);  const result = document.cookie.match(regexp);  const item = result ? result[0].replace(/[; ]/g, &#39;&#39;) : &#39;&#39;;  const time = new Date();  time.toGMTString(time.setTime(0));  document.cookie = item + &#39;;expires=&#39; + time + &#39;;&#39; + options.path + options.domain;}   clearCookie(params)   Cookieを全て削除する   /*** @method clearCookie* @param {object} [options]* @param {string} [options.path]* @param {string} [options.domain]*/function clearCookie(options) {  let arr = document.cookie.split(&#39;;&#39;), path = &#39;&#39;, domain = &#39;&#39;;  if (!options) options = {};  if (options.path) path = &#39;path=&#39; + options.path + &#39;;&#39;;  if (options.domain) domain = &#39;domain=&#39; + options.domain + &#39;;&#39;;  for (let i = 0; i &lt; arr.length; i++) {    let key = arr[i].substring(0, arr[i].indexOf(&#39;=&#39;));    document.cookie = key + &#39;=0;expires=Thu, 01 Jan 1970 00:00:00 GMT;&#39; + path + domain;  }}","categories":["notes"]},{"title":"JavaScript ユーティリティ関数","url":"/ja/2020/12/10/javascript-utility-functions.html","content":"メソッドコレクション：   メソッド名   説明   typeOf   データ型を検証します。   deepCopy   ディープコピー。   formatDate   日付フォーマット。   uuid   UUIDを生成します。   download   ファイルをダウンロードします。   getUrlArg   名前でパスパラメータを取得します。   getUrlQuery   パスパラメータをオブジェクト形式に変換します。   setUrlQuery   オブジェクト形式をパスパラメータに変換します。   getDeepValueOfObject   オブジェクトの深い値を取得します。   toThousands   千の区切り形式に変換します。   hyperscript   JSでHTMLノードを生成します。   typeOf        /*** データ型を検証します。* @method typeOf* @param {any} obj* @return {string}*/export function typeOf(obj) {  const TypeMap = {    &#39;[object Boolean]&#39;: &#39;boolean&#39;,     &#39;[object Number]&#39;: &#39;number&#39;,    &#39;[object String]&#39;: &#39;string&#39;,    &#39;[object Function]&#39;: &#39;function&#39;,    &#39;[object Array]&#39;: &#39;array&#39;,    &#39;[object Date]&#39;: &#39;date&#39;,    &#39;[object RegExp]&#39;: &#39;regexp&#39;,    &#39;[object Undefined]&#39;: &#39;undefined&#39;,    &#39;[object Null]&#39;: &#39;null&#39;,    &#39;[object Object]&#39;: &#39;object&#39;  };  const toString = Object.prototype.toString;  return TypeMap[toString.call(obj)];}console.log(typeOf(&#39;abc&#39;)); // stringconsole.log(typeOf([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])); // arrayconsole.log(typeOf({ a: 1, b: 2, c: 3 })); // object          enum TypeValueEnum {  Boolean = &#39;boolean&#39;,  Number = &#39;number&#39;,  String = &#39;string&#39;,  Function = &#39;function&#39;,  Array = &#39;array&#39;,  Date = &#39;date&#39;,  RegExp = &#39;regexp&#39;,  Undefined = &#39;undefined&#39;,  Null = &#39;null&#39;,  Object = &#39;object&#39;}/*** データ型を検証します。* @method typeOf* @param {unknown} obj* @return {TypeValueEnum}*/export function typeOf(obj: unknown): TypeValueEnum {  const TypeMap: Record&lt;string, TypeValueEnum&gt; = {    &#39;[object Boolean]&#39;: TypeValueEnum.Boolean,     &#39;[object Number]&#39;: TypeValueEnum.Number,    &#39;[object String]&#39;: TypeValueEnum.String,    &#39;[object Function]&#39;: TypeValueEnum.Function,    &#39;[object Array]&#39;: TypeValueEnum.Array,    &#39;[object Date]&#39;: TypeValueEnum.Date,    &#39;[object RegExp]&#39;: TypeValueEnum.RegExp,    &#39;[object Undefined]&#39;: TypeValueEnum.Undefined,    &#39;[object Null]&#39;: TypeValueEnum.Null,    &#39;[object Object]&#39;: TypeValueEnum.Object  };  const toString: string = Object.prototype.toString;  return TypeMap[toString.call(obj)];}console.log(typeOf(&#39;abc&#39;)); // stringconsole.log(typeOf([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])); // arrayconsole.log(typeOf({ a: 1, b: 2, c: 3 })); // object     deepCopy   このメソッドは    typeOf()    メソッドと組み合わせて使用する必要があります。        /** * ディープコピー。 * @method deepCopy * @param {array|object} data * @return {array|object} */export function deepCopy(data) {  const type = typeOf(data);  switch (type) {    case &#39;array&#39;: {      const array = [];      for (let index = 0; index &lt; data.length; index++) {        array.push(deepCopy(data[index]));      }      return array;    }    case &#39;object&#39;: {      const object = {};      for (const key in data) {        if (Object.prototype.hasOwnProperty.call(data, key)) {          object[key] = deepCopy(data[key]);        }      }      return object;    }    default:      return data;  }}const obj1 = { a: 1, b: 2, c: 3 };const obj2 = deepCopy(obj1);console.log(obj1 === obj2); // false          /** * ディープコピー。 * @method deepCopy * @param {array|object} data * @return {array|object} */export function deepCopy&lt;T&gt;(data: T): T {  const type: TypeValueEnum = typeOf(data);  switch (type) {    case TypeValueEnum.Array: {      const array: unknown[] = [];      for (let index = 0; index &lt; (data as unknown[]).length; index++) {        array.push(deepCopy(data[index]));      }      return array as T;    }    case TypeValueEnum.Object: {      const object: Record&lt;string, unknown&gt; = {};      for (const key in data) {        if (Object.prototype.hasOwnProperty.call(data, key)) {          object[key] = deepCopy(data[key]);        }      }      return object as T;    }    default:      return data;  }}const obj1 = { a: 1, b: 2, c: 3 };const obj2 = deepCopy(obj1);console.log(obj1 === obj2); // false     formatDate        /** * 日付フォーマット。 * @method formatDate * @param {string|date} time * @return {string} */export function formatDate(time, format = &#39;yyyy-MM-dd hh:mm:ss&#39;) {  const date = time ? new Date(time) : new Date();  const dateValues = {    &#39;M+&#39;: date.getMonth() + 1, // 月    &#39;d+&#39;: date.getDate(), // 日    &#39;h+&#39;: date.getHours(), // 時    &#39;m+&#39;: date.getMinutes(), // 分    &#39;s+&#39;: date.getSeconds(), // 秒    &#39;q+&#39;: Math.floor((date.getMonth() + 3) / 3), // 四半期    &#39;S&#39;: date.getMilliseconds() // ミリ秒  };  if (/(y{4})/.test(format)) {    format = format.replace(RegExp.$1, (date.getFullYear() + &#39;&#39;).substr(4 - RegExp.$1.length));  }  for (const key in dateValues) {    if (new RegExp(&#39;(&#39; + key + &#39;)&#39;).test(format)) {      const value = dateValues[key].toString();      format = format.replace(RegExp.$1, (RegExp.$1.length === 1) ? value : (&#39;00&#39; + value).substr(value.length));    }  }  return format;}console.log(formatDate(&#39;2024-05-01&#39;)); // &#39;2024-05-01 00:00:00&#39;console.log(formatDate(&#39;2024-05-01&#39;, &#39;yyyy-MM-dd&#39;)); // &#39;2024-05-01&#39;          /** * 日付フォーマット。 * @method formatDate * @param {string|date} time * @return {string} */export function formatDate(time: string | Date, format: string = &#39;yyyy-MM-dd hh:mm:ss&#39;): string {  const date: Date = time ? new Date(time) : new Date();  const dateValues: Record&lt;string, number&gt; = {    &#39;M+&#39;: date.getMonth() + 1, // 月    &#39;d+&#39;: date.getDate(), // 日    &#39;h+&#39;: date.getHours(), // 時    &#39;m+&#39;: date.getMinutes(), // 分    &#39;s+&#39;: date.getSeconds(), // 秒    &#39;q+&#39;: Math.floor((date.getMonth() + 3) / 3), // 四半期    &#39;S&#39;: date.getMilliseconds() // ミリ秒  };  if (/(y{4})/.test(format)) {    format = format.replace(RegExp.$1, (date.getFullYear() + &#39;&#39;).substr(4 - RegExp.$1.length));  }  for (const key in dateValues) {    if (new RegExp(&#39;(&#39; + key + &#39;)&#39;).test(format)) {      const value: string = dateValues[key].toString();      format = format.replace(RegExp.$1, (RegExp.$1.length === 1) ? value : (&#39;00&#39; + value).substr(value.length));    }  }  return format;}console.log(formatDate(&#39;2024-05-01&#39;)); // &#39;2024-05-01 00:00:00&#39;console.log(formatDate(&#39;2024-05-01&#39;, &#39;yyyy-MM-dd&#39;)); // &#39;2024-05-01&#39;     uuid        /** * UUIDを生成します。 * @method uuid * @return {string} */export function uuid(): string {  return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) {    const r = Math.random() * 16 | 0;    const v = c === &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);    return v.toString(16);  });}console.log(uuid()); // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx          /** * UUIDを生成します。 * @method uuid * @return {string} */export function uuid(): string {  return &#39;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#39;.replace(/[xy]/g, function (c) {    const r: number = Math.random() * 16 | 0;    const v: number = c === &#39;x&#39; ? r : (r &amp; 0x3 | 0x8);    return v.toString(16);  });}console.log(uuid()); // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx     download        /** * ファイルをダウンロードします。 * @method download * @param {string} url * @param {string} name */export function download(url, name) {  const aDom = document.createElement(&#39;a&#39;);  aDom.download = name;  aDom.href = url;  document.body.appendChild(aDom);  aDom.click();  aDom.remove();}console.log(download(&#39;word.docx&#39;, &#39;https://www.test.com/word.docx&#39;)); // word.docx          /** * ファイルをダウンロードします。 * @method download * @param {string} url * @param {string} name */export function download(url: string, name: string): void {  const aDom: HTMLAnchorElement = document.createElement(&#39;a&#39;);  aDom.download = name;  aDom.href = url;  document.body.appendChild(aDom);  aDom.click();  aDom.remove();}console.log(download(&#39;word.docx&#39;, &#39;https://www.test.com/word.docx&#39;)); // word.docx     getUrlArg        /** * URLからパラメータ値を取得します。 * @method getUrlArg * @param {string} name * @return {string} */export function getUrlArg(name) {  const search = window.location.search;  const regexp = new RegExp(`(^|&amp;)${name}=([^&amp;]*)(&amp;|$)`);  const arg = search.substr(1).match(regexp);  return arg ? arg[2] : &#39;&#39;;}          /** * URLからパラメータ値を取得します。 * @method getUrlArg * @param {string} name * @return {string} */export function getUrlArg(name: string): string {  const search: string = window.location.search;  const regexp: RegExp = new RegExp(`(^|&amp;)${name}=([^&amp;]*)(&amp;|$)`);  const arg: RegExpExecArray | null = search.substr(1).match(regexp);  return arg ? arg[2] : &#39;&#39;;}     getUrlQuery        /** * URLからクエリパラメータを取得します。 * @method getUrlQuery * @param {string} url * @return {object} */export function getUrlQuery(url) {  const query = url.substring(url.indexOf(&#39;?&#39;) + 1).split(&#39;&amp;&#39;);  const params = {};  query.forEach(item =&gt; {    const key_value = item.split(&#39;=&#39;);    params[key_value[0]] = key_value[1];  });  return params;}const url = &#39;https://www.test.com/query?a=1&amp;b=2&amp;c=3&#39;;console.log(getUrlQuery(url)); // { a: 1, b: 2, c: 3 }          /** * URLからクエリパラメータを取得します。 * @method getUrlQuery * @param {string} url * @return {object} */export function getUrlQuery(url: string): Record&lt;string, string&gt; {  const query: string[] = url.substring(url.indexOf(&#39;?&#39;) + 1).split(&#39;&amp;&#39;);  const params: Record&lt;string, string&gt; = {};  query.forEach(item =&gt; {    const key_value: string[] = item.split(&#39;=&#39;);    params[key_value[0]] = key_value[1];  });  return params;}const url: string = &#39;https://www.test.com/query?a=1&amp;b=2&amp;c=3&#39;;console.log(getUrlQuery(url)); // { a: 1, b: 2, c: 3 }     setUrlQuery        /** * オブジェクト形式をパスパラメータに変換します。 * @method setUrlQuery * @param {object} params * @return {string} */export function setUrlQuery(params) {  const querys = [];  for (const key in params) {    if (params.hasOwnProperty(key)) {      querys.push(key + &#39;=&#39; + params[key]);    }  }  return querys.join(&#39;&amp;&#39;);}const params = { a: 1, b: 2, c: 3 };console.log(setUrlQuery(params)); // &#39;a=1&amp;b=2&amp;c=3&#39;          /** * オブジェクト形式をパスパラメータに変換します。 * @method setUrlQuery * @param {object} params * @return {string} */export function setUrlQuery(params: Record&lt;string, any&gt;): string {  const querys: string[] = [];  for (const key in params) {    if (params.hasOwnProperty(key)) {      querys.push(key + &#39;=&#39; + params[key]);    }  }  return querys.join(&#39;&amp;&#39;);}const params: Record&lt;string, any&gt; = { a: 1, b: 2, c: 3 };console.log(setUrlQuery(params)); // &#39;a=1&amp;b=2&amp;c=3&#39;     getDeepValueOfObject        /** * オブジェクトの深い値を取得します。 * @method getDeepValueOfObject * @param {object|array} object * @param {string} keyPath * @param {any} [defaultValue] * @return {any} */export function getDeepValueOfObject(object, keyPath, defaultValue) {  const isString = typeof keyPath === &#39;string&#39;;  if (!isString) {    console.warn(&#39;[getDeepValueOfObject warn]: keyPath is not a string, type &#39; + typeof keyPath);  }    if (object &amp;&amp; keyPath &amp;&amp; isString) {    const keys = keyPath.split(&#39;.&#39;);    let value = object;    for (let index = 0; index &lt; keys.length; index++) {      const key = keys[index];      if (value[key] !== undefined) {        value = value[key];      } else {        value = defaultValue;      }    }    return value;  } else {    return defaultValue;  }}const obj = {  foo: {    number: 3  },  bar: 2,};const arr = [ obj ];console.log(getDeepValueOfObject(obj, &#39;foo.number&#39;)); // 3console.log(getDeepValueOfObject(obj, &#39;bar.number&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;bar.number&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(obj, &#39;&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(arr, 0)); // undefinedconsole.log(getDeepValueOfObject(arr, &#39;0.foo.number&#39;)); // 3          /** * オブジェクトの深い値を取得します。 * @method getDeepValueOfObject * @param {object|array} object * @param {string} keyPath * @param {any} [defaultValue] * @return {any} */export function getDeepValueOfObject&lt;T&gt;(object: Record&lt;string, any&gt;, keyPath: string, defaultValue?: T): T | any {  const isString: boolean = typeof keyPath === &#39;string&#39;;  if (!isString) {    console.warn(&#39;[getDeepValueOfObject warn]: keyPath is not a string, type &#39; + typeof keyPath);  }    if (object &amp;&amp; keyPath &amp;&amp; isString) {    const keys: string[] = keyPath.split(&#39;.&#39;);    let value: any = object;    for (let index = 0; index &lt; keys.length; index++) {      const key: string = keys[index];      if (value[key] !== undefined) {        value = value[key];      } else {        value = defaultValue;      }    }    return value;  } else {    return defaultValue;  }}const obj = {  foo: {    number: 3  },  bar: 2,};const arr = [ obj ];console.log(getDeepValueOfObject(obj, &#39;foo.number&#39;)); // 3console.log(getDeepValueOfObject(obj, &#39;bar.number&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;bar.number&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(obj, &#39;&#39;)); // undefinedconsole.log(getDeepValueOfObject(obj, &#39;&#39;, &#39;default&#39;)); // &#39;default&#39;console.log(getDeepValueOfObject(arr, 0)); // undefinedconsole.log(getDeepValueOfObject(arr, &#39;0.foo.number&#39;)); // 3     toThousands        /** * 数値を千の区切り形式に変換します。 * @method toThousands * @param {number|string} number * @return {string} */export function toThousands(number) {  if (Math.abs(Number(number)) &gt;= 1000) {    const [integer, float] = (number || 0).toString().split(&#39;.&#39;);    const thousandsInteger = integer.replace(/(\\d)(?=(?:\\d{3})+$)/g, &#39;$1,&#39;);    return thousandsInteger + (float ? &#39;.&#39; + float : &#39;&#39;);  } else {    return number;  }}          /** * 数値を千の区切り形式に変換します。 * @method toThousands * @param {number|string} number * @return {string} */export function toThousands(number: number | string): string {  if (Math.abs(Number(number)) &gt;= 1000) {    const [integer, float]: string[] = (number || 0).toString().split(&#39;.&#39;);    const thousandsInteger: string = integer.replace(/(\\d)(?=(?:\\d{3})+$)/g, &#39;$1,&#39;);    return thousandsInteger + (float ? &#39;.&#39; + float : &#39;&#39;);  } else {    return String(number);  }}     hyperscript        var w = window;var document = w.document;var Text = w.Text;export function h(...args) {  var e = null;  function item(l) {    var r;    function parseClass(string) {      // 私たちの最小限のパーサーは、`#`のようなCSSの特殊文字のエスケープを理解しません。      // それらを使用しないでください。詳細はこちら：      // https://mathiasbynens.be/notes/css-escapes 。      var m = string.split(/([\\.#]?[^\\s#.]+)/);      if (/^\\.|#/.test(m[1])) e = document.createElement(&#39;div&#39;);      forEach(m, function (v) {        var s = v.substring(1, v.length);        if (!v) return;        if (!e) e = document.createElement(v);        else if (v[0] === &#39;.&#39;) e.classList.add(s);        else if (v[0] === &#39;#&#39;) e.setAttribute(&#39;id&#39;, s);      });    }    if (l == null);    else if (&#39;string&#39; === typeof l) {      if (!e) parseClass(l);      else e.appendChild((r = document.createTextNode(l)));    } else if (      &#39;number&#39; === typeof l ||      &#39;boolean&#39; === typeof l ||      l instanceof Date ||      l instanceof RegExp    ) {      e.appendChild((r = document.createTextNode(l.toString())));    }    //これを処理するより良い方法があるかもしれません...    else if (isArray(l)) forEach(l, item);    else if (isNode(l)) e.appendChild((r = l));    else if (l instanceof Text) e.appendChild((r = l));    else if (&#39;object&#39; === typeof l) {      for (var k in l) {        if (&#39;function&#39; === typeof l[k]) {          if (/^on\\w+/.test(k)) {            (function (k, l) {              // クロージャ内でk、lをキャプチャ              if (e.addEventListener) {                e.addEventListener(k.substring(2), l[k], false);              } else {                e.attachEvent(k, l[k]);              }            })(k, l);          } else {            // オブザーバブル            e[k] = l[k]();          }        } else if (k === &#39;style&#39;) {          if (&#39;string&#39; === typeof l[k]) {            e.style.cssText = l[k];          } else {            for (var s in l[k])              (function (s, v) {                if (&#39;function&#39; === typeof v) {                  // オブザーバブル                  e.style.setProperty(s, v());                } else var match = l[k][s].match(/(.*)\\W+!important\\W*$/);                if (match) {                  e.style.setProperty(s, match[1], &#39;important&#39;);                } else {                  e.style.setProperty(s, l[k][s]);                }              })(s, l[k][s]);          }        } else if (k === &#39;attrs&#39;) {          for (var v in l[k]) {            e.setAttribute(v, l[k][v]);          }        } else if (k.substr(0, 5) === &#39;data-&#39;) {          e.setAttribute(k, l[k]);        } else {          e[k] = l[k];        }      }    } else if (&#39;function&#39; === typeof l) {      //オブザーバブルであると仮定します！      var v = l();      e.appendChild((r = isNode(v) ? v : document.createTextNode(v)));    }    return r;  }  while (args.length) item(args.shift());  return e;}function isNode(el) {  return el &amp;&amp; el.nodeName &amp;&amp; el.nodeType;}function forEach(arr, fn) {  if (arr.forEach) return arr.forEach(fn);  for (var i = 0; i &lt; arr.length; i++) fn(arr[i], i);}function isArray(arr) {  return Object.prototype.toString.call(arr) == &#39;[object Array]&#39;;}          export interface HyperElementTagNameMap extends HTMLElementTagNameMap {  [customTagName: `${string}-${string}`]: HTMLElement;}export interface CSSStyleAttributes {  style?: string | Partial&lt;CSSStyleDeclaration&gt;;}export function hyperscript&lt;T extends keyof HyperElementTagNameMap&gt;(  tagName: string,  attributes?: (CSSStyleAttributes &amp; Record&lt;string, unknown&gt; &amp; Partial&lt;GlobalEventHandlers&gt;) | null,  children?: string | HTMLElement | ChildNode | (HTMLElement | ChildNode)[]): HyperElementTagNameMap[T] {  const tagNameWithCssSelectorArr: string[] = tagName.split(/(?=[.#])/);  const pureTagName: string = tagNameWithCssSelectorArr.shift();  const element = document.createElement(pureTagName) as HyperElementTagNameMap[T];  tagNameWithCssSelectorArr.forEach((item: string) =&gt; {    const selectorName: string = item.substring(1, item.length);    if (item[0] === &#39;.&#39;) {      element.classList.add(selectorName);    } else if (item[0] === &#39;#&#39;) {      element.setAttribute(&#39;id&#39;, selectorName);    }  });  if (attributes) {    for (const attributeName in attributes) {      const attributeValue: unknown = attributes[attributeName];      if (attributeName === &#39;style&#39;) {        if (typeof attributeValue === &#39;string&#39;) {          element.style.cssText = attributeValue;        } else if (attributeValue instanceof CSSStyleDeclaration) {          for (const styleName in attributeValue) {            element.style.setProperty(styleName, attributeValue[styleName]);          }        }      } else if (/on[a-zA-Z]+/.test(attributeName) &amp;&amp; typeof attributeValue === &#39;function&#39;) {        if (element.addEventListener) {          element.addEventListener(            attributeName.substring(2).toLocaleLowerCase(),            attributeValue as (event: Event) =&gt; void,            false          );        }      } else if (attributeName === &#39;attrs&#39; &amp;&amp; typeof attributeValue === &#39;object&#39;) {        for (const key in attributeValue) {          setAttribute(element, key, attributeValue[key]);        }      } else if (attributeName.substr(0, 5) === &#39;data-&#39;) {        setAttribute(element, attributeName, attributeValue);      } else {        element[attributeName] = attributeValue;      }    }  }  if (children) {    if (typeof children === &#39;string&#39;) {      const child = document.createTextNode(children);      appendChild(element, child);    } else if (children instanceof Array) {      children.forEach(child =&gt; {        appendChild(element, child);      });    } else {      appendChild(element, children);    }  }  return element;}function setAttribute(element: HTMLElement, attributeName: string, attributeValue: unknown): void {  switch (typeof attributeValue) {    case &#39;number&#39;:    case &#39;boolean&#39;:      element.setAttribute(attributeName, attributeValue.toString());      break;    case &#39;string&#39;:    default:      element.setAttribute(attributeName, attributeValue as string);      break;  }}function appendChild(parent: HTMLElement, child: HTMLElement | ChildNode | Text): void {  if (parent.tagName.toLocaleLowerCase() === &#39;template&#39;) {    (parent as HTMLTemplateElement).content.appendChild(child);  } else {    parent.appendChild(child);  }}","categories":["notes"]},{"title":"きゅうりとソーセージの炒め物","url":"/ja/2020/12/05/sauteed-cucumber-sausage.html","content":"材料   材料   量   きゅうり   1本   ソーセージ   2本   油   適量   ニンニク   適量   塩   適量   鶏ガラスープの素   適量   醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    ニンニクをみじん切りにして皿に盛る   3.    きゅうりを薄切りにする   4.    ソーセージを斜めにスライスする   5.    フライパンを熱し、油を入れてソーセージを炒め、表面が少し焦げたら皿に取る   6.    別の油でニンニクを炒めて香りを出す   7.    きゅうりを加えて均一に炒める   8.    ソーセージ、塩、醤油、鶏ガラスープの素を加えて均一に炒める   9.    仕上げる   10.    盛り付ける","categories":["cookbooks"]},{"title":"セロリと肉の炒め物","url":"/ja/2020/11/30/celery-fried-meat.html","content":"材料   材料   量   セロリ   200グラム   鶏むね肉   半分   油   適量   ニンニク   適量   コショウ   適量   でんぷん   適量   塩   適量   醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：ニンニクをスライスする   3.    セロリを切って、下茹でする   4.    肉をスライスし、水気を取って、醤油・コショウ・でんぷんを加える   5.    粘り気が出るまで混ぜる   6.    油を中火で熱し、調味料を入れて香りを出す   7.    肉を入れて炒める   8.    セロリを加え、少量の水を加えて強火で炒める   9.    塩と少しの濃口醤油を加えて炒める   10.    仕上げる   11.    盛り付ける","categories":["cookbooks"]},{"title":"セロリとソーセージの卵炒め","url":"/ja/2020/11/29/scrambled-eggs-with-celery-sausage.html","content":"材料   材料   量   セロリ   150グラム   ソーセージ   2本   卵   2個   油   少量   ニンニク   適量   塩   適量   醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    ニンニクをみじん切りにして用意する   3.    セロリをカットする   4.    ソーセージをスライスする   5.    卵を溶きほぐす   6.    フライパンを熱し、油を入れて卵を炒めて固め、取り出しておく   7.    フライパンを熱し、油を入れてソーセージを炒める   8.    ソーセージの表面が少し焦げたらニンニクとセロリを加えて炒める   9.    卵、塩、醤油を加えて味をなじませる   10.    仕上げる   11.    盛り付ける","categories":["cookbooks"]},{"title":"手で裂いた鶏肉","url":"/ja/2020/11/27/hand-tore-the-chicken.html","content":"材料   材料   量   骨なし鶏もも肉   2枚   ショウガ   適量   料理酒   適量   ネギ   適量   ニンニク   適量   唐辛子粉   適量   塩   適量   醤油   適量   ごま油   適量   花椒油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    鶏肉を茹でる調味料：ネギのぶつ切り、ショウガのスライス、塩、料理酒   3.    鍋に鶏もも肉と茹でる調味料を入れ、水を加えて約20分煮る   4.    その間に漬けダレを準備：ネギのぶつ切り、ニンニクのみじん切り、唐辛子粉、塩、醤油、花椒油、ごま油   5.    鶏肉が茹で上がったら取り出して手で裂く   6.    漬けダレを加えてよく和える   7.    盛り付ける","categories":["cookbooks"]},{"title":"麻辣手羽中","url":"/ja/2020/10/31/spicy-chicken-medium-wing.html","content":"材料   材料   量   手羽中   4本   油   少量   ネギ   適量   ショウガ   適量   ニンニク   適量   八角   2個   乾燥唐辛子   適量   花椒   適量   塩   適量   醤油   適量   濃口醤油   適量   ごま油   適量   手羽中は必ず下茹でしてアクを取ること。そうしないと臭みが残る。   作り方の手順   画像   手順   1.    材料を準備する   2.    ネギを小口切り、ニンニクをみじん切り、ショウガをスライスし、乾燥唐辛子・花椒・八角と一緒に用意する   3.    手羽中を解凍し、洗って切り込みを入れる（味を染み込ませたい場合は爪楊枝で刺してもよい）   4.    フライパンを熱し、油を入れて手羽中を表面がきつね色になるまで炒める   5.    ネギ、ニンニク、唐辛子、花椒、八角を加えて香りを出す   6.    半カップの水、醤油、濃口醤油、塩を加える   7.    汁気が少なくなったらごま油を加えて仕上げる   8.    盛り付ける","categories":["cookbooks"]},{"title":"青菜と肉の炒め物","url":"/ja/2020/10/31/green-vegetables-meat.html","content":"材料   材料   量   青菜   250グラム   鶏むね肉   半分   油   多め   ニンニク   適量   唐辛子の輪切り   適量   花椒   適量   塩   適量   醤油   適量   濃口醤油   適量   青菜から水分を出さないコツ：油を多めに使い、最後に塩を加えること。   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：ニンニクをスライス、花椒、唐辛子の輪切り   3.    青菜を洗って下茹でする   4.    肉をスライスし、水気を取って、でんぷん・醤油・少量の濃口醤油を加える   5.    粘り気が出るまで混ぜる   6.    油を中火で熱し、ニンニク・唐辛子の輪切り・花椒を入れて香りを出す   7.    肉を加えて炒め、火が通るまで炒める   8.    青菜を加えて強火で炒める   9.    最後に塩を加えてさっと炒めて味をなじませる   10.    仕上げる   11.    盛り付ける","categories":["cookbooks"]},{"title":"じゃがいもと肉の煮込み","url":"/ja/2020/10/21/potato-cubes-stew-with-meat.html","content":"材料   材料   量   じゃがいも   400グラム   鶏むね肉   半分   油   適量   ネギ   適量   ショウガ   適量   ニンニク   適量   唐辛子の輪切り   適量   花椒   適量   ローレル   1枚   塩   適量   濃口醤油   少量   醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    調味料を準備：ネギのみじん切り、ニンニクのみじん切り、唐辛子の輪切り、花椒   3.    じゃがいもを一口大に切り、水に浸して変色を防ぐ   4.    肉をスライスし、水気を取る   5.    油を熱し、調味料を入れて香りを出す   6.    中火で肉を炒める   7.    じゃがいもを加えて均一に炒める   8.    醤油、濃口醤油、塩を加えて強火で炒める   9.    ローレルを加え、水を材料がかぶるくらい入れて強火で煮詰める   10.    仕上げる   11.    盛り付ける","categories":["cookbooks"]},{"title":"じゃがいもと豚肉の細切り炒め","url":"/ja/2020/10/21/potato-with-meat-shreds.html","content":"材料   材料   量   じゃがいも   250グラム   豚肉   120グラム   油   適量   ピーマン   適量   ニンニク   適量   乾燥唐辛子   適量   花椒   適量   塩   適量   醤油   適量   作り方の手順   画像   手順   1.    材料を準備する   2.    ピーマンを細切り、ニンニクをスライスし、唐辛子と花椒と一緒に用意する   3.    じゃがいもを細切りにし、でんぷんを落とすために洗い、水に浸して変色を防ぐ   4.    豚肉を細切りにする   5.    肉の細切りを解凍し、余分な水分を取る   6.    フライパンを熱し、油が煙を上げたら肉を入れて香りが出るまで炒める（肉に水分があると油がはねるので注意）   7.    ピーマンや調味料を加えて炒め、香りを出す   8.    じゃがいもの細切りを加えて均一に炒め、醤油と塩を加えて味をなじませる   9.    仕上げる   10.    盛り付ける","categories":["cookbooks"]},{"title":"フロントエンドの自動 GitHub Page デプロイ","url":"/ja/2019/12/05/deploy-github-page.html","content":"自分のプロジェクトを GitHub Page にデプロイするのは面倒で、まず build してからファイルを master/docs または gh-pages ブランチに push する必要があります。今は github にこれらの手順を自動化できるプラグインがあります：   github アドレス：   gh-pages   インストール：   $ npm install gh-pages --save-dev   注意：このモジュールは git バージョン 1.9 以上が必要です   設定：   package.json の script フィールドに以下を追加します   &quot;scripts&quot;: {  &quot;deploy&quot;: &quot;npm run build &amp; gh-pages -d dist&quot;,}   次に    npm run deploy    を実行すると、まず build コマンドが実行され、その後このプロジェクトの gh-pages ブランチに build したファイルが push されます。その後、github プロジェクトの Settings &gt; GitHub Pages の Sourse で gh-pages branch を選択し、数分待ってから URL を開いて確認します。   https://${username}.github.io/${project}   コマンドライン引数の説明   引数   説明   -d   push するファイルのディレクトリ。ここではプロジェクトルートの dist フォルダ。   -m   push メッセージ。メッセージが長く空白を含む場合は json で    -m \\&quot;Update GitHub Page\\&quot;    のようにダブルクォートで囲む必要があります。   -b   push するブランチ。デフォルトは gh-pages   詳細な引数は以下のコマンドで確認できます   $ gh-pages --help","categories":["guides"]},{"title":"荒れ狂う波、ある老水兵の実体験","url":"/ja/2019/10/31/wave-and-sky.html","content":"","categories":["reprints"]},{"title":"画像 JPEG 表示最適化","url":"/ja/2019/10/31/gradual-jpeg.html","content":"1. JPEG の紹介   JPEG は Joint Photographic Experts Group（画像専門家グループ）の略称で、最初の国際画像圧縮標準です。JPEG 画像圧縮アルゴリズムは良好な圧縮性能を提供しながら、比較的良い再構築品質を持ち、画像・動画処理分野で広く使用されています。   2. 保存方式   JPEG ファイル形式には2つの保存方式があります。Baseline JPEG と Progressive JPEG です。両形式は同じサイズと画像データを持ち、拡張子も同じですが、唯一の違いは表示方式です。   2.1 Baseline JPEG （ベースライン）   このタイプの JPEG ファイルは上から下へのスキャン方式で、各行を順番に JPEG ファイルに保存します。このファイルを開いて内容を表示する時、データは保存時の順序で上から下へ一行ずつ表示され、すべてのデータが読み込まれるまで続き、画像全体の表示が完了します。ファイルが大きいかネットワークのダウンロード速度が遅い場合、画像が一行ずつ読み込まれる効果が見られます。この形式の JPEG には特に利点がないため、一般的に Progressive JPEG の使用が推奨されています。   2.2 Progressive JPEG （プログレッシブ）   Baseline の一度のスキャンとは異なり、Progressive JPEG ファイルは複数回のスキャンを含み、これらのスキャンが順番に JPEG ファイルに保存されます。ファイルを開く過程で、まず画像全体のぼやけた輪郭が表示され、スキャン回数が増えるにつれて画像が徐々に鮮明になります。この形式の主な利点は、ネットワークが遅い場合でも画像の輪郭を見ることができ、読み込み中の画像が何であるかを知ることができることです。一部のウェブサイトで大きな画像を開く時、この技術に気づくでしょう。   3. 作成方法   Photoshop を使用   ファイル &gt; 別名で保存 &gt; 保存をクリック後、JPEG オプションが表示されます   プログレッシブ JPEG を作成したい場合は、連続を選択   4. 応用   基本 JPEG とプログレッシブ JPEG はいつ使用すべきか？   JPEG 画像が 10K 未満の場合、基本 JPEG として保存するのが最適です（約75％の確率でより小さくなります）10K を超えるファイルの場合、プログレッシブ JPEG がより良い圧縮を提供します（94％の場合）Chrome + Firefox + IE9 ブラウザでは、プログレッシブ画像の読み込みがより速く、大幅に速くなります。他のブラウザでは、基本画像の読み込みと同等で、少なくとも遅れることはありません。   プログレッシブ画像にも欠点があり、CPU とメモリを消費します。","categories":["guides"]},{"title":"母鶏とフロントエンドエンジニア","url":"/ja/2019/10/25/hen-and-front-end-engineer.html","content":"","categories":["reprints"]},{"title":"RegExp","url":"/ja/2019/10/22/regexp.html","content":"JavaScript RegExp オブジェクト   構文   var regexp = new RegExp(pattern, modifiers);    // 通过 RegExp 构造函数创建var regexp = /[pattern]/[modifiers];            // 通过字面量创建   pattern（パターン）は式のパターンを記述します   modifiers（修飾子）はグローバルマッチ、大小文字の区別、複数行マッチを指定します   注意：コンストラクタで正規表現オブジェクトを作成する場合、通常の文字エスケープルール（バックスラッシュ \\ を前に付ける）が必要です。例えば、次は等価です：   var regexp = new RegExp(&#39;\\\\w+&#39;);var regexp = /\\w+/;   修飾子   修飾子（Modifiers）はグローバルマッチ、大小文字の区別、複数行マッチを指定します：   修飾子   説明   i   大小文字を区別しないマッチを実行します。   g   グローバルマッチ（すべての一致を検索、最初の一致で停止しない）を実行します。   m   複数行マッチを実行します。   s   . で改行文字もマッチできるようにします。   u   unicode コードのパターンでマッチします。   y   &quot;粘着（sticky）&quot;検索を実行し、ターゲット文字列の現在位置からマッチします。   量指定子   量指定子（Quantifiers）は繰り返しマッチする文字の回数や範囲を定義します：   量指定子   説明   n+   少なくとも1つの n を含む文字列にマッチします。   n*   0個以上の n を含む文字列にマッチします。   n?   0個または1個の n を含む文字列にマッチします。   n{X}   X 個の n の並びにマッチします。   n{X,}   最低 x 個、最大 y 個の n の並びにマッチします。   n{X,Y}   少なくとも x 個の n の並びにマッチします。   ^n   n で始まる文字列にマッチします。   n$   n で終わる文字列にマッチします。   ?=n   直後に指定文字列 n が続く場合にマッチします。   ?!n   直後に指定文字列 n が続かない場合にマッチします。   メタ文字   メタ文字（Metacharacter）は特別な意味を持つ文字です：   メタ文字   説明   .   （ドット）デフォルトで   改行以外   の任意の1文字にマッチします。   \\w   単語文字（数字、英字、アンダースコア）にマッチします。   \\W   非単語文字にマッチします。   \\d   数字にマッチします。   \\D   非数字文字にマッチします。   \\s   空白文字にマッチします。   \\S   非空白文字にマッチします。   \\b   単語境界にマッチします。   \\B   非単語境界にマッチします。   \\0   NULL 文字にマッチします。   \\n   改行文字にマッチします。   \\f   改ページ文字にマッチします。   \\r   復帰文字にマッチします。   \\t   タブ文字にマッチします。   \\v   垂直タブにマッチします。   \\xxx   8進数 xxx で指定された文字にマッチします。   \\xdd   16進数 dd で指定された文字にマッチします。   \\uxxxx   16進数 xxxx で指定された Unicode 文字にマッチします。   角括弧   角括弧は特定の範囲の文字を検索するために使います：   式   説明   [^]   任意の文字にマッチします。（   改行もマッチ可能   ）   [abc]   角括弧内の任意の文字にマッチします。   [^abc]   角括弧内にない任意の文字にマッチします。   [0-9]   0 から 9 までの任意の数字にマッチします。   [a-z]   小文字 a から小文字 z までの任意の文字にマッチします。   [A-Z]   大文字 A から大文字 Z までの任意の文字にマッチします。   [A-z]   大文字 A から小文字 z までの任意の文字にマッチします。   (red|blue|green)   指定されたいずれかの選択肢にマッチします。   RegExp オブジェクトのメソッド   式   説明   compile   正規表現をコンパイルします。   exec   文字列内で指定値を検索します。見つかった値とその位置を返します。   test   文字列内で指定値を検索します。true または false を返します。   正規表現をサポートする String オブジェクトのメソッド   式   説明   search   正規表現に一致する値を検索します。   match   1つまたは複数の正規表現の一致を見つけます。   replace   正規表現に一致する部分文字列を置換します。   split   文字列を配列に分割します。   複数行テキストで正規表現を使う   var string = &#39;Please yes\\nmake my day!&#39;;string.match(/yes.*day/); // nullstring.match(/yes[^]*day/); // &#39;yes\\nmake my day&#39;   先読みアサーションと否定先読みアサーション   先読みアサーション（lookahead）は、xがyの前にある場合のみマッチします。/x(?=y)/ のように書きます。例えば、パーセント記号の前の数字だけをマッチさせるには /\\d+(?=%)/ と書きます。   var string = &#39;100% of US presidents have been male&#39;;/\\d+(?=%)/.exec(string); // [&#39;100&#39;]/have(?=%)/.exec(string); // null   否定先読みアサーション（negative lookahead）は、xがyの前にない場合のみマッチします。/x(?!y)/ のように書きます。例えば、パーセント記号の前でない数字だけをマッチさせるには /\\d+(?!%)/ と書きます。   var string = &#39;that&#39;s all 44 of them&#39;;/\\d+(?!%)/.exec(string); // [&#39;44&#39;]/\\d+(?!.*of)/.exec(string); // null/\\d+(?!.*all)/.exec(string); // [&#39;44&#39;]/\\d+(?!.*of|.*all)/.exec(string); // null   後読みアサーションと否定後読みアサーション   ES2018 で後読みアサーションが導入され、V8 エンジン 4.9（Chrome 62）以降でサポートされています。後読みアサーション（lookbehind）は、xがyの後にある場合のみマッチします。/(?&lt;=y)x/ のように書きます。例えば、ドル記号の後の数字だけをマッチさせるには /(?&lt;=$)d+/ と書きます。   var string = &#39;Benjamin Franklin is on the $100 bill&#39;;/(?&lt;=\\$)\\d+/.exec(string);  // [&quot;100&quot;]   否定後読みアサーション（negative lookbehind）は、xがyの後にない場合のみマッチします。/(?&lt;!y)x/ のように書きます。例えば、ドル記号の後でない数字だけをマッチさせるには /(?&lt;!\\$)d+/ と書きます。   var string = &#39;it&#39;s is worth about €90&#39;;/(?&lt;!\\$)\\d+/.exec(string);  // [&quot;90&quot;]   貪欲モードと非貪欲モード   貪欲モード: 正規表現は通常、できるだけ長くマッチしようとします。   var html = &#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;;var regexp = /(&lt;.*&gt;)/;html.match(regexp); // [&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;]   非貪欲モード: 最小限のマッチを試みます。   var html = &#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;;var regexp = /(&lt;.*?&gt;)/;html.match(regexp); // [&#39;&lt;html&gt;&#39;]   6種類の繰り返しの非貪欲マッチの簡単な説明：   {n,m}?：できるだけ n 回マッチしますが、条件を満たすために最大 m 回まで繰り返すこともあります。   {n}?：できるだけ n 回マッチします。   {n,}?：できるだけ n 回マッチしますが、条件を満たすために任意回数繰り返すこともあります。   ??：できるだけマッチしますが、条件を満たすために最大1回までマッチします（{0,1}? と同等）。   +?：できるだけ1回マッチしますが、条件を満たすために任意回数繰り返すこともあります（{1,}? と同等）。   *? ：できるだけマッチしませんが、条件を満たすために任意回数繰り返すこともあります（{0,}? と同等）。   キャプチャグループと非キャプチャグループ   キャプチャグループ ()：キャプチャグループは各グループでマッチした内容を一時的に保存し、次回利用できます。JavaScript では $1, $2, $3… の形式で保存されます。そのためキャプチャグループはパフォーマンスに影響します。   var string = &#39;sjds24324abcabc1234&#39;;var regexp = /(abc){2}/;string.match(regexp); // [&#39;abcabc&#39;, &#39;abc&#39;]   非キャプチャグループ (?:)：非キャプチャグループは各グループのマッチ内容を保存せず、結果のみ返します。したがってマッチ速度が向上します。   var string = &#39;sjds24324abcabc1234&#39;;var regexp = /(?:abc){2}/;string.match(regexp); // [&#39;abcabc&#39;]   正規表現の名前付きグループキャプチャ   名前付きグループキャプチャは ?&lt;name&gt; 記法を使い、マッチした結果を名前でアクセスできます。グループがマッチしなかった場合、groups オブジェクトの該当プロパティは undefined になります。   var date = &#39;2023-01-01&#39;;var regexp = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u;regexp.exec(&#39;2023-01-01&#39;); // { year: &#39;2023&#39;, month: &#39;01&#39;, day: &#39;01&#39; }","categories":["notes"]},{"title":"VSCode","url":"/ja/2019/09/21/vscode-configuration.html","content":"コードフォーマットのショートカット：            ```    Shift + Alt + F    ```              ```    Shift (⇧) + Option (⌥) + F    ```              ```    Ctrl + Shift + I    ```     ショートカット設定：   Redo（やり直し）：            ```    Ctrl + Shift + Z   ->   Ctrl + Y    ```              ```    Command (⌘) + Shift (⇧) + Z   ->   Command (⌘) + Y    ```     Copy Line Down（行を素早くコピー）:            ```    Shift + Alt + ↓   ->   Ctrl + D    ```              ```    Shift (⇧) + Option (⌥) + ↓   ->   Command (⌘) + D    ```     Transform to Uppercase（大文字に変換）:            ```    Null   ->   Ctrl + Shift + U    ```              ```    Null   ->   Command (⌘) + Shift (⇧) + U    ```     Transform to Lowercase（小文字に変換）:            ```    Null   ->   Ctrl + Shift + L    ```              ```    Null   ->   Command (⌘) + Shift (⇧) + L    ```     プラグイン   GitLens   ：特定の行のコードが誰によって書かれたかを表示   vscode-fileheader   ：ファイルの作者・修正情報を表示   ESLint   ：プロジェクトの eslint 設定ファイルを使用してコードをチェック   Prettier - Code formatter   ：prettier でコードをフォーマット   Tailwind CSS IntelliSense   ：Tailwind css の構文ヒントプラグイン   {  &quot;recommendations&quot;: [    &quot;eamodio.gitlens&quot;,    &quot;dbaeumer.vscode-eslint&quot;,    &quot;esbenp.prettier-vscode&quot;,    &quot;bradlc.vscode-tailwindcss&quot;  ]}   VSCode エディタ設定：   {  &quot;editor.detectIndentation&quot;: true,  &quot;editor.tabSize&quot;: 2,  &quot;files.eol&quot;: &quot;\\n&quot;,  &quot;files.autoSave&quot;: &quot;off&quot;,}   インデント    Indentation   detectIndentation    - ファイルを開く時にファイル内容に基づいて &quot;editor.tabSize&quot; と &quot;editor.insertSpaces&quot; を自動検出するかどうかを制御します。   tabSize    - タブ文字に相当するスペース数。 &quot;editor.detectIndentation&quot; が有効な場合、この設定はファイル内容に基づいて上書きされます。   insertSpaces    - &quot;Tab&quot; キーを押した時にスペースを挿入します。 &quot;editor.detectIndentation&quot; が有効な場合、この設定はファイル内容に基づいて上書きされます。   {  &quot;editor.detectIndentation&quot;: true,  &quot;editor.tabSize&quot;: 2,  &quot;editor.insertSpaces&quot;: true}   行終端文字   デフォルトの行終端文字。   値   説明   \\n   LF (Linux)   \\r\\n   CRLF (Windows)   auto   Uses operating system specific end of line character.   {  &quot;files.eol&quot;: &quot;\\n&quot;,  // Configure settings to be overridden for the shellscript language.  &quot;[shellscript]&quot;: {    &quot;files.eol&quot;: &quot;\\n&quot;  }}   自動保存    Auto Save   値   説明   off   to disable auto save.   afterDelay   to save files after a configured delay (default 1000 ms).   onFocusChange   to save files when focus moves out of the editor of the dirty file.   onWindowChange   to save files when the focus moves out of the VS Code window.   {  &quot;files.autoSave&quot;: &quot;off&quot;,  &quot;files.autoSaveDelay&quot;: 1000}   自動フォーマット    Formatting   formatOnSave    - 保存時にコードファイルをフォーマット   formatOnType    - 入力後にその行のコードをフォーマット   formatOnPaste    - 貼り付け内容をフォーマット   {  &quot;editor.formatOnSave&quot;: true,  &quot;editor.formatOnType&quot;: false,  &quot;editor.formatOnPaste&quot;: false}   デフォルトフォーマッタ    Default formatter   dbaeumer.vscode-eslint    - Eslint Plugin.   esbenp.prettier-vscode    - Prettier - Code formatter.   {  // 将根据eslint配置格式化代码  &quot;editor.defaultFormatter&quot;: &quot;dbaeumer.vscode-eslint&quot;}   改行   コードの長さがエディタの表示幅を超えた場合に改行するかどうか   {  &quot;editor.wordWrap&quot;: &quot;on&quot;}   省略記法の展開    Emmet   ショートカット構文でタグを展開します。例：ul&gt;li*3&gt;span.hello   {  &quot;emmet.triggerExpansionOnTab&quot;: true}   スティッキースクロール    Sticky Scroll   https://code.visualstudio.com/updates/v1_85#_sticky-scroll-in-trees   {  &quot;workbench.tree.enableStickyScroll&quot;: false,  &quot;editor.stickyScroll.enabled&quot;: false}   その他        dragAndDrop    - エディタでドラッグアンドドロップを許可するかどうかを制御します。     ignoreRecommendations    - true に設定すると推奨プラグインのプッシュを禁止できます。   詳細はこちら        proxy    - エディタのプロキシ設定   {  &quot;editor.dragAndDrop&quot;: false,  &quot;extensions.ignoreRecommendations&quot;: true,  &quot;http.proxy&quot;: &quot;http://127.0.0.1:1000&quot;}","categories":["notes"]},{"title":"Webstorm","url":"/ja/2019/09/20/webstorm-configuration.html","content":"中文字体の設定   Show only monospaced fonts のチェックを外す   Font：consolas   Size：14   Line spacing: 1.2   Fallback font：Microsoft YaHei   コードフォーマットのショートカット：   Ctrl + Alt + L   キーボードショートカット：   Add Or Remove Caret（マルチカーソル）:   Alt+ Button1 Click   Redo（やり直し）:   Ctrl + Shift + Z   Expand Live Template / Emmet Abbreviation（タグの展開）:   Tab   Fix ESLint Problems（ESLint エラーの修正）:   Alt + Shift + L   波括弧と角括弧の間にスペースを追加する設定：   Setting &gt; Editor &gt; Code Style &gt; JavaScript &gt; Space で Within を見つけ、以下の項目にチェックを入れる：   Object literal braces   ES6 import/export braces   Array brackets   Interpolation expressions   ESLint の設定   Setting &gt; Plugins で ESLint プラグインをインストール   Setting &gt; ESLint Settings で設定   Setting で ESLint を検索するか、Setting &gt; Languages &amp; Frameworks &gt; JavaScript &gt; Code Quality Tools &gt; ESLint を探す   webstorm の自動保存を無効にする   ステップ1：   Settings &gt; Appearance &amp; Behavior &gt; System Settings&gt; Synchronization   &gt; Synchroniza files on frame or editor tab activation           // 激活当前窗口时保存   &gt; Save files on frame deactivation                                       // 切换到其他窗口时保存   &gt; Save files automatically if application is idle for  15 sec.    // 设定一个时间自动保存   &gt; Use &quot;safe write&quot; (save changes to a temporary file first)    // 安全写入,这个选项会不停的保存源文件,因此关闭最后一个就好   ステップ2：   Settings &gt; Editor &gt; General &gt; Editor Tabs&gt; Appearance   &gt; Mark modified(*)   // 被修改的文件会出现 * 号（在文件图标右下角）","categories":["notes"]}]